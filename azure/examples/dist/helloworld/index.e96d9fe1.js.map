{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,gB,I,A,E,S,a,E,E,E,O,C,qB,I,A,E,S,kB,E,E,E,O,C,gB,I,A,E,S,a,E,E,E,O,C,qB,I,A,E,S,kB,E,E,E,O,C,sB,I,A,E,S,mB,E,E,E,O,C,kB,I,A,E,S,e,E,E,E,O,C,mB,I,A,E,S,gB,E,E,E,O,C,a,I,A,E,S,U,E,E,E,O,C,6B,I,A,E,S,0B,E,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,Q,G,E,Q,S,C,C,C,E,E,E,O,C,c,I,G,I,E,E,S,E,E,S,E,E,QGYM,OAAO,EACV,OAA6B,AAC7B,CAAA,OAAsB,AACtB,CAAA,QAAuB,AACvB,CAAA,KAA4B,AAIpB,CAAA,WAAW,CAAiC,CAA5C,CACL,MAAO,CACJ,GAAG,CAAO,CACV,sBAAsB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CACvD,CACJ,CAEA,MAAM,SAAS,CAAiB,CAAE,CAAiC,CAAnE,KACO,EASA,EARJ,GAAI,CAED,GAAI,CAAC,AADL,CAAA,EAAS,MAAM,MAAM,EAArB,EACc,EAAE,CAAE,MAAM,AAAI,MAAM,iCAAiC,EAAW,MAAM,EAAS,UAAU,CAC1G,CAAE,MAAM,EAAS,CAEd,MADA,QAAQ,GAAG,CAAC,+BAA+B,GACrC,CACT,CAGA,GAAI,CACD,IAAM,EAAY,MAAM,EAAS,WAAW,GAC5C,EAAW,MAAM,YAAY,WAAW,CAAC,EAAW,CAAC,IAAK,IAAI,CAAC,UAAU,CAAC,EAAQ,EACrF,CAAE,MAAM,EAAS,CAEd,MADA,QAAQ,GAAG,CAAC,2BAA6B,EAAO,CAAA,EAAI,KAAK,CAAG,KA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","sources":["<anon>","../source/twr-ts/index.ts","../lib-js/twrwasmbase.js","../source/twr-ts/twrwasmbase.ts","../lib-js/twrwasmmem.js","../source/twr-ts/twrwasmmem.ts","../lib-js/twrliblocale.js","../source/twr-ts/twrliblocale.ts","../lib-js/twrlibrary.js","../source/twr-ts/twrlibrary.ts","../lib-js/twreventqueue.js","../source/twr-ts/twreventqueue.ts","../lib-js/twrcircular.js","../source/twr-ts/twrcircular.ts","../lib-js/twrwasmcall.js","../source/twr-ts/twrwasmcall.ts","../lib-js/twrmod.js","../source/twr-ts/twrmod.ts","../lib-js/twrmodutil.js","../source/twr-ts/twrmodutil.ts","../lib-js/twrcondiv.js","../source/twr-ts/twrcondiv.ts","../lib-js/twrcon.js","../source/twr-ts/twrcon.ts","../lib-js/twrconcanvas.js","../source/twr-ts/twrconcanvas.ts","../lib-js/twrconterm.js","../source/twr-ts/twrconterm.ts","../lib-js/twrcondebug.js","../source/twr-ts/twrcondebug.ts","../lib-js/twrlibbuiltin.js","../source/twr-ts/twrlibbuiltin.ts","../lib-js/twrlibmath.js","../source/twr-ts/twrlibmath.ts","../lib-js/twrlibtimer.js","../source/twr-ts/twrlibtimer.ts","../lib-js/twrlibaudio.js","../source/twr-ts/twrlibaudio.ts","../lib-js/twrlibdate.js","../source/twr-ts/twrlibdate.ts","../lib-js/twrcondummy.js","../source/twr-ts/twrcondummy.ts","../lib-js/twrmodasync.js","../source/twr-ts/twrmodasync.ts","../../../Users/awood/AppData/Roaming/npm/node_modules/parcel/node_modules/@parcel/runtime-js/lib/runtime-d2e44ea23d7e8cca.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire8dfc\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire8dfc\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"57pKS\", function(module, exports) {\n$parcel$export(module.exports, \"twrWasmModule\", () => (parcelRequire(\"5baAq\")).twrWasmModule);\n$parcel$export(module.exports, \"twrWasmModuleAsync\", () => (parcelRequire(\"U6Thw\")).twrWasmModuleAsync);\n$parcel$export(module.exports, \"twrConsoleDiv\", () => (parcelRequire(\"8wznr\")).twrConsoleDiv);\n$parcel$export(module.exports, \"twrConsoleTerminal\", () => (parcelRequire(\"a7Sa2\")).twrConsoleTerminal);\n$parcel$export(module.exports, \"keyEventToCodePoint\", () => (parcelRequire(\"4Jz48\")).keyEventToCodePoint);\n$parcel$export(module.exports, \"twrConsoleDebug\", () => (parcelRequire(\"9kgjF\")).twrConsoleDebug);\n$parcel$export(module.exports, \"twrConsoleCanvas\", () => (parcelRequire(\"8vcno\")).twrConsoleCanvas);\n$parcel$export(module.exports, \"twrLibrary\", () => (parcelRequire(\"9lAov\")).twrLibrary);\n$parcel$export(module.exports, \"twrLibraryInstanceRegistry\", () => (parcelRequire(\"9lAov\")).twrLibraryInstanceRegistry);\nparcelRequire(\"jxXdl\");\nparcelRequire(\"5baAq\");\nparcelRequire(\"3tyux\");\nparcelRequire(\"U6Thw\");\nparcelRequire(\"8wznr\");\nparcelRequire(\"a7Sa2\");\nparcelRequire(\"4Jz48\");\nparcelRequire(\"9kgjF\");\nparcelRequire(\"8vcno\");\nparcelRequire(\"9lAov\");\n\n});\nparcelRegister(\"jxXdl\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrWasmBase\", () => $e3af081ed3b5b25b$export$599419144fb0094a);\n\nvar $3tyux = parcelRequire(\"3tyux\");\n\nvar $7KBfz = parcelRequire(\"7KBfz\");\n\nvar $6QEzV = parcelRequire(\"6QEzV\");\nclass $e3af081ed3b5b25b$export$599419144fb0094a {\n    exports;\n    wasmMem;\n    wasmCall;\n    callC;\n    /*********************************************************************/ getImports(imports) {\n        return {\n            ...imports,\n            twr_register_callback: this.registerCallback.bind(this)\n        };\n    }\n    async loadWasm(pathToLoad, imports) {\n        let response;\n        try {\n            response = await fetch(pathToLoad);\n            if (!response.ok) throw new Error(\"Fetch response error on file '\" + pathToLoad + \"'\\n\" + response.statusText);\n        } catch (err) {\n            console.log(\"loadWasm() failed to fetch: \" + pathToLoad);\n            throw err;\n        }\n        let instance;\n        try {\n            const wasmBytes = await response.arrayBuffer();\n            instance = await WebAssembly.instantiate(wasmBytes, {\n                env: this.getImports(imports)\n            });\n        } catch (err) {\n            console.log(\"Wasm instantiate error: \" + err + (err.stack ? \"\\n\" + err.stack : \"\"));\n            throw err;\n        }\n        if (this.exports) throw new Error(\"Unexpected error -- this.exports already set\");\n        if (!instance.instance.exports) throw new Error(\"Unexpected error - undefined instance.exports\");\n        this.exports = instance.instance.exports;\n        const memory = this.exports.memory;\n        if (!memory) throw new Error(\"Unexpected error - undefined exports.memory\");\n        const malloc = this.exports.malloc;\n        const free = this.exports.free;\n        this.wasmMem = new (0, $3tyux.twrWasmMemory)(memory, free, malloc);\n        this.wasmCall = new (0, $7KBfz.twrWasmCall)(this.wasmMem, this.exports);\n        this.callC = this.wasmCall.callC.bind(this.wasmCall);\n    }\n    //see twrWasmModule.constructor - imports - twr_register_callback:this.registerCallback.bind(this), \n    registerCallback(funcNameIdx) {\n        const funcName = this.wasmMem.getString(funcNameIdx);\n        const onEventCallback = this.exports[funcName];\n        return (0, $6QEzV.twrEventQueueReceive).registerCallback(funcName, onEventCallback);\n    }\n}\n\n});\nparcelRegister(\"3tyux\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrWasmMemory\", () => $287ed5d7d50ba8d6$export$d835cdc0f59e6ea8);\n$parcel$export(module.exports, \"twrWasmMemoryAsync\", () => $287ed5d7d50ba8d6$export$f59b88b16ecb0d13);\n\nvar $lVt1a = parcelRequire(\"lVt1a\");\nclass $287ed5d7d50ba8d6$export$ad21274072098225 {\n    memory;\n    mem8;\n    mem16;\n    mem32;\n    memF;\n    memD;\n    constructor(memory){\n        this.memory = memory;\n        this.mem8 = new Uint8Array(memory.buffer);\n        this.mem16 = new Uint16Array(memory.buffer);\n        this.mem32 = new Uint32Array(memory.buffer);\n        this.memF = new Float32Array(memory.buffer);\n        this.memD = new Float64Array(memory.buffer);\n    }\n    // convert a Javascript string into byte sequence that encodes the string using UTF8, or the requested codePage\n    stringToU8(sin, codePage = (0, $lVt1a.codePageUTF8)) {\n        let ru8;\n        if (codePage == (0, $lVt1a.codePageUTF8)) {\n            const encoder = new TextEncoder();\n            ru8 = encoder.encode(sin);\n        } else if (codePage == (0, $lVt1a.codePage1252)) {\n            ru8 = new Uint8Array(sin.length);\n            for(let i = 0; i < sin.length; i++)ru8[i] = (0, $lVt1a.to1252)(sin[i]);\n        } else if (codePage == (0, $lVt1a.codePageASCII)) {\n            ru8 = new Uint8Array(sin.length);\n            for(let i = 0; i < sin.length; i++){\n                const r = (0, $lVt1a.toASCII)(sin[i]);\n                ru8[i] = r;\n            }\n        } else throw new Error(\"unknown codePage: \" + codePage);\n        return ru8;\n    }\n    // copy a string into existing buffer in the webassembly module memory as utf8 (or specified codePage)\n    // result always null terminated\n    copyString(buffer, buffer_size, sin, codePage = (0, $lVt1a.codePageUTF8)) {\n        if (buffer_size < 1) throw new Error(\"copyString buffer_size must have length > 0 (room for terminating 0): \" + buffer_size);\n        const ru8 = this.stringToU8(sin, codePage);\n        let i;\n        for(i = 0; i < ru8.length && i < buffer_size - 1; i++)this.mem8[buffer + i] = ru8[i];\n        this.mem8[buffer + i] = 0;\n    }\n    getLong(idx) {\n        const idx32 = Math.floor(idx / 4);\n        if (idx32 * 4 != idx) throw new Error(\"getLong passed non long aligned address\");\n        if (idx32 < 0 || idx32 >= this.mem32.length) throw new Error(\"invalid index passed to getLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\n        const long = this.mem32[idx32];\n        return long;\n    }\n    setLong(idx, value) {\n        const idx32 = Math.floor(idx / 4);\n        if (idx32 * 4 != idx) throw new Error(\"setLong passed non long aligned address\");\n        if (idx32 < 0 || idx32 >= this.mem32.length - 1) throw new Error(\"invalid index passed to setLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\n        this.mem32[idx32] = value;\n    }\n    getDouble(idx) {\n        const idx64 = Math.floor(idx / 8);\n        if (idx64 * 8 != idx) throw new Error(\"getLong passed non Float64 aligned address\");\n        const long = this.memD[idx64];\n        return long;\n    }\n    setDouble(idx, value) {\n        const idx64 = Math.floor(idx / 8);\n        if (idx64 * 8 != idx) throw new Error(\"setDouble passed non Float64 aligned address\");\n        this.memD[idx64] = value;\n    }\n    getShort(idx) {\n        if (idx < 0 || idx >= this.mem8.length) throw new Error(\"invalid index passed to getShort: \" + idx);\n        const short = this.mem8[idx] + this.mem8[idx + 1] * 256;\n        return short;\n    }\n    // get a string out of module memory\n    // null terminated, up until max of (optional) len bytes\n    // len may be longer than the number of characters, if characters are utf-8 encoded\n    getString(strIndex, len, codePage = (0, $lVt1a.codePageUTF8)) {\n        if (strIndex < 0 || strIndex >= this.mem8.length) throw new Error(\"invalid strIndex passed to getString: \" + strIndex);\n        if (len) {\n            if (len < 0 || len + strIndex > this.mem8.length) throw new Error(\"invalid len  passed to getString: \" + len);\n        } else {\n            len = this.mem8.indexOf(0, strIndex);\n            if (len == -1) throw new Error(\"string is not null terminated\");\n            len = len - strIndex;\n        }\n        let encodeFormat;\n        if (codePage == (0, $lVt1a.codePageUTF8)) encodeFormat = \"utf-8\";\n        else if (codePage == (0, $lVt1a.codePage1252)) encodeFormat = \"windows-1252\";\n        else throw new Error(\"Unsupported codePage: \" + codePage);\n        const td = new TextDecoder(encodeFormat);\n        const u8todecode = new Uint8Array(this.mem8.buffer, strIndex, len);\n        // chrome throws exception when using TextDecoder on SharedArrayBuffer\n        // BUT, instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error, so don't check directly\n        if (this.mem8.buffer instanceof ArrayBuffer) {\n            const sout = td.decode(u8todecode);\n            return sout;\n        } else {\n            const regularArrayBuffer = new ArrayBuffer(len);\n            const regularUint8Array = new Uint8Array(regularArrayBuffer);\n            regularUint8Array.set(u8todecode);\n            const sout = td.decode(regularUint8Array);\n            return sout;\n        }\n    }\n    // get a byte array out of module memory when passed in index to [size, dataptr]\n    getU8Arr(idx) {\n        if (idx < 0 || idx >= this.mem8.length) throw new Error(\"invalid index passed to getU8: \" + idx);\n        const rv = new Uint32Array(this.mem8.slice(idx, idx + 8).buffer);\n        let size = rv[0];\n        let dataptr = rv[1];\n        if (dataptr < 0 || dataptr >= this.mem8.length) throw new Error(\"invalid idx.dataptr passed to getU8\");\n        if (size < 0 || size > this.mem8.length - dataptr) throw new Error(\"invalid idx.size passed to  getU8\");\n        const u8 = this.mem8.slice(dataptr, dataptr + size);\n        return u8;\n    }\n    // get a int32 array out of module memory when passed in index to [size, dataptr]\n    getU32Arr(idx) {\n        if (idx < 0 || idx >= this.mem8.length) throw new Error(\"invalid index passed to getU32: \" + idx);\n        const rv = new Uint32Array(this.mem8.slice(idx, idx + 8).buffer);\n        let size = rv[0];\n        let dataptr = rv[1];\n        if (dataptr < 0 || dataptr >= this.mem8.length) throw new Error(\"invalid idx.dataptr passed to getU32\");\n        if (size < 0 || size > this.mem8.length - dataptr) throw new Error(\"invalid idx.size passed to  getU32\");\n        if (size % 4 != 0) throw new Error(\"idx.size is not an integer number of 32 bit words\");\n        const u32 = new Uint32Array(this.mem8.slice(dataptr, dataptr + size).buffer);\n        return u32;\n    }\n}\nclass $287ed5d7d50ba8d6$export$d835cdc0f59e6ea8 extends $287ed5d7d50ba8d6$export$ad21274072098225 {\n    malloc;\n    free;\n    constructor(memory, free, malloc){\n        super(memory);\n        this.free = free;\n        this.malloc = malloc;\n    }\n    // allocate and copy a string into the webassembly module memory as utf8 (or the specified codePage)\n    putString(sin, codePage = (0, $lVt1a.codePageUTF8)) {\n        const ru8 = this.stringToU8(sin, codePage);\n        const strIndex = this.malloc(ru8.length + 1);\n        this.mem8.set(ru8, strIndex);\n        this.mem8[strIndex + ru8.length] = 0;\n        return strIndex;\n    }\n    // allocate and copy a Uint8Array into Wasm mod memory\n    putU8(u8a) {\n        let dest = this.malloc(u8a.length);\n        this.mem8.set(u8a, dest);\n        return dest;\n    }\n    putArrayBuffer(ab) {\n        const u8 = new Uint8Array(ab);\n        return this.putU8(u8);\n    }\n}\nclass $287ed5d7d50ba8d6$export$f59b88b16ecb0d13 extends $287ed5d7d50ba8d6$export$ad21274072098225 {\n    malloc;\n    free;\n    constructor(memory, mallocImpl, callCImpl){\n        super(memory);\n        this.free = (size)=>{\n            return callCImpl(\"free\", [\n                size\n            ]);\n        };\n        this.malloc = mallocImpl;\n    }\n    // allocate and copy a string into the webassembly module memory as utf8 (or the specified codePage)\n    async putString(sin, codePage = (0, $lVt1a.codePageUTF8)) {\n        const ru8 = this.stringToU8(sin, codePage);\n        const strIndex = await this.malloc(ru8.length + 1);\n        this.mem8.set(ru8, strIndex);\n        this.mem8[strIndex + ru8.length] = 0;\n        return strIndex;\n    }\n    // allocate and copy a Uint8Array into Wasm mod memory\n    async putU8(u8a) {\n        let dest = await this.malloc(u8a.length);\n        this.mem8.set(u8a, dest);\n        return dest;\n    }\n    async putArrayBuffer(ab) {\n        const u8 = new Uint8Array(ab);\n        return this.putU8(u8);\n    }\n}\n\n});\nparcelRegister(\"lVt1a\", function(module, exports) {\n\n$parcel$export(module.exports, \"codePageASCII\", () => $ff656e333be58c07$export$53f1026d7d1c23fb);\n$parcel$export(module.exports, \"codePage1252\", () => $ff656e333be58c07$export$29f202393adbf96);\n$parcel$export(module.exports, \"codePageUTF8\", () => $ff656e333be58c07$export$3d6ef5b62200d8d1);\n$parcel$export(module.exports, \"codePageUTF32\", () => $ff656e333be58c07$export$ddea6250b326d061);\n$parcel$export(module.exports, \"default\", () => $ff656e333be58c07$export$2e2bcd8739ae039);\n$parcel$export(module.exports, \"twrCodePageToUnicodeCodePoint\", () => $ff656e333be58c07$export$c7de3f2686797480);\n$parcel$export(module.exports, \"to1252\", () => $ff656e333be58c07$export$8644084c19ac418e);\n$parcel$export(module.exports, \"toASCII\", () => $ff656e333be58c07$export$69111c4ea6e0c4a0);\n\nvar $9lAov = parcelRequire(\"9lAov\");\nconst $ff656e333be58c07$export$53f1026d7d1c23fb = 0;\nconst $ff656e333be58c07$export$29f202393adbf96 = 1252;\nconst $ff656e333be58c07$export$3d6ef5b62200d8d1 = 65001;\nconst $ff656e333be58c07$export$ddea6250b326d061 = 12000;\nclass $ff656e333be58c07$export$2e2bcd8739ae039 extends (0, $9lAov.twrLibrary) {\n    id;\n    imports = {\n        twrUnicodeCodePointToCodePage: {\n            isCommonCode: true\n        },\n        twrCodePageToUnicodeCodePoint: {\n            isCommonCode: true\n        },\n        twrUserLanguage: {\n            isCommonCode: true\n        },\n        twrTimeTmLocal: {\n            isCommonCode: true\n        },\n        twrUserLconv: {\n            isCommonCode: true\n        },\n        twrRegExpTest1252: {\n            isCommonCode: true\n        },\n        twrToUpper1252: {\n            isCommonCode: true\n        },\n        twrToLower1252: {\n            isCommonCode: true\n        },\n        twrStrcoll: {\n            isCommonCode: true\n        },\n        twrGetDtnames: {\n            isCommonCode: true\n        }\n    };\n    libSourcePath = new URL(\"file:///../lib-js/twrliblocale.js\").pathname;\n    cpTranslate = new $ff656e333be58c07$export$c7de3f2686797480();\n    cpTranslate2 = new $ff656e333be58c07$export$c7de3f2686797480();\n    constructor(){\n        // all library constructors should start with these two lines\n        super();\n        this.id = (0, $9lAov.twrLibraryInstanceRegistry).register(this);\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////\n    twrCodePageToUnicodeCodePoint(callingMod, c, codePage) {\n        return this.cpTranslate2.convert(c, codePage);\n    }\n    twrUnicodeCodePointToCodePage(callingMod, outstr, cp, codePage) {\n        const ru8 = callingMod.wasmMem.stringToU8(String.fromCodePoint(cp), codePage);\n        callingMod.wasmMem.mem8.set(ru8, outstr);\n        return ru8.length;\n    }\n    twrUserLanguage(callingMod) {\n        // navigator.language works in JS main thread and Worker thread\n        return callingMod.wasmMem.putString(navigator.language, $ff656e333be58c07$export$53f1026d7d1c23fb);\n    }\n    // checks if the character c, when converted to a string, is matched by the passed in regexp string \n    // utf-8 version not needed since this function is used for a single byte ('char'), \n    // and non-ascii range utf-8 single byte are not valid\n    twrRegExpTest1252(callingMod, regexpStrIdx, c) {\n        const regexpStr = callingMod.wasmMem.getString(regexpStrIdx);\n        const regexp = new RegExp(regexpStr, \"u\");\n        const cstr = this.cpTranslate.decoder1252.decode(new Uint8Array([\n            c\n        ]));\n        const r = regexp.test(cstr);\n        if (r) return 1;\n        else return 0;\n    }\n    // utf-8 version not needed since this function is used for a single byte ('char'), \n    // and non-ascii range utf-8 single byte are not valid\n    twrToLower1252(callingMod, c) {\n        const cstr = this.cpTranslate.decoder1252.decode(new Uint8Array([\n            c\n        ]));\n        const regexp = new RegExp(\"^\\\\p{Letter}$\", \"u\");\n        if (regexp.test(cstr)) {\n            const r = $ff656e333be58c07$export$8644084c19ac418e(cstr.toLocaleLowerCase());\n            //console.log(\"twrToLower1252Impl: isLetter\", c, cstr, cstr.codePointAt(0), cstr.toLocaleLowerCase(), cstr.toLocaleLowerCase().codePointAt(0), r);\n            return r;\n        } else //console.log(\"twrToLower1252Impl: isNOTLetter\", c, cstr, cstr.codePointAt(0));\n        return c;\n    }\n    //utf-8 version not needed since this function is used for a single byte ('char'), \n    // and non-ascii range utf-8 single byte are not valid\n    twrToUpper1252(callingMod, c) {\n        const cstr = this.cpTranslate.decoder1252.decode(new Uint8Array([\n            c\n        ]));\n        if (cstr.codePointAt(0) == 402) return c; // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is ƒ\n        if (cstr.codePointAt(0) == 181) return c; // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is µ\n        if (cstr.codePointAt(0) == 223) return c; // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is ß'\n        if (cstr == \"\\xb5\") return c; // upper case version doesn't fit in 1252\n        if (cstr == \"\\u0192\") return c; // upper case version doesn't fit in 1252\n        if (cstr == \"\\xdf\") return c; // toLocaleUpperCase() will convert beta to SS\n        const regexp = new RegExp(\"^\\\\p{Letter}$\", \"u\");\n        if (regexp.test(cstr)) return $ff656e333be58c07$export$8644084c19ac418e(cstr.toLocaleUpperCase());\n        else return c;\n    }\n    twrStrcoll(callingMod, lhs, rhs, codePage) {\n        const lhStr = callingMod.wasmMem.getString(lhs, undefined, codePage);\n        const rhStr = callingMod.wasmMem.getString(rhs, undefined, codePage);\n        // c strcmp(): A positive integer if str1 is greater than str2.\n        // 1 if string 1 (lh) comes after string 2 (rh)\n        const collator = new Intl.Collator();\n        const r = collator.compare(lhStr, rhStr);\n        return r;\n    }\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    //struct tm {\n    //\tint\ttm_sec;\t\t/* seconds after the minute [0-60] */\n    //\tint\ttm_min;\t\t/* minutes after the hour [0-59] */\n    //\tint\ttm_hour;\t\t/* hours since midnight [0-23] */\n    //\tint\ttm_mday;\t\t/* day of the month [1-31] */\n    //\tint\ttm_mon;\t\t/* months since January [0-11] */\n    //\tint\ttm_year;\t\t/* years since 1900 */\n    //\tint\ttm_wday;\t\t/* days since Sunday [0-6] */\n    //\tint\ttm_yday;\t\t/* days since January 1 [0-365] */\n    //\tint\ttm_isdst;\t/* Daylight Saving Time flag */\n    //\tlong\ttm_gmtoff;\t/* offset from UTC in seconds */\n    //\tchar\t*tm_zone;\t/* timezone abbreviation */\n    //};\n    // fill in struct tm\n    // epcohSecs as 32bit int will overflow January 19, 2038. \n    twrTimeTmLocal(callingMod, tmIdx, epochSecs) {\n        const d = new Date(epochSecs * 1000);\n        callingMod.wasmMem.setLong(tmIdx, d.getSeconds());\n        callingMod.wasmMem.setLong(tmIdx + 4, d.getMinutes());\n        callingMod.wasmMem.setLong(tmIdx + 8, d.getHours());\n        callingMod.wasmMem.setLong(tmIdx + 12, d.getDate());\n        callingMod.wasmMem.setLong(tmIdx + 16, d.getMonth());\n        callingMod.wasmMem.setLong(tmIdx + 20, d.getFullYear() - 1900);\n        callingMod.wasmMem.setLong(tmIdx + 24, d.getDay());\n        callingMod.wasmMem.setLong(tmIdx + 28, this.getDayOfYear(d));\n        callingMod.wasmMem.setLong(tmIdx + 32, this.isDst());\n        callingMod.wasmMem.setLong(tmIdx + 36, -d.getTimezoneOffset() * 60);\n        callingMod.wasmMem.setLong(tmIdx + 40, callingMod.wasmMem.putString(this.getTZ(d), $ff656e333be58c07$export$53f1026d7d1c23fb));\n    }\n    getDayOfYear(date) {\n        const start = new Date(date.getFullYear(), 0, 1);\n        const diff = date.getTime() - start.getTime(); // Difference in milliseconds\n        const oneDay = 86400000; // Number of milliseconds in one day\n        const day = Math.floor(diff / oneDay);\n        return day;\n    }\n    isDst() {\n        const timeString = new Date().toLocaleTimeString(\"en-US\", {\n            timeZoneName: \"long\"\n        });\n        if (timeString.includes(\"Daylight\")) return 1;\n        else return 0;\n    }\n    getTZ(date) {\n        const timeZone = date.toLocaleTimeString(\"en-US\", {\n            timeZoneName: \"short\"\n        }).split(\" \").pop();\n        return timeZone ? timeZone : \"UTC\";\n    }\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    setAndPutString(mem, idx, sin, codePage) {\n        const stridx = mem.putString(sin, codePage);\n        mem.setLong(idx, stridx);\n    }\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    //struct lconv {\n    //\tchar\t*decimal_point;   \t\t0\n    //\tchar\t*thousands_sep;\t\t\t4\n    //\tchar\t*grouping;\t\t\t\t\t8\n    //\tchar\t*int_curr_symbol;\t\t\t12\n    //\tchar\t*currency_symbol;\t\t\t16\n    //\tchar\t*mon_decimal_point;\t\t20\n    //\tchar\t*mon_thousands_sep;\t\t24\n    //\tchar\t*mon_grouping;\t\t\t\t28\n    //\tchar\t*positive_sign;\t\t\t32\n    //\tchar\t*negative_sign;\t\t\t36\n    //\tchar\tint_frac_digits;\t\t\t40\n    //\tchar\tfrac_digits;\t\t\t\t44\n    //\tchar\tp_cs_precedes;\t\t\t\t48\n    //\tchar\tp_sep_by_space;\t\t\t52\n    //\tchar\tn_cs_precedes;\t\t\t\t56\n    //\tchar\tn_sep_by_space;\t\t\t60\n    //\tchar\tp_sign_posn;\t\t\t\t64\n    //\tchar\tn_sign_posn;\t\t\t\t68\n    //};\n    twrUserLconv(callingMod, lconvIdx, codePage) {\n        const locDec = this.getLocaleDecimalPoint();\n        const locSep = this.getLocaleThousandsSeparator();\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 0, locDec, codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 4, locSep, codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 20, locDec, codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 24, locSep, codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 24, locSep, codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 24, locSep, codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 32, \"+\", codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 36, \"-\", codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 12, this.getLocalCurrencySymbol(), codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 16, this.getLocalCurrencySymbol(), codePage);\n    }\n    getLocaleDecimalPoint() {\n        const formatter = new Intl.NumberFormat();\n        //console.log(\"dec resolvedOptions\", formatter.resolvedOptions());\n        // Format a test number to find out the decimal point.\n        const formattedNumber = formatter.format(1.1);\n        //console.log(\"dec formattedNumber\", formattedNumber);\n        // Find the character between the numeric parts.\n        const decimalPoint = formattedNumber.replace(/[0-9]/g, \"\").charAt(0);\n        return decimalPoint;\n    }\n    getLocaleThousandsSeparator() {\n        const formatter = new Intl.NumberFormat(undefined, {\n            minimumFractionDigits: 0 // Ensure no decimal part interferes\n        });\n        // Format a test number to include a thousands separator.\n        const formattedNumber = formatter.format(1000);\n        //console.log(\"sep formattedNumber\", formattedNumber);\n        // Extract the thousands separator by removing numeric characters and possible decimal points.\n        // This may need adjustment depending on whether other characters are present.\n        let thousandsSeparator = formattedNumber.replace(/[0-9]/g, \"\").charAt(0); // Assumes separator is the first character.\n        //console.log(\"sep code\",  thousandsSeparator.codePointAt(0));\n        return thousandsSeparator;\n    }\n    // this doesn't work, localeCurrency is not correct\n    getLocaleCurrencyDecimalPoint() {\n        // Create an initial NumberFormat object to detect the locale's currency\n        const tempFormatter = new Intl.NumberFormat(undefined, {\n            style: \"currency\",\n            currency: \"USD\"\n        });\n        const localeCurrency = tempFormatter.resolvedOptions().currency;\n        const formatter = new Intl.NumberFormat(undefined, {\n            style: \"currency\",\n            currency: localeCurrency\n        });\n        // Format a test number to find out the decimal point.\n        const formattedNumber = formatter.format(1.1);\n        // Find the character between the numeric parts.\n        // char(0) is the currency symbol\n        const decimalPoint = formattedNumber.replace(/[0-9]/g, \"\").charAt(1);\n        return decimalPoint;\n    }\n    getLocalCurrencySymbol() {\n        switch(navigator.language){\n            case \"en-US\":\n            case \"en-CA\":\n            case \"fr-CA\":\n            case \"en-AU\":\n            case \"es-MX\":\n            case \"es-AR\":\n            case \"es-CL\":\n            case \"es-CO\":\n            case \"es-EC\":\n            case \"en-GY\":\n            case \"nl-SR\":\n            case \"es-UY\":\n            case \"en-BZ\":\n            case \"es-SV\":\n            case \"es-PA\":\n                return \"$\";\n            case \"es-BO\":\n            case \"es-VE\":\n                return \"Bs.\";\n            case \"es-PY\":\n                return \"\\u20B2\";\n            case \"es-PE\":\n                return \"S/\";\n            case \"es-CR\":\n                return \"\\u20A1\";\n            case \"es-GT\":\n                return \"Q\";\n            case \"es-HN\":\n                return \"L\";\n            case \"es-NI\":\n                return \"C$\";\n            case \"en-GB\":\n                return \"\\xa3\";\n            case \"en-IE\":\n            case \"de-DE\":\n            case \"fr-FR\":\n            case \"de-AT\":\n            case \"nl-BE\":\n            case \"fr-BE\":\n            case \"el-CY\":\n            case \"et-EE\":\n            case \"fi-FI\":\n            case \"sv-FI\":\n            case \"el-GR\":\n            case \"it-IT\":\n            case \"lv-LV\":\n            case \"lt-LT\":\n            case \"fr-LU\":\n            case \"de-LU\":\n            case \"lb-LU\":\n            case \"mt-MT\":\n            case \"nl-NL\":\n            case \"pt-PT\":\n            case \"sk-SK\":\n            case \"sl-SI\":\n            case \"es-ES\":\n                return \"\\u20AC\";\n            case \"ja-JP\":\n                return \"\\xa5\";\n            case \"zh-CN\":\n                return \"\\xa5\";\n            case \"de-CH\":\n            case \"fr-CH\":\n            case \"it-CH\":\n                return \"CHF\";\n            case \"sv-SE\":\n            case \"da-DK\":\n            case \"nb-NO\":\n                return \"kr\";\n            case \"ru-RU\":\n                return \"\\u20BD\";\n            case \"ko-KR\":\n                return \"\\u20A9\";\n            case \"en-IN\":\n                return \"\\u20B9\";\n            case \"pt-BR\":\n                return \"R$\";\n            case \"he-IL\":\n                return \"\\u20AA\";\n            case \"tr-TR\":\n                return \"\\u20BA\";\n            default:\n                return \"\";\n        }\n    }\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /*\n    struct locale_dtnames {\n       const char* day[7];\n       const char* abday[7];\n       const char* month[12];\n       const char* abmonth[12];\n       const char* ampm[2];\n    };\n    */ twrGetDtnames(callingMod, codePage) {\n        const malloc = callingMod.wasmMem.malloc;\n        const dtnamesStructIdx = malloc(160);\n        for(let i = 0; i < 7; i++)this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx + i * 4, this.getLocalizedDayName(i, \"long\"), codePage);\n        for(let i = 0; i < 7; i++)this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx + (i + 7) * 4, this.getLocalizedDayName(i, \"short\"), codePage);\n        for(let i = 0; i < 12; i++)this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx + (i + 14) * 4, this.getLocalizedMonthNames(i, \"long\"), codePage);\n        for(let i = 0; i < 12; i++)this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx + (i + 14 + 12) * 4, this.getLocalizedMonthNames(i, \"short\"), codePage);\n        this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx + 152, this.getLocalizedAM(), codePage);\n        this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx + 156, this.getLocalizedPM(), codePage);\n        return dtnamesStructIdx;\n    }\n    getLocalizedDayName(n, weekdayType) {\n        // Create a Date object for the desired day of the week\n        const date = new Date();\n        date.setDate(date.getDate() - date.getDay() + n);\n        // Create an Intl.DateTimeFormat object with the desired locale and options\n        const formatter = new Intl.DateTimeFormat(undefined, {\n            weekday: weekdayType\n        });\n        // Format the date to get the full day name\n        return formatter.format(date);\n    }\n    getLocalizedMonthNames(n, monthType) {\n        const formatter = new Intl.DateTimeFormat(undefined, {\n            month: monthType\n        });\n        const date = new Date(2000, n, 1);\n        return formatter.format(date);\n    }\n    getLocalizedAM() {\n        // Create a Date object for a time in the morning\n        const morningDate = new Date(2000, 0, 1, 9, 0, 0);\n        // Create an Intl.DateTimeFormat object with the desired locale and options\n        const formatter = new Intl.DateTimeFormat(undefined, {\n            hour: \"numeric\",\n            hour12: true\n        });\n        // Format the date and get the parts\n        const formattedParts = formatter.formatToParts(morningDate);\n        // Find the part of the formatted string that corresponds to the day period (AM/PM)\n        const dayPeriodPart = formattedParts.find((part)=>part.type === \"dayPeriod\");\n        return dayPeriodPart ? dayPeriodPart.value : \"\";\n    }\n    getLocalizedPM() {\n        // Create a Date object for a time in the afternoon\n        const afternoonDate = new Date(2000, 0, 1, 15, 0, 0);\n        // Create an Intl.DateTimeFormat object with the desired locale and options\n        const formatter = new Intl.DateTimeFormat(undefined, {\n            hour: \"numeric\",\n            hour12: true\n        });\n        // Format the date and get the parts\n        const formattedParts = formatter.formatToParts(afternoonDate);\n        // Find the part of the formatted string that corresponds to the day period (AM/PM)\n        const dayPeriodPart = formattedParts.find((part)=>part.type === \"dayPeriod\");\n        return dayPeriodPart ? dayPeriodPart.value : \"\";\n    }\n}\nfunction $ff656e333be58c07$export$8644084c19ac418e(instr) {\n    if (instr.codePointAt(0) == 8239) return 32; // turn narrow-no-break-space into space\n    // this first switch statment fixes what appears to be a bug in safari 15.6.1 (17613.3.9.1.16) (comparisons to the character string fail)\n    let cp = instr.codePointAt(0) || 0;\n    switch(cp){\n        case 338:\n            return 0x8C;\n        case 339:\n            return 0x9C;\n        case 352:\n            return 0x8A;\n        case 353:\n            return 0x9A;\n        case 376:\n            return 0x9F;\n        case 381:\n            return 0x8E;\n        case 382:\n            return 0x9E;\n        case 402:\n            return 0x83;\n        case 710:\n            return 0x88;\n    }\n    switch(instr.normalize()){\n        case \"\\u20AC\":\n            return 0x80;\n        case \"\\u201A\":\n            return 0x82;\n        case \"\\u0192\":\n            return 0x83;\n        case \"\\u201E\":\n            return 0x84;\n        case \"\\u2026\":\n            return 0x85;\n        case \"\\u2020\":\n            return 0x86;\n        case \"\\u2021\":\n            return 0x87;\n        case \"\\u02C6\":\n            return 0x88;\n        case \"\\u2030\":\n            return 0x89;\n        case \"\\u0160\":\n            return 0x8A;\n        case \"\\u2039\":\n            return 0x8B;\n        case \"\\u0152\":\n            return 0x8C;\n        case \"\\u017D\":\n            return 0x8E;\n        case \"\\u2018\":\n            return 0x91;\n        case \"\\u2019\":\n            return 0x92;\n        case \"\\u201C\":\n            return 0x93;\n        case \"\\u201D\":\n            return 0x94;\n        case \"\\u2022\":\n            return 0x95;\n        case \"\\u2013\":\n            return 0x96;\n        case \"\\u2014\":\n            return 0x97;\n        case \"\\u02DC\":\n            return 0x98;\n        case \"\\u2122\":\n            return 0x99;\n        case \"\\u0161\":\n            return 0x9A;\n        case \"\\u203A\":\n            return 0x9B;\n        case \"\\u0153\":\n            return 0x9C;\n        case \"\\u017E\":\n            return 0x9E;\n        case \"\\u0178\":\n            return 0x9F;\n    }\n    if (cp > 255) {\n        console.log(\"twr-wasm.to1252(): unable to convert: \", instr, cp);\n        cp = 0;\n    }\n    return cp;\n}\nfunction $ff656e333be58c07$export$69111c4ea6e0c4a0(instr) {\n    if (instr == \"\\u0192\") return 102; // lowercase 'f'\n    if (instr.codePointAt(0) == 8239) return 32; // turn narrow-no-break-space into space\n    let cp = instr.codePointAt(0) || 0;\n    if (cp > 127) return 63; // ASCII for \"?\"\n    return cp;\n}\nclass $ff656e333be58c07$export$c7de3f2686797480 {\n    decoderUTF8 = new TextDecoder(\"utf-8\");\n    decoder1252 = new TextDecoder(\"windows-1252\");\n    convert(c, codePage) {\n        let outstr;\n        if (codePage == $ff656e333be58c07$export$3d6ef5b62200d8d1) outstr = this.decoderUTF8.decode(new Uint8Array([\n            c\n        ]), {\n            stream: true\n        });\n        else if (codePage == $ff656e333be58c07$export$29f202393adbf96) outstr = this.decoder1252.decode(new Uint8Array([\n            c\n        ]));\n        else if (codePage == $ff656e333be58c07$export$53f1026d7d1c23fb) {\n            if (c > 127) outstr = \"\";\n            else outstr = String.fromCharCode(c);\n        } else if (codePage == $ff656e333be58c07$export$ddea6250b326d061) outstr = String.fromCodePoint(c);\n        else throw new Error(\"unsupported CodePage: \" + codePage);\n        return outstr.codePointAt(0) || 0;\n    }\n}\n\n});\nparcelRegister(\"9lAov\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrLibrary\", () => $6ce24e5be95ebe48$export$e0c9f0d281d749b5);\n$parcel$export(module.exports, \"twrLibraryInstanceRegistry\", () => $6ce24e5be95ebe48$export$67aa3c579b4a4587);\n$parcel$export(module.exports, \"twrLibraryProxy\", () => $6ce24e5be95ebe48$export$5ab2b60d8abc5018);\n$parcel$export(module.exports, \"twrLibraryInstanceProxyRegistry\", () => $6ce24e5be95ebe48$export$fdde87911cbb71ae);\n\nvar $6QEzV = parcelRequire(\"6QEzV\");\nclass $6ce24e5be95ebe48$export$e0c9f0d281d749b5 {\n    // set to unique name if multiple instances allowed (must all expose the same interface) (e.g. consoles).  \n    // When true, APIs will expect first arg to be library ID.\n    interfaceName;\n    constructor(){}\n    // the actual twrLibrary is created outside of a specific wasm module, so isn't paired to a specific module\n    // however, each call to getImports is paired to a specific wasm module\n    // getImports returns Wasm Module imports that will be added to this wasm module's WebAssembly.ModuleImports\n    // getImports expects that the derived class has created a \"this.import\" with a list of function names (as strings)\n    // getImports is called by twrWasmModule\n    getImports(callingMod) {\n        if (callingMod.isTwrWasmModuleAsync) throw new Error(\"unsupported module type (expecting twrWasmModule\");\n        let wasmImports = {};\n        const derivedInstanceThis = this;\n        if (this.imports === undefined) throw new Error(\"twrLibrary derived class is missing imports.\");\n        if (this.libSourcePath === undefined) throw new Error(\"twrLibrary derived class is missing libSourcePath.\");\n        for(let funcName in this.imports)if (this.imports[funcName].isModuleAsyncOnly) {\n            const nullFun = ()=>{\n                throw new Error(\"Invalid call to unimplemented twrLibrary 'import' function (isModuleAsyncOnly was used): \" + funcName);\n            };\n            wasmImports[funcName] = nullFun;\n        } else {\n            if (!derivedInstanceThis[funcName]) throw new Error(\"twrLibrary 'import' function is missing: \" + funcName);\n            if (this.interfaceName) {\n                // in this case, this particular instance represents the class\n                // but the actual instance needs to be retrieved at runtime using the libID & registry\n                // since only once set of WasmImports is created for each class\n                const libFunc = (funcName, mod, libID, ...params)=>{\n                    const lib = $6ce24e5be95ebe48$export$67aa3c579b4a4587.getLibraryInstance(libID);\n                    const derivedLib = lib;\n                    const f = derivedLib[funcName];\n                    if (!f) throw new Error(`Library function not found. id=${libID}, funcName=${funcName}`);\n                    return f.call(derivedLib, mod, ...params);\n                };\n                wasmImports[funcName] = libFunc.bind(null, funcName, callingMod); // rest of function args are also passed to libFunc when using bind\n            } else wasmImports[funcName] = derivedInstanceThis[funcName].bind(this, callingMod);\n        }\n        return wasmImports;\n    }\n    // this function is called by twrWasmModuleAsync, and sent to the corresponding twrWasmModuleAsyncProxy\n    getProxyParams() {\n        return [\n            \"twrLibraryProxy\",\n            this.id,\n            this.imports,\n            this.libSourcePath,\n            this.interfaceName\n        ];\n    }\n    // called by twrWasmModuleAsync\n    async processMessageFromProxy(msg, mod) {\n        const [msgClass, libID, funcName, doAwait, returnValueEventID, ...params] = msg;\n        if (this.interfaceName && $6ce24e5be95ebe48$export$67aa3c579b4a4587.getLibraryInstance(libID).libSourcePath != this.libSourcePath) throw new Error(\"internal error\"); // should never happen\n        else if (libID != this.id) throw new Error(\"internal error\"); // should never happen\n        if (!mod.isTwrWasmModuleAsync) throw new Error(\"internal error\");\n        const libThis = $6ce24e5be95ebe48$export$67aa3c579b4a4587.getLibraryInstance(libID);\n        const derivedInstance = libThis;\n        if (!derivedInstance[funcName]) throw new Error(\"twrLibrary derived class missing 'import' function: \" + funcName);\n        let retVal;\n        if (doAwait) retVal = await derivedInstance[funcName](mod, ...params);\n        else retVal = derivedInstance[funcName](mod, ...params);\n        if (returnValueEventID > -1) mod.eventQueueSend.postEvent(returnValueEventID, retVal);\n    }\n}\nclass $6ce24e5be95ebe48$export$5ab2b60d8abc5018 {\n    id;\n    imports;\n    libSourcePath;\n    interfaceName;\n    called = false;\n    //every module instance has its own twrLibraryProxy\n    constructor(params){\n        const [className, id, imports, libSourcePath, interfaceName] = params;\n        this.id = id;\n        this.imports = imports;\n        this.libSourcePath = libSourcePath;\n        this.interfaceName = interfaceName;\n    }\n    remoteProcedureCall(ownerMod, funcName, isAsyncFunction, returnValueEventID, interfaceName, ...args) {\n        let msg;\n        if (interfaceName) msg = [\n            \"twrLibrary\",\n            args[0],\n            funcName,\n            isAsyncFunction,\n            returnValueEventID,\n            ...args.slice(1)\n        ];\n        else msg = [\n            \"twrLibrary\",\n            this.id,\n            funcName,\n            isAsyncFunction,\n            returnValueEventID,\n            ...args\n        ];\n        // postMessage sends message to the JS Main thread that created the twrModAsyncProxy thread\n        // the message processing code discriminates the destination instance by:  \"twrLibrary\", this.id,\n        postMessage(msg);\n        //TODO!! a void return type isn't particularly supported -- it will presumably returned undefined from the JS function, \n        //which will put a zero into the Int32Array used for returnValue\n        if (returnValueEventID == -1) return 0;\n        const [id, retVals] = ownerMod.eventQueueReceive.waitEvent(returnValueEventID);\n        if (id != returnValueEventID) throw new Error(\"internal error\");\n        if (retVals.length != 1) throw new Error(\"internal error\");\n        return retVals[0];\n    }\n    // getProxyImports is called by twrWasmModuleAsyncProxy\n    // it provides the functions that the twrWasmModuleAsync's C code will call\n    // these will RPC to the JS main thread (unless isCommonCode set) and then wait for a return value (unless noBlock) \n    async getProxyImports(ownerMod) {\n        if (this.called === true) throw new Error(\"getProxyImports should only be called once per twrLibraryProxy instance\");\n        this.called = true;\n        let wasmImports = {};\n        let libClass;\n        // now for each twrLibrary import, create the functions that will be added to wasm module imports\n        for(let funcName in this.imports){\n            if (this.imports[funcName].isCommonCode) {\n                if (this.imports[funcName].isAsyncFunction) throw new Error(\"isAsyncFunction can not be used with isCommonCode\");\n                if (libClass === undefined) {\n                    if (this.libSourcePath === undefined) throw new Error(\"undefined libSourcePath\");\n                    const libMod = await import(this.libSourcePath);\n                    libClass = new libMod.default;\n                }\n                wasmImports[funcName] = libClass[funcName].bind(libClass, ownerMod);\n            } else if (this.imports[funcName].isAsyncFunction) wasmImports[funcName] = this.remoteProcedureCall.bind(this, ownerMod, funcName + \"_async\", this.imports[funcName].isAsyncFunction ? true : false, this.imports[funcName].noBlock ? -1 : (0, $6QEzV.twrEventQueueReceive).registerEvent(), this.interfaceName);\n            else wasmImports[funcName] = this.remoteProcedureCall.bind(this, ownerMod, funcName, this.imports[funcName].isAsyncFunction ? true : false, this.imports[funcName].noBlock ? -1 : (0, $6QEzV.twrEventQueueReceive).registerEvent(), this.interfaceName);\n        }\n        return wasmImports;\n    }\n}\nclass $6ce24e5be95ebe48$export$67aa3c579b4a4587 {\n    // every twrLibrary instance goes here\n    static libInstances = [];\n    // Each unique interface has one representative and arbitrary instance in libInterfaceInstances.\n    // A unique interfaceName represents a unique interface.  Multiple classes may have the same interfaceName.\n    // (A class is identified by libSourcePath)\n    // An undefined interfaceName (anonymous interface) means that only one instance of that class is allowed\n    // and also means that the class has a unique anonymous interface.\n    static libInterfaceInstances = [];\n    // create a pairing between an instance of type ILibraryBase and an integer ID\n    static register(libInstance) {\n        if (libInstance.imports === undefined) throw new Error(\"twrLibrary derived class is missing imports.\");\n        if (libInstance.libSourcePath === undefined) throw new Error(\"twrLibrary derived class is missing libSourcePath.\");\n        // register the new instance\n        $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInstances.push(libInstance);\n        const id = $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInstances.length - 1;\n        // if this has a named interface, add it to the interface list, but only add it once.\n        if (libInstance.interfaceName) {\n            const interfaceID = this.getLibraryInstanceByInterfaceName(libInstance.interfaceName);\n            if (interfaceID === undefined) $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInterfaceInstances.push(libInstance);\n            else {\n                // verify the interface are compatible.  If they don't its a coding error\n                const alreadyRegisteredLibInstance = $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInterfaceInstances[interfaceID];\n                for(let i = 0; i < $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInterfaceInstances.length; i++)if ($6ce24e5be95ebe48$export$67aa3c579b4a4587.libInterfaceInstances[i].interfaceName === libInstance.interfaceName) {\n                    if (!$6ce24e5be95ebe48$var$CompareImports($6ce24e5be95ebe48$export$67aa3c579b4a4587.libInterfaceInstances[i].imports, libInstance.imports)) throw new Error(`interface definitions (imports) ${libInstance.interfaceName} are not compatible between class ${libInstance.libSourcePath} and ${alreadyRegisteredLibInstance.libSourcePath}`);\n                }\n                // TODO!!  This is here to make twrcondummy.ts work correctly (a console without a complete interface might be loaded before twrcondummy.ts)\n                if (Object.keys(libInstance.imports).length > Object.keys(alreadyRegisteredLibInstance.imports).length) $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInterfaceInstances[interfaceID] = libInstance;\n            }\n        } else {\n            // then check for the error where a Class is registered more than once\n            if (this.getLibraryInstanceByClass(libInstance.libSourcePath)) throw new Error(\"A second twrLibrary instance was registered but interfaceName===undefined\");\n            // if no error, than add anonymous interface to the list\n            $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInterfaceInstances.push(libInstance);\n        }\n        return id;\n    }\n    static getLibraryInstance(id) {\n        if (id < 0 || id >= $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInstances.length) throw new Error(\"Invalid console ID: \" + id);\n        return $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInstances[id];\n    }\n    static getLibraryInstanceByInterfaceName(name) {\n        for(let i = 0; i < $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInterfaceInstances.length; i++)if ($6ce24e5be95ebe48$export$67aa3c579b4a4587.libInterfaceInstances[i].interfaceName === name) return i;\n        return undefined;\n    }\n    static getLibraryInstanceByClass(path) {\n        for(let i = 0; i < $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInterfaceInstances.length; i++)if ($6ce24e5be95ebe48$export$67aa3c579b4a4587.libInstances[i].libSourcePath === path) return $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInstances;\n        return undefined;\n    }\n    static getLibraryInstanceID(libInstance) {\n        for(let i = 0; i < $6ce24e5be95ebe48$export$67aa3c579b4a4587.libInstances.length; i++)if ($6ce24e5be95ebe48$export$67aa3c579b4a4587.libInstances[i] == libInstance) return i;\n        throw new Error(\"libInstance not in registry\");\n    }\n}\nclass $6ce24e5be95ebe48$export$fdde87911cbb71ae {\n    static libProxyInstances = [];\n    // create a pairing between an instance of type IConsole and an integer ID\n    static registerProxy(libProxyInstance) {\n        $6ce24e5be95ebe48$export$fdde87911cbb71ae.libProxyInstances[libProxyInstance.id] = libProxyInstance;\n        return libProxyInstance.id;\n    }\n    static getLibraryInstanceProxy(id) {\n        if (id < 0 || id >= $6ce24e5be95ebe48$export$fdde87911cbb71ae.libProxyInstances.length) throw new Error(\"Invalid console ID: \" + id);\n        return $6ce24e5be95ebe48$export$fdde87911cbb71ae.libProxyInstances[id];\n    }\n    static getLibraryInstanceID(libProxyInstance) {\n        for(let i = 0; i < $6ce24e5be95ebe48$export$fdde87911cbb71ae.libProxyInstances.length; i++)if ($6ce24e5be95ebe48$export$fdde87911cbb71ae.libProxyInstances[i] == libProxyInstance) return i;\n        throw new Error(\"libProxyInstance not in registry\");\n    }\n}\nfunction $6ce24e5be95ebe48$var$shallowEqual(obj1, obj2) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    // If the objects have different numbers of keys, they aren't equal\n    if (keys1.length !== keys2.length) return false;\n    // Check if all keys and their values are equal\n    return keys1.every((key)=>obj1[key] === obj2[key]);\n}\nfunction $6ce24e5be95ebe48$var$CompareImports(obj1, obj2) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    // they don't have to have the same number of imports, but every import that exists in both needs to match\n    for(let i = 0; i < keys1.length; i++){\n        const k = keys1[i];\n        if (obj2[k] && !$6ce24e5be95ebe48$var$shallowEqual(obj1[k], obj2[k])) return false;\n    }\n    for(let i = 0; i < keys2.length; i++){\n        const k = keys2[i];\n        if (obj1[k] && !$6ce24e5be95ebe48$var$shallowEqual(obj1[k], obj2[k])) return false;\n    }\n    return true;\n}\n\n});\nparcelRegister(\"6QEzV\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrEventQueueSend\", () => $4fc713716bd016cb$export$a2b31bb9f5a7d633);\n$parcel$export(module.exports, \"twrEventQueueReceive\", () => $4fc713716bd016cb$export$c59837088adec3b3);\n\nvar $dRr3I = parcelRequire(\"dRr3I\");\nconst $4fc713716bd016cb$var$eventMarker = 0x684610d6; // random positive 32 bit value\nconst $4fc713716bd016cb$var$mallocMarker = 0x51949385; // random positive 32 bit value\nclass $4fc713716bd016cb$export$a2b31bb9f5a7d633 {\n    circBuffer = new (0, $dRr3I.twrSharedCircularBuffer)();\n    //TOOD!! unify / rename TOnEventCallback = (eventID:number, ...args:number[])=>void;\n    postEvent(eventID, ...params) {\n        this.circBuffer.writeArray([\n            $4fc713716bd016cb$var$eventMarker,\n            eventID,\n            params.length,\n            ...params\n        ]);\n    }\n    postMalloc(mallocID, size) {\n        this.circBuffer.writeArray([\n            $4fc713716bd016cb$var$mallocMarker,\n            mallocID,\n            size\n        ]);\n    }\n}\nclass $4fc713716bd016cb$export$c59837088adec3b3 {\n    circBuffer;\n    pendingEventIDs;\n    pendingEventArgs;\n    ownerMod;\n    static unqiueInt = 1;\n    static onEventCallbacks = [];\n    constructor(ownerMod, eventQueueBuffer){\n        this.circBuffer = new (0, $dRr3I.twrSharedCircularBuffer)(eventQueueBuffer);\n        this.pendingEventIDs = [];\n        this.pendingEventArgs = [];\n        this.ownerMod = ownerMod;\n    }\n    readEventRemainder() {\n        const eventID = this.circBuffer.read();\n        if (eventID === undefined) throw new Error(\"internal error\");\n        const argLen = this.circBuffer.read();\n        if (argLen === undefined) throw new Error(\"internal error\");\n        const args = [];\n        for(let i = 0; i < argLen; i++){\n            const arg = this.circBuffer.read();\n            if (arg === undefined) throw new Error(\"internal error\");\n            args.push(arg);\n        }\n        if (!(eventID in $4fc713716bd016cb$export$c59837088adec3b3.onEventCallbacks)) throw new Error(\"internal error\");\n        this.pendingEventIDs.push(eventID);\n        this.pendingEventArgs.push(args);\n    }\n    readMallocRemainder() {\n        const mallocID = this.circBuffer.read();\n        if (mallocID === undefined) throw new Error(\"internal error\");\n        const size = this.circBuffer.read();\n        if (size === undefined) throw new Error(\"internal error\");\n        const ptr = this.ownerMod.wasmMem.malloc(size);\n        postMessage([\n            \"twrWasmModule\",\n            mallocID,\n            \"callCOkay\",\n            ptr\n        ]); // we are in the twrWasmModuleAsyncProxy main thread\n    }\n    readCommandRemainder(firstValue) {\n        if (firstValue === $4fc713716bd016cb$var$eventMarker) this.readEventRemainder();\n        else if (firstValue === $4fc713716bd016cb$var$mallocMarker) this.readMallocRemainder();\n        else throw new Error(\"internal error -- eventMarker or mallocMarker expected but not found\");\n    }\n    // called only if circBuffer not empty\n    readCommand() {\n        const firstValue = this.circBuffer.read();\n        this.readCommandRemainder(firstValue);\n    }\n    readWaitCommand() {\n        const firstValue = this.circBuffer.readWait();\n        this.readCommandRemainder(firstValue);\n    }\n    findEvent(filterEvent) {\n        if (filterEvent === undefined) return [\n            this.pendingEventIDs.shift(),\n            this.pendingEventArgs.shift(),\n            0\n        ];\n        const index = this.pendingEventIDs.indexOf(filterEvent);\n        if (index != -1) return [\n            this.pendingEventIDs.splice(index, 1)[0],\n            this.pendingEventArgs.splice(index, 1)[0],\n            index\n        ];\n        return [\n            undefined,\n            undefined,\n            undefined\n        ];\n    }\n    waitEvent(filterEvent) {\n        while(true){\n            // empty the queue\n            while(!this.circBuffer.isEmpty())this.readCommand();\n            // is our event in the queue?\n            const [eventID, args, index] = this.findEvent(filterEvent);\n            // execute callbacks up to this filterEvent (so as to call them in order)\n            // if filterEvent not found, index is undefined, which causes doCallbacks to execute all pendingEventIDs\n            // this call commented out so that the C events act like JavaScript events/callbacks (only called when main function finishes)\n            // to consider: allow callbacks in sync blocking functions like sleep (that use await in their implementations)\n            //this.doCallbacks(index); \n            if (eventID && args) return [\n                eventID,\n                args\n            ];\n            // wait for a new event\n            this.readWaitCommand();\n        }\n    }\n    doCallbacks(upToIndex) {\n        const end = upToIndex ? upToIndex : this.pendingEventIDs.length;\n        console.log(\"end\", end, upToIndex, this.pendingEventIDs.length);\n        for(let i = 0; i < end; i++){\n            const eventID = this.pendingEventIDs[i];\n            const args = this.pendingEventArgs[i];\n            const onEventCallback = $4fc713716bd016cb$export$c59837088adec3b3.onEventCallbacks[eventID];\n            if (onEventCallback) {\n                onEventCallback(eventID, ...args);\n                this.pendingEventIDs.splice(i, 1);\n                this.pendingEventArgs.splice(i, 1);\n            }\n        }\n    }\n    processIncomingCommands() {\n        while(!this.circBuffer.isEmpty())this.readCommand();\n        this.doCallbacks();\n    }\n    //see twrWasmModule.constructor - imports - twr_register_callback:this.registerCallback.bind(this), \n    //TODO!! This static method works for twrWasmModuleAsync, but when/if I implement message loop for twrWasmModule, this may need to change?\n    static registerCallback(funcName, onEventCallback) {\n        if (!onEventCallback) throw new Error(\"registerCallback called with a function name that is not exported from the module\");\n        this.onEventCallbacks[++this.unqiueInt] = onEventCallback;\n        return this.unqiueInt;\n    }\n    static registerEvent() {\n        this.onEventCallbacks[++this.unqiueInt] = undefined;\n        return this.unqiueInt;\n    }\n}\n\n});\nparcelRegister(\"dRr3I\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrSharedCircularBuffer\", () => $a17536f066adc156$export$a01cca24f011573a);\n//\n// This class implements a circular buffer that the main javascript thread can write to, \n// and a blocking WebWorker thread can read from.  This allows keyboard characters to be transferred from the main JS thread to a WebWorker thread.\n// The WebWorker can use the readWait() function to sleep, w/o participating in the normal \n// async callback dispatch method.  This allows a C program that is a single blocking loop to receive input from the primary javascript thread.\n// readWait() is used used when io_getc32() or io_mbgetstr() is called from a C function.\n//\nconst $a17536f066adc156$var$RDIDX = 0;\nconst $a17536f066adc156$var$WRIDX = 1;\nconst $a17536f066adc156$var$LEN = 256;\nclass $a17536f066adc156$export$a01cca24f011573a {\n    saBuffer;\n    f64Array;\n    i32Array;\n    constructor(sa){\n        if (typeof window !== \"undefined\") {\n            if (!crossOriginIsolated && !(window.location.protocol === \"file:\")) throw new Error(\"twrSharedCircularBuffer constructor, crossOriginIsolated=\" + crossOriginIsolated + \". See SharedArrayBuffer docs.\");\n        }\n        if (sa) this.saBuffer = sa;\n        else this.saBuffer = new SharedArrayBuffer($a17536f066adc156$var$LEN * 8 + 4 + 4); // LEN Float64's + RDIDX and WRIDX (both Int32)\n        this.f64Array = new Float64Array(this.saBuffer, 8);\n        this.i32Array = new Int32Array(this.saBuffer, 0, 2);\n        this.i32Array[$a17536f066adc156$var$RDIDX] = 0;\n        this.i32Array[$a17536f066adc156$var$WRIDX] = 0;\n    }\n    silentWrite(n) {\n        let i = this.i32Array[$a17536f066adc156$var$WRIDX];\n        this.f64Array[i] = n;\n        i++;\n        if (i == $a17536f066adc156$var$LEN) i = 0;\n        this.i32Array[$a17536f066adc156$var$WRIDX] = i;\n    }\n    writeArray(arr) {\n        if (arr.length > 0) {\n            for(let i = 0; i < arr.length; i++)this.silentWrite(arr[i]);\n            Atomics.notify(this.i32Array, $a17536f066adc156$var$WRIDX);\n        }\n    }\n    write(n) {\n        this.silentWrite(n);\n        Atomics.notify(this.i32Array, $a17536f066adc156$var$WRIDX);\n    }\n    read() {\n        if (!this.isEmpty()) {\n            let i = this.i32Array[$a17536f066adc156$var$RDIDX];\n            let n = this.f64Array[i];\n            i++;\n            if (i == $a17536f066adc156$var$LEN) i = 0;\n            this.i32Array[$a17536f066adc156$var$RDIDX] = i;\n            return n;\n        } else return undefined;\n    }\n    readWait() {\n        let retVal = this.read();\n        if (retVal !== undefined) return retVal;\n        const rdptr = this.i32Array[$a17536f066adc156$var$RDIDX];\n        // verifies that a shared memory location still contains a given value and if so sleeps until notified.\n        Atomics.wait(this.i32Array, $a17536f066adc156$var$WRIDX, rdptr);\n        retVal = this.read();\n        if (retVal === undefined) throw new Error(\"internal error\");\n        return retVal;\n    }\n    isEmpty() {\n        return this.i32Array[$a17536f066adc156$var$RDIDX] == this.i32Array[$a17536f066adc156$var$WRIDX];\n    }\n}\n\n});\n\n\n\n\n\nparcelRegister(\"7KBfz\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrWasmCall\", () => $5a49b95e459921ed$export$adadb990ab47e6f0);\n$parcel$export(module.exports, \"twrWasmModuleCallAsync\", () => $5a49b95e459921ed$export$9d4f0c051dfa35a8);\n/*\n    * callC takes an array where:\n    * the first entry is the name of the C function in the Wasm module to call (must be exported, typically via the --export clang flag)\n    * and the next entries are a variable number of arguments to pass to the C function, of type\n    * number - converted to int32 or float64 as appropriate\n   * bigint - converted to int64\n    * string - converted to a an index (ptr) into a module Memory returned via stringToMem()\n    * ArrayBuffer - the array is loaded into module memory via putArrayBuffer\n    */ class $5a49b95e459921ed$export$adadb990ab47e6f0 {\n    exports;\n    mem;\n    constructor(mem, exports){\n        if (!exports) throw new Error(\"WebAssembly.Exports undefined\");\n        this.exports = exports;\n        this.mem = mem;\n    }\n    callCImpl(fname, cparams = []) {\n        if (!this.exports[fname]) throw new Error(\"callC: function '\" + fname + \"' not in export table.  Use --export wasm-ld flag.\");\n        const f = this.exports[fname];\n        let cr = f(...cparams);\n        return cr;\n    }\n    callC(params) {\n        const cparams = this.preCallC(params);\n        let retval = this.callCImpl(params[0], cparams);\n        this.postCallC(cparams, params);\n        return retval;\n    }\n    // convert an array of arguments to numbers by stuffing contents into malloc'd Wasm memory\n    preCallC(params) {\n        if (!(params.constructor === Array)) throw new Error(\"callC: params must be array, first arg is function name\");\n        if (params.length == 0) throw new Error(\"callC: missing function name\");\n        let cparams = [];\n        let ci = 0;\n        for(let i = 1; i < params.length; i++){\n            const p = params[i];\n            switch(typeof p){\n                case \"number\":\n                case \"bigint\":\n                    cparams[ci++] = p;\n                    break;\n                case \"string\":\n                    cparams[ci++] = this.mem.putString(p);\n                    break;\n                case \"object\":\n                    if (p instanceof URL) throw new Error(\"URL arg in callC is no longer supported directly.  use module.fetchAndPutURL\");\n                    else if (p instanceof ArrayBuffer) {\n                        const r = this.mem.putArrayBuffer(p);\n                        cparams[ci++] = r; // mem index\n                        break;\n                    }\n                default:\n                    throw new Error(\"callC: invalid object type passed in\");\n            }\n        }\n        return cparams;\n    }\n    // free the mallocs; copy array buffer data from malloc back to arraybuffer\n    postCallC(cparams, params) {\n        let ci = 0;\n        for(let i = 1; i < params.length; i++){\n            const p = params[i];\n            switch(typeof p){\n                case \"number\":\n                case \"bigint\":\n                    ci++;\n                    break;\n                case \"string\":\n                    this.callCImpl(\"free\", [\n                        cparams[ci]\n                    ]);\n                    ci++;\n                    break;\n                case \"object\":\n                    if (p instanceof URL) //this.callCImpl('free',[cparams[ci]])\n                    //ci=ci+2;\n                    throw new Error(\"internal error\");\n                    else if (p instanceof ArrayBuffer) {\n                        const u8 = new Uint8Array(p);\n                        const idx = cparams[ci];\n                        for(let j = 0; j < u8.length; j++)u8[j] = this.mem.mem8[idx + j];\n                        this.callCImpl(\"free\", [\n                            idx\n                        ]);\n                        ci++;\n                        break;\n                    } else throw new Error(\"postCallC: internal error A\");\n                default:\n                    throw new Error(\"postCallC: internal error B\");\n            }\n        }\n        return cparams;\n    }\n}\nclass $5a49b95e459921ed$export$9d4f0c051dfa35a8 {\n    mem;\n    callCImpl;\n    constructor(mem, callCImpl){\n        this.mem = mem;\n        this.callCImpl = callCImpl;\n    }\n    // convert an array of arguments to numbers by stuffing contents into malloc'd Wasm memory\n    async preCallC(params) {\n        if (!(params.constructor === Array)) throw new Error(\"callC: params must be array, first arg is function name\");\n        if (params.length == 0) throw new Error(\"callC: missing function name\");\n        let cparams = [];\n        let ci = 0;\n        for(let i = 1; i < params.length; i++){\n            const p = params[i];\n            switch(typeof p){\n                case \"number\":\n                case \"bigint\":\n                    cparams[ci++] = p;\n                    break;\n                case \"string\":\n                    cparams[ci++] = await this.mem.putString(p);\n                    break;\n                case \"object\":\n                    if (p instanceof URL) throw new Error(\"URL arg in callC is no longer supported directly.  use module.fetchAndPutURL\");\n                    else if (p instanceof ArrayBuffer) {\n                        const r = await this.mem.putArrayBuffer(p);\n                        cparams[ci++] = r; // mem index\n                        break;\n                    }\n                default:\n                    throw new Error(\"callC: invalid object type passed in\");\n            }\n        }\n        return cparams;\n    }\n    // free the mallocs; copy array buffer data from malloc back to arraybuffer\n    async postCallC(cparams, params) {\n        let ci = 0;\n        for(let i = 1; i < params.length; i++){\n            const p = params[i];\n            switch(typeof p){\n                case \"number\":\n                case \"bigint\":\n                    ci++;\n                    break;\n                case \"string\":\n                    await this.callCImpl(\"free\", [\n                        cparams[ci]\n                    ]);\n                    ci++;\n                    break;\n                case \"object\":\n                    if (p instanceof URL) //await this.callCImpl('free',[cparams[ci]])\n                    //ci=ci+2;\n                    throw new Error(\"internal error\");\n                    else if (p instanceof ArrayBuffer) {\n                        const u8 = new Uint8Array(p);\n                        const idx = cparams[ci];\n                        for(let j = 0; j < u8.length; j++)u8[j] = this.mem.mem8[idx + j]; // mem8 is a Uint8Array view of the module's WebAssembly Memory\n                        await this.callCImpl(\"free\", [\n                            idx\n                        ]);\n                        ci++;\n                        break;\n                    } else throw new Error(\"postCallC: internal error A\");\n                default:\n                    throw new Error(\"postCallC: internal error B\");\n            }\n        }\n        return cparams;\n    }\n}\n\n});\n\n\nparcelRegister(\"5baAq\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrWasmModule\", () => $3c56311baef528c2$export$3298af74d75b595c);\n\nvar $eZP3w = parcelRequire(\"eZP3w\");\n\nvar $4Jz48 = parcelRequire(\"4Jz48\");\n\nvar $9lAov = parcelRequire(\"9lAov\");\n\nvar $jxXdl = parcelRequire(\"jxXdl\");\n\nvar $6QEzV = parcelRequire(\"6QEzV\");\n\nvar $kwtqA = parcelRequire(\"kwtqA\");\nclass $3c56311baef528c2$export$3298af74d75b595c extends (0, $jxXdl.twrWasmBase) {\n    io;\n    ioNamesToID;\n    isTwrWasmModuleAsync = false;\n    // divLog is deprecated.  Use IConsole.putStr or log\n    divLog;\n    log;\n    // IWasmMemory\n    // These are deprecated, use wasmMem instead.\n    memory;\n    mem8;\n    mem32;\n    memD;\n    stringToU8;\n    copyString;\n    getLong;\n    setLong;\n    getDouble;\n    setDouble;\n    getShort;\n    getString;\n    getU8Arr;\n    getU32Arr;\n    malloc;\n    free;\n    putString;\n    putU8;\n    putArrayBuffer;\n    /*********************************************************************/ constructor(opts = {}){\n        super();\n        [this.io, this.ioNamesToID] = (0, $eZP3w.parseModOptions)(opts);\n        this.log = (0, $4Jz48.logToCon).bind(undefined, this.io.stdio);\n        this.divLog = this.log;\n    }\n    /*********************************************************************/ async loadWasm(pathToLoad) {\n        // load builtin libraries\n        await (0, $kwtqA.twrLibBuiltIns)();\n        const twrConGetIDFromNameImpl = (nameIdx)=>{\n            const name = this.wasmMem.getString(nameIdx);\n            const id = this.ioNamesToID[name];\n            if (id) return id;\n            else return -1;\n        };\n        let imports = {};\n        for(let i = 0; i < (0, $9lAov.twrLibraryInstanceRegistry).libInterfaceInstances.length; i++){\n            const lib = (0, $9lAov.twrLibraryInstanceRegistry).libInterfaceInstances[i];\n            imports = {\n                ...imports,\n                ...lib.getImports(this)\n            };\n        }\n        imports = {\n            ...imports,\n            twrConGetIDFromName: twrConGetIDFromNameImpl\n        };\n        await super.loadWasm(pathToLoad, imports);\n        if (!(this.wasmMem.memory.buffer instanceof ArrayBuffer)) console.log(\"twrWasmModule does not require shared Memory. Okay to remove wasm-ld --shared-memory --no-check-features\");\n        // backwards compatible\n        this.memory = this.wasmMem.memory;\n        this.mem8 = this.wasmMem.mem8;\n        this.mem32 = this.wasmMem.mem32;\n        this.memD = this.wasmMem.memD;\n        this.malloc = this.wasmMem.malloc;\n        this.free = this.wasmMem.free;\n        this.stringToU8 = this.wasmMem.stringToU8;\n        this.copyString = this.wasmMem.copyString;\n        this.getLong = this.wasmMem.getLong;\n        this.setLong = this.wasmMem.setLong;\n        this.getDouble = this.wasmMem.getDouble;\n        this.setDouble = this.wasmMem.setDouble;\n        this.getShort = this.wasmMem.getShort;\n        this.getString = this.wasmMem.getString;\n        this.getU8Arr = this.wasmMem.getU8Arr;\n        this.getU32Arr = this.wasmMem.getU32Arr;\n        this.putString = this.wasmMem.putString;\n        this.putU8 = this.wasmMem.putU8;\n        this.putArrayBuffer = this.wasmMem.putArrayBuffer;\n        // init C runtime\n        const init = this.exports.twr_wasm_init;\n        init(this.ioNamesToID.stdio, this.ioNamesToID.stderr, this.ioNamesToID.std2d == undefined ? -1 : this.ioNamesToID.std2d, this.wasmMem.mem8.length);\n    }\n    /*********************************************************************/ // given a url, load its contents, and stuff into Wasm memory similar to Unint8Array\n    // TODO!! Doc that this is no longer a CallC option, and must be called here manually\n    async fetchAndPutURL(fnin) {\n        if (!(typeof fnin === \"object\" && fnin instanceof URL)) throw new Error(\"fetchAndPutURL param must be URL\");\n        try {\n            let response = await fetch(fnin);\n            let buffer = await response.arrayBuffer();\n            let src = new Uint8Array(buffer);\n            let dest = this.wasmMem.putU8(src);\n            return [\n                dest,\n                src.length\n            ];\n        } catch (err) {\n            console.log(\"fetchAndPutURL Error. URL: \" + fnin + \"\\n\" + err + (err.stack ? \"\\n\" + err.stack : \"\"));\n            throw err;\n        }\n    }\n    postEvent(eventID, ...params) {\n        //TODO!! PostEvent into eventQueueSend, then processEvents -- to enable non callback events when i add them\n        if (!(eventID in (0, $6QEzV.twrEventQueueReceive).onEventCallbacks)) throw new Error(\"twrWasmModule.postEvent called with invalid eventID: \" + eventID + \", params: \" + params);\n        const onEventCallback = (0, $6QEzV.twrEventQueueReceive).onEventCallbacks[eventID];\n        if (onEventCallback) onEventCallback(eventID, ...params);\n        else throw new Error(\"twrWasmModule.postEvent called with undefined callback.  eventID: \" + eventID + \", params: \" + params);\n    }\n    peekEvent(eventName) {\n    // get earliest inserted entry in event Map\n    //const ev=this.events.get(eventName)\n    }\n}\n\n});\nparcelRegister(\"eZP3w\", function(module, exports) {\n\n$parcel$export(module.exports, \"parseModOptions\", () => $aeae5dd39662a3ec$export$4dd3e184aad418c6);\n// This class extends base to handle options when called in the main Java Script thread\n\nvar $8wznr = parcelRequire(\"8wznr\");\n\nvar $8vcno = parcelRequire(\"8vcno\");\n\nvar $a7Sa2 = parcelRequire(\"a7Sa2\");\n\nvar $9kgjF = parcelRequire(\"9kgjF\");\nfunction $aeae5dd39662a3ec$export$4dd3e184aad418c6(opts = {}) {\n    let io;\n    let ioNamesToID;\n    if (typeof document === \"undefined\") throw new Error(\"twrWasmModuleJSMain should only be created in JavaScript Main.\");\n    // io contains a mapping of names to IConsole\n    // stdio, stderr are required (but if they are not passed in, we will find defaults here)\n    // there can be an arbitrary number of IConsoles passed to a module for use by the module\n    if (opts.io) io = opts.io;\n    else io = {};\n    if (!io.stdio) {\n        const eiodiv = document.getElementById(\"twr_iodiv\");\n        const eiocanvas = document.getElementById(\"twr_iocanvas\");\n        if (opts.stdio) io.stdio = opts.stdio;\n        else if (eiodiv) io.stdio = new (0, $8wznr.twrConsoleDiv)(eiodiv, {\n            foreColor: opts.forecolor,\n            backColor: opts.backcolor,\n            fontSize: opts.fontsize\n        });\n        else if (eiocanvas) io.stdio = new (0, $a7Sa2.twrConsoleTerminal)(eiocanvas, {\n            foreColor: opts.forecolor,\n            backColor: opts.backcolor,\n            fontSize: opts.fontsize,\n            widthInChars: opts.windim?.[0],\n            heightInChars: opts.windim?.[1]\n        });\n        else {\n            io.stdio = new (0, $9kgjF.twrConsoleDebug)();\n            console.log(\"Stdio console is not specified.  Using twrConsoleDebug.\");\n        }\n    }\n    if (!io.stderr) io.stderr = new (0, $9kgjF.twrConsoleDebug)();\n    if (!io.std2d) {\n        if (opts.d2dcanvas) io.std2d = opts.d2dcanvas;\n        else {\n            const ed2dcanvas = document.getElementById(\"twr_d2dcanvas\");\n            if (ed2dcanvas) io.std2d = new (0, $8vcno.twrConsoleCanvas)(ed2dcanvas);\n        }\n    }\n    // each module has a mapping of names to console.id\n    ioNamesToID = {};\n    Object.keys(io).forEach((key)=>{\n        ioNamesToID[key] = io[key].id;\n    });\n    return [\n        io,\n        ioNamesToID\n    ];\n}\n\n});\nparcelRegister(\"8wznr\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrConsoleDiv\", () => $634cc10760be4c8e$export$b0aa7e35767ef6cf);\n\nvar $lVt1a = parcelRequire(\"lVt1a\");\n\nvar $4Jz48 = parcelRequire(\"4Jz48\");\n\nvar $9lAov = parcelRequire(\"9lAov\");\nclass $634cc10760be4c8e$export$b0aa7e35767ef6cf extends (0, $9lAov.twrLibrary) {\n    id;\n    element;\n    CURSOR = String.fromCharCode(9611);\n    cursorOn = false;\n    lastChar = 0;\n    extraBR = false;\n    cpTranslate;\n    keyBuffer = [];\n    keyWaiting;\n    imports = {\n        twrConCharOut: {\n            noBlock: true\n        },\n        twrConGetProp: {},\n        twrConPutStr: {\n            noBlock: true\n        },\n        twrConCharIn: {\n            isAsyncFunction: true,\n            isModuleAsyncOnly: true\n        },\n        twrConSetFocus: {\n            noBlock: true\n        }\n    };\n    libSourcePath = new URL(\"file:///../lib-js/twrcondiv.js\").pathname;\n    interfaceName = \"twrConsole\";\n    constructor(element, params){\n        // all library constructors should start with these two lines\n        super();\n        this.id = (0, $9lAov.twrLibraryInstanceRegistry).register(this);\n        // twrLibraryProxy will construct with no element or params.\n        // this is triggered by defining a function as isCommonCode.  \n        // Such functions should work with undefined constructor args\n        // TODO!! Doc this issue\n        if (element !== undefined) {\n            this.element = element;\n            if (!(element && element instanceof HTMLDivElement)) throw new Error(\"Invalid HTMLDivElement parameter in twrConsoleDiv constructor \");\n            if (params) {\n                if (params.backColor) this.element.style.backgroundColor = params.backColor;\n                if (params.foreColor) this.element.style.color = params.foreColor;\n                if (params.fontSize) this.element.style.font = params.fontSize.toString() + \"px arial\";\n            }\n            this.cpTranslate = new (0, $lVt1a.twrCodePageToUnicodeCodePoint)();\n        }\n    }\n    isHtmlEntityAtEnd(str) {\n        const entityPattern = /&[^;]+;$/;\n        return entityPattern.test(str);\n    }\n    removeHtmlEntityAtEnd(str) {\n        const entityPattern = /&[^;]+;$/;\n        return str.replace(entityPattern, \"\");\n    }\n    twrConSetFocus() {\n        if (this.element === undefined) throw new Error(\"undefined HTMLDivElement\");\n        this.element.focus();\n    }\n    charOut(str) {\n        if (str.length > 1) throw new Error(\"charOut takes an empty or single char string\");\n        this.twrConCharOut(undefined, str.codePointAt(0) || 0, (0, $lVt1a.codePageUTF32));\n    }\n    /*\n     * add utf-8 or windows-1252 character to div.  Supports the following control codes:\n     * any of CRLF, CR (/r), or LF(/n)  will cause a new line\n     * 0x8 backspace\n     * 0xE cursor on\n     * 0xF cursor off\n    */ twrConCharOut(callingMod, ch, codePage) {\n        if (!this.element) throw new Error(\"undefined HTMLDivElement\");\n        if (!this.cpTranslate) throw new Error(\"internal error\");\n        //console.log(\"div::charout: \", ch, codePage);\n        if (this.extraBR) {\n            this.extraBR = false;\n            if (this.cursorOn) this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n            this.element.innerHTML = this.element.innerHTML.slice(0, -4);\n            if (this.cursorOn) this.element.innerHTML += this.CURSOR;\n        }\n        const chnum = this.cpTranslate.convert(ch, codePage);\n        if (chnum != 0) {\n            switch(chnum){\n                case 10:\n                case 13:\n                    if (ch == 10 && this.lastChar == 13) break; // detect CR LF and treat as single new line\n                    if (this.cursorOn) this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    this.element.innerHTML += \"<br><br>\"; //2nd break is a place holder for next line (fixes scroll issue at bottom)\n                    this.extraBR = true;\n                    if (this.cursorOn) this.element.innerHTML += this.CURSOR;\n                    //element.scrollIntoView();\n                    //element.scrollTop = element.scrollHeight;\n                    let p = this.element.getBoundingClientRect();\n                    window.scrollTo(0, p.height + 100);\n                    break;\n                case 8:\n                    if (this.cursorOn) this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    if (this.isHtmlEntityAtEnd(this.element.innerHTML)) this.element.innerHTML = this.removeHtmlEntityAtEnd(this.element.innerHTML);\n                    else this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    if (this.cursorOn) this.element.innerHTML += this.CURSOR;\n                    break;\n                case 0xE:\n                    if (!this.cursorOn) {\n                        this.cursorOn = true;\n                        this.element.innerHTML += this.CURSOR;\n                        this.element.focus();\n                    }\n                    break;\n                case 0xF:\n                    if (this.cursorOn) {\n                        this.cursorOn = false;\n                        this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    }\n                    break;\n                default:\n                    if (this.cursorOn) this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    let newchr = String.fromCodePoint(chnum);\n                    // in html, multiple spaces will be collapsed into one space.  This prevents that behavior.\n                    if (newchr == \" \") newchr = \"&nbsp;\";\n                    this.element.innerHTML += newchr;\n                    if (this.cursorOn) this.element.innerHTML += this.CURSOR;\n                    break;\n            }\n            this.lastChar = chnum;\n        }\n    }\n    twrConGetProp(callingMod, pn) {\n        const propName = callingMod.wasmMem.getString(pn);\n        return this.getProp(propName);\n    }\n    getProp(propName) {\n        if (propName === \"type\") return (0, $4Jz48.IOTypes).CHARWRITE | (0, $4Jz48.IOTypes).CHARREAD;\n        console.log(\"twrConsoleDiv.getProp passed unknown property name: \", propName);\n        return 0;\n    }\n    keyDown(ev) {\n        if (this.keyWaiting) {\n            const r = (0, $4Jz48.keyEventToCodePoint)(ev);\n            if (r) {\n                this.keyWaiting(r);\n                this.keyWaiting = undefined;\n            }\n        } else this.keyBuffer.push(ev);\n    }\n    // TODO!! Should keyBuffer be flushed?  Is keyBuffer needed?\n    async twrConCharIn_async(callingMod) {\n        let ev;\n        return new Promise((resolve)=>{\n            if (this.keyWaiting) throw new Error(\"internal error\");\n            while(ev = this.keyBuffer.shift()){\n                const r = (0, $4Jz48.keyEventToCodePoint)(ev);\n                if (r) {\n                    resolve(r);\n                    return;\n                }\n            }\n            this.keyWaiting = resolve;\n        });\n    }\n    putStr(str) {\n        for(let i = 0; i < str.length; i++)this.twrConCharOut(undefined, str.codePointAt(i), (0, $lVt1a.codePageUTF32));\n    }\n    twrConPutStr(callingMod, chars, codePage) {\n        this.putStr(callingMod.wasmMem.getString(chars, undefined, codePage));\n    }\n}\nvar $634cc10760be4c8e$export$2e2bcd8739ae039 = $634cc10760be4c8e$export$b0aa7e35767ef6cf;\n\n});\nparcelRegister(\"4Jz48\", function(module, exports) {\n\n$parcel$export(module.exports, \"IOTypes\", () => $372690b1a012f88a$export$5d8b86200307417d);\n$parcel$export(module.exports, \"keyEventToCodePoint\", () => $372690b1a012f88a$export$7c0e7cc0cf9b4038);\n$parcel$export(module.exports, \"logToCon\", () => $372690b1a012f88a$export$7bb3402d2891b796);\n//TODO:\n// add io_get_type?\n// i can't figure out how to have this param be a keyof instead of string, with separate params for Stream and Terminal:  getProp: (propName: string)=>number;\n// change printf, and other optimizations if they exist, to call io_putstr\n// implement or deprecate io_begin_draw \n// remove from IModParams: imports:{[index:string]:Function},\n// implement \t//\tIModOpts.imports in twrWasmModuleInJSMain\n// add ability to determine if a console has the input focus\n// remove support for io:{[key:string]: IConsole};\n// add codepage as arg to charout.io_putc to make it more flexible and to align with how setc32 works in io_functions\n// add ability to set a max size for a div con, or to trim it.\n// add helloworld-b to index.html?\n// finish inkey\n// add io_setrange example/test case\n// get rid of this.io and just use ioIDtoNames?\n// add ability to use string colors in io_functions and terminal?\n// add io_get/set_colors support for div console\n// must match IO_TYPEs in twr_io.h\nclass $372690b1a012f88a$export$5d8b86200307417d {\n    static CHARREAD = 1;\n    static CHARWRITE = 2;\n    static ADDRESSABLE_DISPLAY = 4;\n    static CANVAS2D = 8;\n    static EVENTS = 16;\n    // Private constructor to prevent instantiation\n    constructor(){}\n}\nfunction $372690b1a012f88a$export$7c0e7cc0cf9b4038(ev) {\n    if (!ev.isComposing && !ev.metaKey && ev.key != \"Control\" && ev.key != \"Alt\") {\n        //console.log(\"keyDownDiv: \",ev.key, ev.code, ev.key.codePointAt(0), ev);\n        if (ev.key.length == 1) return ev.key.codePointAt(0);\n        else {\n            switch(ev.key){\n                case \"Backspace\":\n                    return 8;\n                case \"Enter\":\n                    return 10;\n                case \"Escape\":\n                    return 0x1B;\n                case \"Delete\":\n                    return 0x7F;\n                case \"ArrowLeft\":\n                    return 0x2190;\n                case \"ArrowUp\":\n                    return 0x2191;\n                case \"ArrowRight\":\n                    return 0x2192;\n                case \"ArrowDown\":\n                    return 0x2193;\n            }\n            console.log(\"keyEventProcess SKIPPED: \", ev.key, ev.code, ev.key.codePointAt(0), ev);\n        }\n    } else console.log(\"keyEventProcess SKIPPED-2: \", ev.key, ev.code, ev.key.codePointAt(0), ev);\n    return undefined;\n}\nfunction $372690b1a012f88a$export$7bb3402d2891b796(con, ...params) {\n    for(var i = 0; i < params.length; i++){\n        con.putStr(params[i].toString());\n        con.charOut(\" \"); // space\n    }\n    con.charOut(\"\\n\");\n}\n\n});\n\n\nparcelRegister(\"8vcno\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrConsoleCanvas\", () => $630ad1ae0230dd63$export$e1daeed5216ed90a);\n\nvar $4Jz48 = parcelRequire(\"4Jz48\");\n\nvar $9lAov = parcelRequire(\"9lAov\");\nvar $630ad1ae0230dd63$var$D2DType;\n(function(D2DType) {\n    D2DType[D2DType[\"D2D_FILLRECT\"] = 1] = \"D2D_FILLRECT\";\n    D2DType[D2DType[\"D2D_FILLCODEPOINT\"] = 5] = \"D2D_FILLCODEPOINT\";\n    D2DType[D2DType[\"D2D_SETLINEWIDTH\"] = 10] = \"D2D_SETLINEWIDTH\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLERGBA\"] = 11] = \"D2D_SETFILLSTYLERGBA\";\n    D2DType[D2DType[\"D2D_SETFONT\"] = 12] = \"D2D_SETFONT\";\n    D2DType[D2DType[\"D2D_BEGINPATH\"] = 13] = \"D2D_BEGINPATH\";\n    D2DType[D2DType[\"D2D_MOVETO\"] = 14] = \"D2D_MOVETO\";\n    D2DType[D2DType[\"D2D_LINETO\"] = 15] = \"D2D_LINETO\";\n    D2DType[D2DType[\"D2D_FILL\"] = 16] = \"D2D_FILL\";\n    D2DType[D2DType[\"D2D_STROKE\"] = 17] = \"D2D_STROKE\";\n    D2DType[D2DType[\"D2D_SETSTROKESTYLERGBA\"] = 18] = \"D2D_SETSTROKESTYLERGBA\";\n    D2DType[D2DType[\"D2D_ARC\"] = 19] = \"D2D_ARC\";\n    D2DType[D2DType[\"D2D_STROKERECT\"] = 20] = \"D2D_STROKERECT\";\n    D2DType[D2DType[\"D2D_FILLTEXT\"] = 21] = \"D2D_FILLTEXT\";\n    D2DType[D2DType[\"D2D_IMAGEDATA\"] = 22] = \"D2D_IMAGEDATA\";\n    D2DType[D2DType[\"D2D_PUTIMAGEDATA\"] = 23] = \"D2D_PUTIMAGEDATA\";\n    D2DType[D2DType[\"D2D_BEZIERTO\"] = 24] = \"D2D_BEZIERTO\";\n    D2DType[D2DType[\"D2D_MEASURETEXT\"] = 25] = \"D2D_MEASURETEXT\";\n    D2DType[D2DType[\"D2D_SAVE\"] = 26] = \"D2D_SAVE\";\n    D2DType[D2DType[\"D2D_RESTORE\"] = 27] = \"D2D_RESTORE\";\n    D2DType[D2DType[\"D2D_CREATERADIALGRADIENT\"] = 28] = \"D2D_CREATERADIALGRADIENT\";\n    D2DType[D2DType[\"D2D_SETCOLORSTOP\"] = 29] = \"D2D_SETCOLORSTOP\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLEGRADIENT\"] = 30] = \"D2D_SETFILLSTYLEGRADIENT\";\n    D2DType[D2DType[\"D2D_RELEASEID\"] = 31] = \"D2D_RELEASEID\";\n    D2DType[D2DType[\"D2D_CREATELINEARGRADIENT\"] = 32] = \"D2D_CREATELINEARGRADIENT\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLE\"] = 33] = \"D2D_SETFILLSTYLE\";\n    D2DType[D2DType[\"D2D_SETSTROKESTYLE\"] = 34] = \"D2D_SETSTROKESTYLE\";\n    D2DType[D2DType[\"D2D_CLOSEPATH\"] = 35] = \"D2D_CLOSEPATH\";\n    D2DType[D2DType[\"D2D_RESET\"] = 36] = \"D2D_RESET\";\n    D2DType[D2DType[\"D2D_CLEARRECT\"] = 37] = \"D2D_CLEARRECT\";\n    D2DType[D2DType[\"D2D_SCALE\"] = 38] = \"D2D_SCALE\";\n    D2DType[D2DType[\"D2D_TRANSLATE\"] = 39] = \"D2D_TRANSLATE\";\n    D2DType[D2DType[\"D2D_ROTATE\"] = 40] = \"D2D_ROTATE\";\n    D2DType[D2DType[\"D2D_GETTRANSFORM\"] = 41] = \"D2D_GETTRANSFORM\";\n    D2DType[D2DType[\"D2D_SETTRANSFORM\"] = 42] = \"D2D_SETTRANSFORM\";\n    D2DType[D2DType[\"D2D_RESETTRANSFORM\"] = 43] = \"D2D_RESETTRANSFORM\";\n    D2DType[D2DType[\"D2D_STROKETEXT\"] = 44] = \"D2D_STROKETEXT\";\n    D2DType[D2DType[\"D2D_ROUNDRECT\"] = 45] = \"D2D_ROUNDRECT\";\n    D2DType[D2DType[\"D2D_ELLIPSE\"] = 46] = \"D2D_ELLIPSE\";\n    D2DType[D2DType[\"D2D_QUADRATICCURVETO\"] = 47] = \"D2D_QUADRATICCURVETO\";\n    D2DType[D2DType[\"D2D_SETLINEDASH\"] = 48] = \"D2D_SETLINEDASH\";\n    D2DType[D2DType[\"D2D_GETLINEDASH\"] = 49] = \"D2D_GETLINEDASH\";\n    D2DType[D2DType[\"D2D_ARCTO\"] = 50] = \"D2D_ARCTO\";\n    D2DType[D2DType[\"D2D_GETLINEDASHLENGTH\"] = 51] = \"D2D_GETLINEDASHLENGTH\";\n    D2DType[D2DType[\"D2D_DRAWIMAGE\"] = 52] = \"D2D_DRAWIMAGE\";\n    D2DType[D2DType[\"D2D_RECT\"] = 53] = \"D2D_RECT\";\n    D2DType[D2DType[\"D2D_TRANSFORM\"] = 54] = \"D2D_TRANSFORM\";\n    D2DType[D2DType[\"D2D_SETLINECAP\"] = 55] = \"D2D_SETLINECAP\";\n    D2DType[D2DType[\"D2D_SETLINEJOIN\"] = 56] = \"D2D_SETLINEJOIN\";\n    D2DType[D2DType[\"D2D_SETLINEDASHOFFSET\"] = 57] = \"D2D_SETLINEDASHOFFSET\";\n    D2DType[D2DType[\"D2D_GETIMAGEDATA\"] = 58] = \"D2D_GETIMAGEDATA\";\n    D2DType[D2DType[\"D2D_IMAGEDATATOC\"] = 59] = \"D2D_IMAGEDATATOC\";\n    D2DType[D2DType[\"D2D_GETCANVASPROPDOUBLE\"] = 60] = \"D2D_GETCANVASPROPDOUBLE\";\n    D2DType[D2DType[\"D2D_GETCANVASPROPSTRING\"] = 61] = \"D2D_GETCANVASPROPSTRING\";\n    D2DType[D2DType[\"D2D_SETCANVASPROPDOUBLE\"] = 62] = \"D2D_SETCANVASPROPDOUBLE\";\n    D2DType[D2DType[\"D2D_SETCANVASPROPSTRING\"] = 63] = \"D2D_SETCANVASPROPSTRING\";\n})($630ad1ae0230dd63$var$D2DType || ($630ad1ae0230dd63$var$D2DType = {}));\nclass $630ad1ae0230dd63$export$e1daeed5216ed90a extends (0, $9lAov.twrLibrary) {\n    id;\n    ctx;\n    element;\n    props;\n    //TODO!! BUG - precomputed objects should be unique for each module that using this twrConsoleCanvas\n    precomputedObjects;\n    imports = {\n        twrConGetProp: {},\n        twrConDrawSeq: {},\n        twrConLoadImage: {\n            isModuleAsyncOnly: true,\n            isAsyncFunction: true\n        }\n    };\n    libSourcePath = new URL(\"file:///../lib-js/twrconcanvas.js\").pathname;\n    interfaceName = \"twrConsole\";\n    constructor(element){\n        // all library constructors should start with these two lines\n        super();\n        this.id = (0, $9lAov.twrLibraryInstanceRegistry).register(this);\n        this.precomputedObjects = {};\n        if (!(element && element instanceof HTMLCanvasElement && element.getContext)) throw new Error(\"Invalid HTMLCanvasElement parameter in twrConsoleCanvas constructor \");\n        this.element = element;\n        const c = element.getContext(\"2d\");\n        if (!c) throw new Error(\"Canvas 2D context not found.\");\n        this.ctx = c;\n        // these two lines are for backwards compatibility with prior version of twr-wasm\n        c.font = \"16 px Courier New\";\n        c.textBaseline = \"top\";\n        this.props = {\n            canvasHeight: element.height,\n            canvasWidth: element.width,\n            type: (0, $4Jz48.IOTypes).CANVAS2D\n        };\n    }\n    getProp(name) {\n        return this.props[name];\n    }\n    twrConGetProp(callingMod, pn) {\n        const propName = callingMod.wasmMem.getString(pn);\n        return this.getProp(propName);\n    }\n    twrConLoadImage_async(mod, urlPtr, id) {\n        return new Promise((resolve)=>{\n            const url = mod.wasmMem.getString(urlPtr);\n            if (id in this.precomputedObjects) console.log(\"warning: D2D_LOADIMAGE ID already exists.\");\n            const img = new Image();\n            img.onload = ()=>{\n                resolve(1);\n            };\n            img.onerror = ()=>{\n                console.log(\"Warning: D2D_LOADIMAGE: failed to load image \" + url);\n                resolve(1);\n            };\n            img.src = url;\n            this.precomputedObjects[id] = img;\n        });\n    }\n    /* see draw2d.h for structs that match */ twrConDrawSeq(mod, ds) {\n        //console.log(\"twr::Canvas enter drawSeq\");\n        if (!this.ctx) return;\n        const wasmMem = mod.wasmMem;\n        const insHdrSize = 16;\n        let currentInsHdr = wasmMem.getLong(ds); /* ds->start */ \n        const lastInsHdr = wasmMem.getLong(ds + 4); /* ds->last */ \n        let currentInsParams = currentInsHdr + insHdrSize;\n        //console.log(\"instruction start, last \",ins.toString(16), lastins.toString(16));\n        let nextInsHdr;\n        //let insCount=0;\n        while(true){\n            //insCount++;\n            const type = wasmMem.getLong(currentInsHdr + 4); /* hdr->type */ \n            switch(type){\n                case $630ad1ae0230dd63$var$D2DType.D2D_FILLRECT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const w = wasmMem.getDouble(currentInsParams + 16);\n                        const h = wasmMem.getDouble(currentInsParams + 24);\n                        this.ctx.fillRect(x, y, w, h);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_STROKERECT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const w = wasmMem.getDouble(currentInsParams + 16);\n                        const h = wasmMem.getDouble(currentInsParams + 24);\n                        this.ctx.strokeRect(x, y, w, h);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_FILLCODEPOINT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const c = wasmMem.getLong(currentInsParams + 16);\n                        let txt = String.fromCodePoint(c);\n                        this.ctx.fillText(txt, x, y);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_FILLTEXT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const codePage = wasmMem.getLong(currentInsParams + 20);\n                        const strPointer = wasmMem.getLong(currentInsParams + 16);\n                        const str = wasmMem.getString(strPointer, undefined, codePage);\n                        //console.log(\"filltext \",x,y,str)\n                        this.ctx.fillText(str, x, y);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_MEASURETEXT:\n                    {\n                        const codePage = wasmMem.getLong(currentInsParams + 8);\n                        const str = wasmMem.getString(wasmMem.getLong(currentInsParams), undefined, codePage);\n                        const tmidx = wasmMem.getLong(currentInsParams + 4);\n                        const tm = this.ctx.measureText(str);\n                        wasmMem.setDouble(tmidx + 0, tm.actualBoundingBoxAscent);\n                        wasmMem.setDouble(tmidx + 8, tm.actualBoundingBoxDescent);\n                        wasmMem.setDouble(tmidx + 16, tm.actualBoundingBoxLeft);\n                        wasmMem.setDouble(tmidx + 24, tm.actualBoundingBoxRight);\n                        wasmMem.setDouble(tmidx + 32, tm.fontBoundingBoxAscent);\n                        wasmMem.setDouble(tmidx + 40, tm.fontBoundingBoxDescent);\n                        wasmMem.setDouble(tmidx + 48, tm.width);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETFONT:\n                    {\n                        const fontPointer = wasmMem.getLong(currentInsParams);\n                        const str = wasmMem.getString(fontPointer);\n                        this.ctx.font = str;\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETFILLSTYLERGBA:\n                    {\n                        const color = wasmMem.getLong(currentInsParams);\n                        const cssColor = \"#\" + (\"00000000\" + color.toString(16)).slice(-8);\n                        this.ctx.fillStyle = cssColor;\n                    //console.log(\"fillstyle: \", this.ctx.fillStyle, \":\", cssColor,\":\", color)\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETSTROKESTYLERGBA:\n                    {\n                        const color = wasmMem.getLong(currentInsParams);\n                        const cssColor = \"#\" + (\"00000000\" + color.toString(16)).slice(-8);\n                        this.ctx.strokeStyle = cssColor;\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETFILLSTYLE:\n                    {\n                        const cssColorPointer = wasmMem.getLong(currentInsParams);\n                        const cssColor = wasmMem.getString(cssColorPointer);\n                        this.ctx.fillStyle = cssColor;\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETSTROKESTYLE:\n                    {\n                        const cssColorPointer = wasmMem.getLong(currentInsParams);\n                        const cssColor = wasmMem.getString(cssColorPointer);\n                        this.ctx.strokeStyle = cssColor;\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETLINEWIDTH:\n                    {\n                        const width = wasmMem.getDouble(currentInsParams);\n                        this.ctx.lineWidth = width;\n                    //console.log(\"twrCanvas D2D_SETLINEWIDTH: \", this.ctx.lineWidth);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_MOVETO:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        this.ctx.moveTo(x, y);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_LINETO:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        this.ctx.lineTo(x, y);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_BEZIERTO:\n                    {\n                        const cp1x = wasmMem.getDouble(currentInsParams);\n                        const cp1y = wasmMem.getDouble(currentInsParams + 8);\n                        const cp2x = wasmMem.getDouble(currentInsParams + 16);\n                        const cp2y = wasmMem.getDouble(currentInsParams + 24);\n                        const x = wasmMem.getDouble(currentInsParams + 32);\n                        const y = wasmMem.getDouble(currentInsParams + 40);\n                        this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_BEGINPATH:\n                    this.ctx.beginPath();\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_FILL:\n                    this.ctx.fill();\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SAVE:\n                    this.ctx.save();\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_RESTORE:\n                    this.ctx.restore();\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_STROKE:\n                    this.ctx.stroke();\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_ARC:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const radius = wasmMem.getDouble(currentInsParams + 16);\n                        const startAngle = wasmMem.getDouble(currentInsParams + 24);\n                        const endAngle = wasmMem.getDouble(currentInsParams + 32);\n                        const counterClockwise = wasmMem.getLong(currentInsParams + 40) != 0;\n                        this.ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_IMAGEDATA:\n                    {\n                        const start = wasmMem.getLong(currentInsParams);\n                        const length = wasmMem.getLong(currentInsParams + 4);\n                        const width = wasmMem.getLong(currentInsParams + 8);\n                        const height = wasmMem.getLong(currentInsParams + 12);\n                        const id = wasmMem.getLong(currentInsParams + 16);\n                        if (id in this.precomputedObjects) console.log(\"warning: D2D_IMAGEDATA ID already exists.\");\n                        if (mod.isTwrWasmModuleAsync) this.precomputedObjects[id] = {\n                            mem8: new Uint8Array(wasmMem.memory.buffer, start, length),\n                            width: width,\n                            height: height\n                        };\n                        else {\n                            const z = new Uint8ClampedArray(wasmMem.memory.buffer, start, length);\n                            this.precomputedObjects[id] = new ImageData(z, width, height);\n                        }\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_CREATERADIALGRADIENT:\n                    {\n                        const x0 = wasmMem.getDouble(currentInsParams);\n                        const y0 = wasmMem.getDouble(currentInsParams + 8);\n                        const radius0 = wasmMem.getDouble(currentInsParams + 16);\n                        const x1 = wasmMem.getDouble(currentInsParams + 24);\n                        const y1 = wasmMem.getDouble(currentInsParams + 32);\n                        const radius1 = wasmMem.getDouble(currentInsParams + 40);\n                        const id = wasmMem.getLong(currentInsParams + 48);\n                        let gradient = this.ctx.createRadialGradient(x0, y0, radius0, x1, y1, radius1);\n                        if (id in this.precomputedObjects) console.log(\"warning: D2D_CREATERADIALGRADIENT ID already exists.\");\n                        this.precomputedObjects[id] = gradient;\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_CREATELINEARGRADIENT:\n                    {\n                        const x0 = wasmMem.getDouble(currentInsParams);\n                        const y0 = wasmMem.getDouble(currentInsParams + 8);\n                        const x1 = wasmMem.getDouble(currentInsParams + 16);\n                        const y1 = wasmMem.getDouble(currentInsParams + 24);\n                        const id = wasmMem.getLong(currentInsParams + 32);\n                        let gradient = this.ctx.createLinearGradient(x0, y0, x1, y1);\n                        if (id in this.precomputedObjects) console.log(\"warning: D2D_CREATELINEARGRADIENT ID already exists.\");\n                        this.precomputedObjects[id] = gradient;\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETCOLORSTOP:\n                    {\n                        const id = wasmMem.getLong(currentInsParams);\n                        const pos = wasmMem.getLong(currentInsParams + 4);\n                        const cssColorPointer = wasmMem.getLong(currentInsParams + 8);\n                        const cssColor = wasmMem.getString(cssColorPointer);\n                        if (!(id in this.precomputedObjects)) throw new Error(\"D2D_SETCOLORSTOP with invalid ID: \" + id);\n                        const gradient = this.precomputedObjects[id];\n                        gradient.addColorStop(pos, cssColor);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETFILLSTYLEGRADIENT:\n                    {\n                        const id = wasmMem.getLong(currentInsParams);\n                        if (!(id in this.precomputedObjects)) throw new Error(\"D2D_SETFILLSTYLEGRADIENT with invalid ID: \" + id);\n                        const gradient = this.precomputedObjects[id];\n                        this.ctx.fillStyle = gradient;\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_RELEASEID:\n                    {\n                        const id = wasmMem.getLong(currentInsParams);\n                        if (this.precomputedObjects[id]) delete this.precomputedObjects[id];\n                        else console.log(\"warning: D2D_RELEASEID with undefined ID \", id);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_PUTIMAGEDATA:\n                    {\n                        const id = wasmMem.getLong(currentInsParams);\n                        const dx = wasmMem.getLong(currentInsParams + 4);\n                        const dy = wasmMem.getLong(currentInsParams + 8);\n                        const dirtyX = wasmMem.getLong(currentInsParams + 12);\n                        const dirtyY = wasmMem.getLong(currentInsParams + 16);\n                        const dirtyWidth = wasmMem.getLong(currentInsParams + 20);\n                        const dirtyHeight = wasmMem.getLong(currentInsParams + 24);\n                        if (!(id in this.precomputedObjects)) throw new Error(\"D2D_PUTIMAGEDATA with invalid ID: \" + id);\n                        //console.log(\"D2D_PUTIMAGEDATA\",start, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight, this.imageData[start]);\n                        let imgData;\n                        if (mod.isTwrWasmModuleAsync) {\n                            //console.log(\"D2D_PUTIMAGEDATA wasmModuleAsync\");\n                            const z = this.precomputedObjects[id]; // Uint8Array\n                            const ca = Uint8ClampedArray.from(z.mem8); // shallow copy\n                            imgData = new ImageData(ca, z.width, z.height);\n                        } else imgData = this.precomputedObjects[id];\n                        if (dirtyWidth == 0 && dirtyHeight == 0) this.ctx.putImageData(imgData, dx, dy);\n                        else this.ctx.putImageData(imgData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_CLOSEPATH:\n                    this.ctx.closePath();\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_RESET:\n                    this.ctx.reset();\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_CLEARRECT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const w = wasmMem.getDouble(currentInsParams + 16);\n                        const h = wasmMem.getDouble(currentInsParams + 24);\n                        this.ctx.clearRect(x, y, w, h);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SCALE:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        this.ctx.scale(x, y);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_TRANSLATE:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        this.ctx.translate(x, y);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_ROTATE:\n                    {\n                        const angle = wasmMem.getDouble(currentInsParams);\n                        this.ctx.rotate(angle);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_GETTRANSFORM:\n                    {\n                        const matrix_ptr = wasmMem.getLong(currentInsParams);\n                        const transform = this.ctx.getTransform();\n                        wasmMem.setDouble(matrix_ptr + 0, transform.a);\n                        wasmMem.setDouble(matrix_ptr + 8, transform.b);\n                        wasmMem.setDouble(matrix_ptr + 16, transform.c);\n                        wasmMem.setDouble(matrix_ptr + 24, transform.d);\n                        wasmMem.setDouble(matrix_ptr + 32, transform.e);\n                        wasmMem.setDouble(matrix_ptr + 40, transform.f);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETTRANSFORM:\n                    {\n                        const a = wasmMem.getDouble(currentInsParams);\n                        const b = wasmMem.getDouble(currentInsParams + 8);\n                        const c = wasmMem.getDouble(currentInsParams + 16);\n                        const d = wasmMem.getDouble(currentInsParams + 24);\n                        const e = wasmMem.getDouble(currentInsParams + 32);\n                        const f = wasmMem.getDouble(currentInsParams + 40);\n                        this.ctx.setTransform(a, b, c, d, e, f);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_RESETTRANSFORM:\n                    this.ctx.resetTransform();\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_STROKETEXT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const codePage = wasmMem.getLong(currentInsParams + 20);\n                        const strPointer = wasmMem.getLong(currentInsParams + 16);\n                        const str = wasmMem.getString(strPointer, undefined, codePage);\n                        this.ctx.strokeText(str, x, y);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_ROUNDRECT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const width = wasmMem.getDouble(currentInsParams + 16);\n                        const height = wasmMem.getDouble(currentInsParams + 24);\n                        const radii = wasmMem.getDouble(currentInsParams + 32);\n                        this.ctx.roundRect(x, y, width, height, radii);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_ELLIPSE:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const radiusX = wasmMem.getDouble(currentInsParams + 16);\n                        const radiusY = wasmMem.getDouble(currentInsParams + 24);\n                        const rotation = wasmMem.getDouble(currentInsParams + 32);\n                        const startAngle = wasmMem.getDouble(currentInsParams + 40);\n                        const endAngle = wasmMem.getDouble(currentInsParams + 48);\n                        const counterClockwise = wasmMem.getLong(currentInsParams + 56) != 0;\n                        this.ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterClockwise);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_QUADRATICCURVETO:\n                    {\n                        const cpx = wasmMem.getDouble(currentInsParams);\n                        const cpy = wasmMem.getDouble(currentInsParams + 8);\n                        const x = wasmMem.getDouble(currentInsParams + 16);\n                        const y = wasmMem.getDouble(currentInsParams + 24);\n                        this.ctx.quadraticCurveTo(cpx, cpy, x, y);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETLINEDASH:\n                    {\n                        const segment_len = wasmMem.getLong(currentInsParams);\n                        const seg_ptr = wasmMem.getLong(currentInsParams + 4);\n                        let segments = [];\n                        for(let i = 0; i < segment_len; i++)segments[i] = wasmMem.getDouble(seg_ptr + i * 8);\n                        this.ctx.setLineDash(segments);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_GETLINEDASH:\n                    {\n                        const segments = this.ctx.getLineDash();\n                        const buffer_length = wasmMem.getLong(currentInsParams);\n                        const buffer_ptr = wasmMem.getLong(currentInsParams + 4);\n                        const segment_length_ptr = currentInsParams + 8;\n                        wasmMem.setLong(segment_length_ptr, segments.length);\n                        if (segments.length > 0) {\n                            for(let i = 0; i < Math.min(segments.length, buffer_length); i++)wasmMem.setDouble(buffer_ptr + i * 8, segments[i]);\n                            if (segments.length > buffer_length) console.log(\"warning: D2D_GETLINEDASH exceeded given max_length, truncating excess\");\n                        }\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_ARCTO:\n                    {\n                        const x1 = wasmMem.getDouble(currentInsParams);\n                        const y1 = wasmMem.getDouble(currentInsParams + 8);\n                        const x2 = wasmMem.getDouble(currentInsParams + 16);\n                        const y2 = wasmMem.getDouble(currentInsParams + 24);\n                        const radius = wasmMem.getDouble(currentInsParams + 32);\n                        this.ctx.arcTo(x1, y1, x2, y2, radius);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_GETLINEDASHLENGTH:\n                    wasmMem.setLong(currentInsParams, this.ctx.getLineDash().length);\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_DRAWIMAGE:\n                    {\n                        const sx = wasmMem.getDouble(currentInsParams);\n                        const sy = wasmMem.getDouble(currentInsParams + 8);\n                        const sWidth = wasmMem.getDouble(currentInsParams + 16);\n                        const sHeight = wasmMem.getDouble(currentInsParams + 24);\n                        const dx = wasmMem.getDouble(currentInsParams + 32);\n                        const dy = wasmMem.getDouble(currentInsParams + 40);\n                        const dWidth = wasmMem.getDouble(currentInsParams + 48);\n                        const dHeight = wasmMem.getDouble(currentInsParams + 56);\n                        const id = wasmMem.getLong(currentInsParams + 64);\n                        if (!(id in this.precomputedObjects)) throw new Error(\"D2D_DRAWIMAGE with invalid ID: \" + id);\n                        let img = this.precomputedObjects[id];\n                        if (sWidth == 0 && sHeight == 0 && dWidth == 0 && dHeight == 0) this.ctx.drawImage(img, dx, dy);\n                        else if (dWidth == 0 && dHeight == 0) this.ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, sWidth, sHeight);\n                        else if (sWidth == 0 && sHeight == 0) this.ctx.drawImage(img, sx, sy, img.width, img.height, dx, dy, dWidth, dHeight);\n                        else this.ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_RECT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const width = wasmMem.getDouble(currentInsParams + 16);\n                        const height = wasmMem.getDouble(currentInsParams + 24);\n                        this.ctx.rect(x, y, width, height);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_TRANSFORM:\n                    {\n                        const a = wasmMem.getDouble(currentInsParams);\n                        const b = wasmMem.getDouble(currentInsParams + 8);\n                        const c = wasmMem.getDouble(currentInsParams + 16);\n                        const d = wasmMem.getDouble(currentInsParams + 24);\n                        const e = wasmMem.getDouble(currentInsParams + 32);\n                        const f = wasmMem.getDouble(currentInsParams + 40);\n                        this.ctx.transform(a, b, c, d, e, f);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETLINECAP:\n                    {\n                        const lineCapPtr = wasmMem.getLong(currentInsParams);\n                        const lineCap = wasmMem.getString(lineCapPtr);\n                        this.ctx.lineCap = lineCap;\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETLINEJOIN:\n                    {\n                        const lineJoinPtr = wasmMem.getLong(currentInsParams);\n                        const lineJoin = wasmMem.getString(lineJoinPtr);\n                        this.ctx.lineJoin = lineJoin;\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETLINEDASHOFFSET:\n                    {\n                        const lineDashOffset = wasmMem.getDouble(currentInsParams);\n                        this.ctx.lineDashOffset = lineDashOffset;\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_GETIMAGEDATA:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const width = wasmMem.getDouble(currentInsParams + 16);\n                        const height = wasmMem.getDouble(currentInsParams + 24);\n                        const id = wasmMem.getLong(currentInsParams + 32);\n                        const imgData = this.ctx.getImageData(x, y, width, height);\n                        if (id in this.precomputedObjects) console.log(\"warning: D2D_GETIMAGEDATA ID already exists.\");\n                        this.precomputedObjects[id] = imgData;\n                    // const memPtr = wasmMem.getLong(currentInsParams+32);\n                    // const memLen = wasmMem.getLong(currentInsParams+36);\n                    // let imgData = this.ctx.getImageData(x, y, width, height);\n                    // const imgLen = imgData.data.byteLength;\n                    // if (imgLen > memLen) console.log(\"Warning: D2D_GETIMAGEDATA was given a buffer smaller than the image size! Extra data is being truncated\");\n                    // owner.mem8.set(imgData.data.slice(0, Math.min(memLen, imgLen)), memPtr);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_IMAGEDATATOC:\n                    {\n                        const bufferPtr = wasmMem.getLong(currentInsParams);\n                        const bufferLen = wasmMem.getLong(currentInsParams + 4);\n                        const id = wasmMem.getLong(currentInsParams + 8);\n                        if (!(id in this.precomputedObjects)) throw new Error(\"D2D_IMAGEDATATOC with invalid ID: \" + id);\n                        const img = this.precomputedObjects[id];\n                        const imgLen = img.data.byteLength;\n                        if (imgLen > bufferLen) console.log(\"Warning: D2D_IMAGEDATATOC was given a buffer smaller than the image size! Extra data is being truncated\");\n                        wasmMem.mem8.set(img.data.slice(0, Math.min(bufferLen, imgLen)), bufferPtr);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_GETCANVASPROPDOUBLE:\n                    {\n                        const valPtr = wasmMem.getLong(currentInsParams);\n                        const namePtr = wasmMem.getLong(currentInsParams + 4);\n                        const propName = wasmMem.getString(namePtr);\n                        const val = this.ctx[propName];\n                        if (typeof val != \"number\") throw new Error(\"D2D_GETCANVASPROPDOUBLE with property \" + propName + \" expected a number, got \" + typeof val + \"!\");\n                        wasmMem.setDouble(valPtr, val);\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_GETCANVASPROPSTRING:\n                    {\n                        const valPtr = wasmMem.getLong(currentInsParams);\n                        const valMaxLen = wasmMem.getLong(currentInsParams + 4);\n                        const namePtr = wasmMem.getLong(currentInsParams + 8);\n                        const propName = wasmMem.getString(namePtr);\n                        const val = this.ctx[propName];\n                        if (typeof val != \"string\") throw new Error(\"D2D_GETCANVASPROPSTRING with property \" + propName + \" expected a string, got \" + typeof val + \"!\");\n                        const encodedVal = wasmMem.stringToU8(val);\n                        if (encodedVal.byteLength >= valMaxLen) console.log(\"Warning: D2D_GETCANVASPROPSTRING was given a buffer smaller than the return value! The extra data is being truncated!\");\n                        const strLen = Math.min(encodedVal.byteLength, valMaxLen - 1); //-1 from valMaxLen for null character\n                        wasmMem.mem8.set(encodedVal.slice(0, strLen), valPtr);\n                        wasmMem.mem8[strLen + valPtr] = 0; //ensure the null character gets set\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETCANVASPROPDOUBLE:\n                    {\n                        const val = wasmMem.getDouble(currentInsParams);\n                        const namePtr = wasmMem.getLong(currentInsParams + 8);\n                        const propName = wasmMem.getString(namePtr);\n                        const prevVal = this.ctx[propName];\n                        if (typeof prevVal != \"number\") throw new Error(\"D2D_SETCANVASPROPDOUBLE with property \" + propName + \" expected a number, got \" + typeof prevVal + \"!\");\n                        this.ctx[propName] = val;\n                    }\n                    break;\n                case $630ad1ae0230dd63$var$D2DType.D2D_SETCANVASPROPSTRING:\n                    {\n                        const valPtr = wasmMem.getLong(currentInsParams);\n                        const namePtr = wasmMem.getLong(currentInsParams + 4);\n                        const val = wasmMem.getString(valPtr);\n                        const propName = wasmMem.getString(namePtr);\n                        const prevVal = this.ctx[propName];\n                        if (typeof prevVal != \"string\") throw new Error(\"D2D_SETCANVASPROPSTRING with property \" + propName + \" expected a string, got \" + typeof prevVal + \"!\");\n                        this.ctx[propName] = val;\n                    }\n                    break;\n                default:\n                    throw new Error(\"unimplemented or unknown Sequence Type in drawSeq: \" + type);\n            }\n            nextInsHdr = wasmMem.getLong(currentInsHdr); /* hdr->next */ \n            if (nextInsHdr == 0) {\n                if (currentInsHdr != lastInsHdr) throw new Error(\"assert type error in twrcanvas, ins!=lastins\");\n                break;\n            }\n            currentInsHdr = nextInsHdr;\n            currentInsParams = currentInsHdr + insHdrSize;\n        }\n    }\n}\nvar $630ad1ae0230dd63$export$2e2bcd8739ae039 = $630ad1ae0230dd63$export$e1daeed5216ed90a;\n\n});\n\nparcelRegister(\"a7Sa2\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrConsoleTerminal\", () => $75f49210bbda5451$export$3217cba298dc07f7);\n\nvar $lVt1a = parcelRequire(\"lVt1a\");\n\nvar $4Jz48 = parcelRequire(\"4Jz48\");\n\nvar $9lAov = parcelRequire(\"9lAov\");\nconst $75f49210bbda5451$var$TRS80_GRAPHIC_MARKER = 0xE000;\nconst $75f49210bbda5451$var$TRS80_GRAPHIC_MARKER_MASK = 0xFF00;\nconst $75f49210bbda5451$var$TRS80_GRAPHIC_CHAR_MASK = 0x003F; // would be 0xC0 if we included the graphics marker bit 0x80\nclass $75f49210bbda5451$export$3217cba298dc07f7 extends (0, $9lAov.twrLibrary) {\n    id;\n    element;\n    ctx;\n    props;\n    size;\n    cellWidth;\n    cellHeight;\n    cellW1;\n    cellW2;\n    cellH1;\n    cellH2;\n    cellH3;\n    isCursorVisible;\n    videoMem;\n    foreColorMem;\n    backColorMem;\n    cpTranslate;\n    keyBuffer = [];\n    keyWaiting;\n    imports = {\n        twrConCharOut: {\n            noBlock: true\n        },\n        twrConGetProp: {},\n        twrConPutStr: {\n            noBlock: true\n        },\n        twrConCharIn: {\n            isAsyncFunction: true,\n            isModuleAsyncOnly: true\n        },\n        twrConSetFocus: {\n            noBlock: true\n        },\n        twrConSetC32: {\n            noBlock: true\n        },\n        twrConCls: {\n            noBlock: true\n        },\n        twrConSetRange: {\n            noBlock: true\n        },\n        twrConSetReset: {\n            noBlock: true\n        },\n        twrConPoint: {},\n        twrConSetCursor: {\n            noBlock: true\n        },\n        twrConSetCursorXY: {\n            noBlock: true\n        },\n        twrConSetColors: {\n            noBlock: true\n        }\n    };\n    libSourcePath = new URL(\"file:///../lib-js/twrconterm.js\").pathname;\n    interfaceName = \"twrConsole\";\n    constructor(canvasElement, params = {}){\n        // all library constructors should start with these two lines\n        super();\n        this.id = (0, $9lAov.twrLibraryInstanceRegistry).register(this);\n        const { foreColor: foreColor = \"white\", backColor: backColor = \"black\", fontSize: fontSize = 16, widthInChars: widthInChars = 80, heightInChars: heightInChars = 25 } = params;\n        // canvasElement is where we will draw the terminal\n        this.element = canvasElement;\n        if (!(canvasElement && canvasElement instanceof HTMLCanvasElement && canvasElement.getContext)) throw new Error(\"Invalid HTMLCanvasElement parameter in twrConsoleTerminal constructor \");\n        let c = canvasElement.getContext(\"2d\");\n        if (!c) throw new Error(\"canvasElement.getContext('2d') failed\");\n        c.font = fontSize.toString() + \"px Courier New\";\n        c.textBaseline = \"top\";\n        const sampleText = \"          \";\n        //const sampleText=String.fromCharCode(2593).repeat(6);   // this shaded block is typically full width in a font\n        const tm = c.measureText(sampleText);\n        const charWidth = Math.ceil(tm.width / sampleText.length); // ceil rounds up (eg .9 -> 1)\n        let fM = c.measureText(\"X\");\n        const charHeight = Math.ceil(fM.fontBoundingBoxAscent + fM.fontBoundingBoxDescent);\n        canvasElement.width = charWidth * widthInChars;\n        canvasElement.height = charHeight * heightInChars;\n        const canvasHeight = canvasElement.height;\n        const canvasWidth = canvasElement.width;\n        //console.log(\"this.props.canvasHeight, this.props.canvasWidth\",this.props.canvasHeight,this.props.canvasWidth);\n        // reset after dims changed.  Not sure if ctx is needed to reset, but others do\n        let c2 = canvasElement.getContext(\"2d\");\n        if (!c2) throw new Error(\"canvas 2D context not found in twrCanvas.constructor (2nd time)\");\n        this.ctx = c2;\n        this.ctx.font = fontSize.toString() + \"px Courier New\";\n        this.ctx.textBaseline = \"top\";\n        c2.fillStyle = backColor;\n        const backColorAsRGB = Number(\"0x\" + c2.fillStyle.slice(1));\n        c2.fillStyle = foreColor;\n        const foreColorAsRGB = Number(\"0x\" + c2.fillStyle.slice(1));\n        const cursorPos = 0;\n        const type = (0, $4Jz48.IOTypes).CHARWRITE | (0, $4Jz48.IOTypes).CHARREAD | (0, $4Jz48.IOTypes).ADDRESSABLE_DISPLAY;\n        this.props = {\n            type: type,\n            cursorPos: cursorPos,\n            foreColorAsRGB: foreColorAsRGB,\n            backColorAsRGB: backColorAsRGB,\n            fontSize: fontSize,\n            widthInChars: widthInChars,\n            heightInChars: heightInChars,\n            canvasHeight: canvasHeight,\n            canvasWidth: canvasWidth,\n            charWidth: charWidth,\n            charHeight: charHeight\n        };\n        this.isCursorVisible = false;\n        this.size = this.props.widthInChars * this.props.heightInChars;\n        this.videoMem = new Array(this.size);\n        this.foreColorMem = new Array(this.size);\n        this.backColorMem = new Array(this.size);\n        this.cellWidth = this.props.charWidth;\n        this.cellHeight = this.props.charHeight;\n        if (this.cellWidth <= 0) throw new Error(\"invalid cellWidth\");\n        if (this.cellHeight <= 0) throw new Error(\"invalid cellHeight\");\n        // Calc each cell separately to avoid rounding errors\n        this.cellW1 = Math.floor(this.cellWidth / 2);\n        this.cellW2 = this.cellWidth - this.cellW1;\n        this.cellH1 = Math.floor(this.cellHeight / 3);\n        this.cellH2 = this.cellH1;\n        this.cellH3 = this.cellHeight - this.cellH1 - this.cellH2;\n        this.twrConCls();\n        this.cpTranslate = new (0, $lVt1a.twrCodePageToUnicodeCodePoint)();\n    }\n    getProp(propName) {\n        return this.props[propName];\n    }\n    twrConGetProp(callingMod, pn) {\n        const propName = callingMod.wasmMem.getString(pn);\n        return this.getProp(propName);\n    }\n    keyDown(ev) {\n        if (this.keyWaiting) {\n            const r = (0, $4Jz48.keyEventToCodePoint)(ev);\n            if (r) {\n                this.keyWaiting(r);\n                this.keyWaiting = undefined;\n            }\n        } else this.keyBuffer.push(ev);\n    }\n    RGB_TO_RGBA(x) {\n        return x << 8 | 0xFF; // JavaScript uses 32-bit signed integers for bitwise operations, which means the leftmost bit is the sign bit. \n    }\n    eraseLine() {\n        for(let i = this.props.cursorPos; i < Math.floor(this.props.cursorPos / this.props.widthInChars) * this.props.widthInChars + this.props.widthInChars; i++)this.setC32(i, \" \");\n    }\n    twrConCharOut(callingMod, c, codePage) {\n        const c32 = this.cpTranslate.convert(c, codePage);\n        if (c32 === 0) return;\n        this.charOut(String.fromCodePoint(c32));\n    }\n    charOut(c32) {\n        if (c32.length > 1) throw new Error(\"charOut takes an empty or single char string\");\n        if (c32 === \"\\n\") {\n            if (this.isCursorVisible) this.setC32(this.props.cursorPos, \" \");\n            this.props.cursorPos = Math.floor(this.props.cursorPos / this.props.widthInChars);\n            this.props.cursorPos = this.props.cursorPos * this.props.widthInChars;\n            this.props.cursorPos = this.props.cursorPos + this.props.widthInChars;\n            /* if return put us on a new line that isn't a scroll, erase the line */ if (this.props.cursorPos < this.size) this.eraseLine();\n        } else if (c32 === \"\\b\") {\n            if (this.props.cursorPos > 0) {\n                if (this.isCursorVisible) this.setC32(this.props.cursorPos, \" \");\n                this.props.cursorPos--;\n                this.setC32(this.props.cursorPos, \" \");\n            }\n        } else if (c32 === \"\\x0e\") this.isCursorVisible = true;\n        else if (c32 === \"\\x0f\") {\n            this.setC32(this.props.cursorPos, \" \");\n            this.isCursorVisible = false;\n        } else if (c32 === String.fromCharCode(24)) {\n            if (this.props.cursorPos > 0) this.props.cursorPos--;\n        } else if (c32 === String.fromCharCode(25)) {\n            if (this.props.cursorPos < this.size - 1) this.props.cursorPos++;\n        } else if (c32 === String.fromCharCode(26)) {\n            if (this.props.cursorPos < this.props.widthInChars * (this.props.heightInChars - 1)) this.props.cursorPos += this.props.widthInChars;\n        } else if (c32 === String.fromCharCode(27)) {\n            if (this.props.cursorPos >= this.props.widthInChars) this.props.cursorPos -= this.props.widthInChars;\n        } else if (c32 === String.fromCharCode(28)) this.props.cursorPos = 0;\n        else if (c32 === String.fromCharCode(29)) this.props.cursorPos = this.props.cursorPos / this.props.widthInChars * this.props.widthInChars;\n        else if (c32 === String.fromCharCode(30)) this.eraseLine();\n        else if (c32 === String.fromCharCode(31)) for(let i = this.props.cursorPos; i < this.size; i++)this.setC32(i, \" \");\n        else {\n            this.setC32(this.props.cursorPos, c32);\n            this.props.cursorPos++;\n        }\n        // Do we need to scroll?\n        if (this.props.cursorPos == this.size) {\n            this.props.cursorPos = this.props.widthInChars * (this.props.heightInChars - 1);\n            for(let i = 0; i < this.props.widthInChars * (this.props.heightInChars - 1); i++){\n                this.videoMem[i] = this.videoMem[i + this.props.widthInChars];\n                this.backColorMem[i] = this.backColorMem[i + this.props.widthInChars];\n                this.foreColorMem[i] = this.foreColorMem[i + this.props.widthInChars];\n            }\n            for(let i = 0; i < this.props.widthInChars; i++){\n                this.videoMem[this.size - i - 1] = 32;\n                this.backColorMem[this.size - i - 1] = this.props.backColorAsRGB;\n                this.foreColorMem[this.size - i - 1] = this.props.foreColorAsRGB;\n            }\n            this.drawRange(0, this.size - 1);\n        }\n        if (this.isCursorVisible) this.setC32(this.props.cursorPos, String.fromCodePoint(9611)); // 9611 is graphic block -- same cursor i use in class twrDiv\n        if (this.props.cursorPos >= this.size) throw new Error(\"internal error: this.props.cursorPos >= this.size\");\n    }\n    //*************************************************\n    putStr(str) {\n        for(let i = 0; i < str.length; i++)this.twrConCharOut(undefined, str.codePointAt(i) || 0, (0, $lVt1a.codePageUTF32));\n    }\n    twrConPutStr(callingMod, chars, codePage) {\n        const str = callingMod.wasmMem.getString(chars, undefined, codePage);\n        for(let i = 0; i < str.length; i++)this.twrConCharOut(callingMod, str.codePointAt(i) || 0, (0, $lVt1a.codePageUTF32));\n    }\n    //*************************************************\n    setC32(location, str) {\n        if (str.length > 1) throw new Error(\"setC32 takes an empty or single char string\");\n        this.twrConSetC32(undefined, location, str.codePointAt(0) || 0);\n    }\n    twrConSetC32(callingMod, location, c32) {\n        if (!(location >= 0 && location < this.size)) throw new Error(\"Invalid location passed to setC32\");\n        this.videoMem[location] = c32;\n        this.backColorMem[location] = this.props.backColorAsRGB;\n        this.foreColorMem[location] = this.props.foreColorAsRGB;\n        // draw one before and one after to fix any character rendering overlap.  \n        // Can happen with anti-aliasing on graphic chars that fill the cell\n        let start = location - 1;\n        if (start < 0) start = 0;\n        let end = location + 1;\n        if (end >= this.size) end = this.size - 1;\n        this.drawRange(start, end);\n        // draw one line above and below as well to fix any character rendering overlap.  \n        // the block cursor typically can cause an issue\n        const startSave = start;\n        const endSave = end;\n        start = start - this.props.widthInChars;\n        end = end - this.props.widthInChars;\n        if (start < 0) start = 0;\n        if (end < 0) end = 0;\n        this.drawRange(start, end);\n        start = startSave + this.props.widthInChars;\n        end = endSave + this.props.widthInChars;\n        if (start >= this.size) start = this.size - 1;\n        if (end >= this.size) end = this.size - 1;\n        this.drawRange(start, end);\n    }\n    //*************************************************\n    twrConCls() {\n        for(let i = 0; i < this.size; i++){\n            this.videoMem[i] = 32;\n            this.backColorMem[i] = this.props.backColorAsRGB;\n            this.foreColorMem[i] = this.props.foreColorAsRGB;\n        }\n        this.props.cursorPos = 0;\n        this.isCursorVisible = false;\n        this.drawRange(0, this.size - 1);\n    }\n    setFillStyleRGB(color) {\n        // const cssColor= \"#\"+(\"00000000\" + color.toString(16)).slice(-8);  RGBA\n        const cssColor = `#${color.toString(16).padStart(6, \"0\")}`;\n        this.ctx.fillStyle = cssColor;\n    }\n    drawTrs80Graphic(offset, val, fgc, bgc) {\n        let x, y;\n        x = offset % this.props.widthInChars * this.cellWidth;\n        y = Math.floor(offset / this.props.widthInChars) * this.cellHeight;\n        this.setFillStyleRGB(bgc);\n        this.ctx.fillRect(x, y, this.cellWidth, this.cellHeight);\n        if (val == 32) return;\n        this.setFillStyleRGB(fgc);\n        if (val & 1) this.ctx.fillRect(x, y, this.cellW1, this.cellH1);\n        y = y + this.cellH1;\n        if (val & 4) this.ctx.fillRect(x, y, this.cellW1, this.cellH2);\n        y = y + this.cellH2;\n        if (val & 16) this.ctx.fillRect(x, y, this.cellW1, this.cellH3);\n        x = x + this.cellW1;\n        if (val & 32) this.ctx.fillRect(x, y, this.cellW2, this.cellH3);\n        y = y - this.cellH2;\n        if (val & 8) this.ctx.fillRect(x, y, this.cellW2, this.cellH2);\n        y = y - this.cellH1;\n        if (val & 2) this.ctx.fillRect(x, y, this.cellW2, this.cellH1);\n    }\n    //**************************************************\n    drawCell(offset, value, fgc, bgc) {\n        if ((value & $75f49210bbda5451$var$TRS80_GRAPHIC_MARKER_MASK) == $75f49210bbda5451$var$TRS80_GRAPHIC_MARKER || value == 32) this.drawTrs80Graphic(offset, value & $75f49210bbda5451$var$TRS80_GRAPHIC_CHAR_MASK, fgc, bgc);\n        else {\n            let x, y;\n            x = offset % this.props.widthInChars * this.cellWidth;\n            y = Math.floor(offset / this.props.widthInChars) * this.cellHeight;\n            this.setFillStyleRGB(bgc);\n            this.ctx.fillRect(x, y, this.cellWidth, this.cellHeight);\n            if (value != 32) {\n                this.setFillStyleRGB(fgc);\n                const txt = String.fromCodePoint(value);\n                this.ctx.fillText(txt, x, y);\n            }\n        }\n    }\n    //*************************************************\n    // !!TODO add ability to setRange colors\n    // !! should this take a bytearray?\n    // !! need to add \"getRange\" to match\n    setRangeJS(start, values) {\n        let k = 0;\n        for(let i = start; i < start + values.length; i++)this.videoMem[i] = values[k++];\n        this.drawRange(start, start + values.length - 1);\n    }\n    twrConSetRange(callingMod, chars, start, len) {\n        let values = [];\n        for(let i = start; i < start + len; i++)values.push(callingMod.wasmMem.getLong(i));\n        this.setRangeJS(start, values);\n    }\n    drawRange(start, end) {\n        for(let i = start; i <= end; i++)this.drawCell(i, this.videoMem[i], this.foreColorMem[i], this.backColorMem[i]);\n    }\n    /*************************************************/ twrConSetReset(callingMod, x, y, isset) {\n        const loc = Math.floor(x / 2) + this.props.widthInChars * Math.floor(y / 3);\n        const cellx = x % 2;\n        const celly = y % 3;\n        if (x < 0 || x > this.props.widthInChars * 2) throw new Error(\"setReset: invalid x value\");\n        if (y < 0 || y > this.props.heightInChars * 3) throw new Error(\"setReset: invalid y value\");\n        if (!((this.videoMem[loc] & $75f49210bbda5451$var$TRS80_GRAPHIC_MARKER_MASK) == $75f49210bbda5451$var$TRS80_GRAPHIC_MARKER)) {\n            this.videoMem[loc] = $75f49210bbda5451$var$TRS80_GRAPHIC_MARKER; /* set to a cleared graphics value */ \n            this.backColorMem[loc] = this.props.backColorAsRGB;\n            this.foreColorMem[loc] = this.props.foreColorAsRGB;\n        }\n        if (isset) this.videoMem[loc] |= 1 << celly * 2 + cellx;\n        else this.videoMem[loc] &= ~(1 << celly * 2 + cellx);\n        this.drawRange(loc, loc);\n    }\n    //*************************************************\n    twrConPoint(callingMod, x, y) {\n        const loc = Math.floor(x / 2) + this.props.widthInChars * Math.floor(y / 3);\n        const cellx = x % 2;\n        const celly = y % 3;\n        if (x < 0 || x > this.props.widthInChars * 2) throw new Error(\"Point: invalid x value\");\n        if (y < 0 || y > this.props.heightInChars * 3) throw new Error(\"Point: invalid y value\");\n        if (!((this.videoMem[loc] & $75f49210bbda5451$var$TRS80_GRAPHIC_MARKER_MASK) == $75f49210bbda5451$var$TRS80_GRAPHIC_MARKER)) return false; /* not a graphic cell, so false */ \n        if (this.videoMem[loc] & 1 << celly * 2 + cellx) return true;\n        else return false;\n    }\n    //*************************************************\n    twrConSetCursor(callingMod, location) {\n        if (location < 0 || location >= this.size) throw new Error(\"setCursor: invalid location: \" + location);\n        this.props.cursorPos = location;\n    }\n    //*************************************************\n    twrConSetCursorXY(callingMod, x, y) {\n        if (x < 0 || y < 0 || this.props.widthInChars * y + x >= this.size) throw new Error(\"setCursorXY: invalid parameter(s)\");\n        this.twrConSetCursor(callingMod, this.props.widthInChars * y + x);\n    }\n    //*************************************************\n    twrConSetColors(callingMod, foreground, background) {\n        this.props.foreColorAsRGB = foreground;\n        this.props.backColorAsRGB = background;\n    }\n    // TODO!! Should keyBuffer be flushed?  Is keyBuffer needed?\n    async twrConCharIn_async(callingMod) {\n        let ev;\n        return new Promise((resolve)=>{\n            if (this.keyWaiting) throw new Error(\"internal error\");\n            while(ev = this.keyBuffer.shift()){\n                const r = (0, $4Jz48.keyEventToCodePoint)(ev);\n                if (r) {\n                    resolve(r);\n                    return;\n                }\n            }\n            this.keyWaiting = resolve;\n        });\n    }\n    twrConSetFocus() {\n        this.element.focus();\n    }\n}\nvar $75f49210bbda5451$export$2e2bcd8739ae039 //TODO!!  Most of these member functions could benefit from a FireAndForget option\n = $75f49210bbda5451$export$3217cba298dc07f7;\n\n});\n\nparcelRegister(\"9kgjF\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrConsoleDebug\", () => $6ca2a3642a328c4c$export$e501d006d4cbf5f7);\n\nvar $4Jz48 = parcelRequire(\"4Jz48\");\n\nvar $lVt1a = parcelRequire(\"lVt1a\");\n\nvar $9lAov = parcelRequire(\"9lAov\");\nclass $6ca2a3642a328c4c$export$e501d006d4cbf5f7 extends (0, $9lAov.twrLibrary) {\n    id;\n    logline = \"\";\n    element = undefined;\n    cpTranslate;\n    imports = {\n        twrConCharOut: {\n            noBlock: true\n        },\n        twrConGetProp: {},\n        twrConPutStr: {\n            noBlock: true\n        }\n    };\n    libSourcePath = new URL(\"file:///../lib-js/twrcondebug.js\").pathname;\n    interfaceName = \"twrConsole\";\n    constructor(){\n        // all library constructors should start with these two lines\n        super();\n        this.id = (0, $9lAov.twrLibraryInstanceRegistry).register(this);\n        this.cpTranslate = new (0, $lVt1a.twrCodePageToUnicodeCodePoint)();\n    }\n    charOut(ch) {\n        if (ch.length > 1) throw new Error(\"charOut takes an empty string or a single char string\");\n        if (ch === \"\\n\") {\n            console.log(this.logline); // ideally without a linefeed, but there is no way to not have a LF with console.log API.\n            this.logline = \"\";\n        } else {\n            this.logline = this.logline + ch;\n            if (this.logline.length >= 300) {\n                console.log(this.logline);\n                this.logline = \"\";\n            }\n        }\n    }\n    twrConCharOut(callingMod, ch, codePage) {\n        const char = this.cpTranslate.convert(ch, codePage);\n        if (char > 0) this.charOut(String.fromCodePoint(char));\n    }\n    getProp(propName) {\n        if (propName === \"type\") return (0, $4Jz48.IOTypes).CHARWRITE;\n        console.log(\"twrConsoleDebug.getProp passed unknown property name: \", propName);\n        return 0;\n    }\n    twrConGetProp(callingMod, pn) {\n        const propName = callingMod.wasmMem.getString(pn);\n        return this.getProp(propName);\n    }\n    putStr(str) {\n        for(let i = 0; i < str.length; i++)this.charOut(str[i]);\n    }\n    twrConPutStr(callingMod, chars, codePage) {\n        this.putStr(callingMod.wasmMem.getString(chars, undefined, codePage));\n    }\n}\nvar $6ca2a3642a328c4c$export$2e2bcd8739ae039 = $6ca2a3642a328c4c$export$e501d006d4cbf5f7;\n\n});\n\n\nparcelRegister(\"kwtqA\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrLibBuiltIns\", () => $ef0d9f8991255236$export$76382e3dd4b349bf);\n// pre-installed libraries go in this file\n\nvar $dCETg = parcelRequire(\"dCETg\");\n\nvar $lVt1a = parcelRequire(\"lVt1a\");\n\nvar $ezn7a = parcelRequire(\"ezn7a\");\n\nvar $8YYID = parcelRequire(\"8YYID\");\n\nvar $3kGIl = parcelRequire(\"3kGIl\");\n\nvar $7qdpQ = parcelRequire(\"7qdpQ\");\n// currently, libraries can only have one instance\nlet $ef0d9f8991255236$var$defaultLibsAreRegistered = false;\nasync function $ef0d9f8991255236$export$76382e3dd4b349bf() {\n    if (!$ef0d9f8991255236$var$defaultLibsAreRegistered) {\n        // add builtin libraries here:\n        new (0, $dCETg.default); // will register self in twrLibraryInstanceRegistry\n        new (0, $lVt1a.default);\n        new (0, $ezn7a.default);\n        new (0, $8YYID.default);\n        new (0, $3kGIl.default);\n        new (0, $7qdpQ.default);\n        $ef0d9f8991255236$var$defaultLibsAreRegistered = true;\n    }\n}\n\n});\nparcelRegister(\"dCETg\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $9eae8aeb8166011a$export$2e2bcd8739ae039);\n\nvar $9lAov = parcelRequire(\"9lAov\");\nclass $9eae8aeb8166011a$export$2e2bcd8739ae039 extends (0, $9lAov.twrLibrary) {\n    id;\n    imports = {\n        twrSin: {\n            isCommonCode: true\n        },\n        twrCos: {\n            isCommonCode: true\n        },\n        twrTan: {\n            isCommonCode: true\n        },\n        twrACos: {\n            isCommonCode: true\n        },\n        twrASin: {\n            isCommonCode: true\n        },\n        twrATan: {\n            isCommonCode: true\n        },\n        twrATan2: {\n            isCommonCode: true\n        },\n        twrFAbs: {\n            isCommonCode: true\n        },\n        twrExp: {\n            isCommonCode: true\n        },\n        twrFloor: {\n            isCommonCode: true\n        },\n        twrCeil: {\n            isCommonCode: true\n        },\n        twrLog: {\n            isCommonCode: true\n        },\n        twrSqrt: {\n            isCommonCode: true\n        },\n        twrTrunc: {\n            isCommonCode: true\n        },\n        twrFMod: {\n            isCommonCode: true\n        },\n        twrPow: {\n            isCommonCode: true\n        },\n        twrAtod: {\n            isCommonCode: true\n        },\n        twrDtoa: {\n            isCommonCode: true\n        },\n        twrToFixed: {\n            isCommonCode: true\n        },\n        twrToExponential: {\n            isCommonCode: true\n        },\n        twrFcvtS: {\n            isCommonCode: true\n        }\n    };\n    libSourcePath = new URL(\"file:///../lib-js/twrlibmath.js\").pathname;\n    constructor(){\n        // all library constructors should start with these two lines\n        super();\n        this.id = (0, $9lAov.twrLibraryInstanceRegistry).register(this);\n    }\n    //////////////////////////////////////////////////////////////////////////////////////\n    // isCommonCode is set -- this means these functions will be used by twrWasmModuleAsync as well as twrWasmModule\n    // This means the functions in twrWasmModuleAsync will not RPC into the JS main thread.\n    // isCommonCode can only be used for functions that runs in a Worker thread, and that don't require the async keyword.\n    twrSin(callingMod, angle) {\n        return Math.sin(angle);\n    }\n    twrCos(callingMod, angle) {\n        return Math.cos(angle);\n    }\n    twrTan(callingMod, angle) {\n        return Math.tan(angle);\n    }\n    twrACos(callingMod, p) {\n        return Math.acos(p);\n    }\n    twrASin(callingMod, p) {\n        return Math.asin(p);\n    }\n    twrATan(callingMod, p) {\n        return Math.atan(p);\n    }\n    twrATan2(callingMod, y, x) {\n        return Math.atan2(y, x);\n    }\n    twrFAbs(callingMod, p) {\n        return Math.abs(p);\n    }\n    twrExp(callingMod, p) {\n        return Math.exp(p);\n    }\n    twrFloor(callingMod, p) {\n        return Math.floor(p);\n    }\n    twrCeil(callingMod, p) {\n        return Math.ceil(p);\n    }\n    twrLog(callingMod, p) {\n        return Math.log(p);\n    }\n    twrSqrt(callingMod, p) {\n        return Math.sqrt(p);\n    }\n    twrTrunc(callingMod, p) {\n        return Math.trunc(p);\n    }\n    twrFMod(callingMod, x, y) {\n        return x % y;\n    }\n    twrPow(callingMod, x, y) {\n        return Math.pow(x, y);\n    }\n    twrAtod(callingMod, ...p) {\n        return this.atod(callingMod.wasmMem, ...p);\n    }\n    twrDtoa(callingMod, ...p) {\n        this.dtoa(callingMod.wasmMem, ...p);\n    }\n    twrToFixed(callingMod, ...p) {\n        this.toFixed(callingMod.wasmMem, ...p);\n    }\n    twrToExponential(callingMod, ...p) {\n        this.toExponential(callingMod.wasmMem, ...p);\n    }\n    twrFcvtS(callingMod, ...p) {\n        return this.fcvtS(callingMod.wasmMem, ...p);\n    }\n    //////////////////////////////////////////////////////////////////////////////////////\n    atod(mem, strptr, len) {\n        const str = mem.getString(strptr, len);\n        const upper = str.trimStart().toUpperCase();\n        if (upper == \"INF\" || upper == \"+INF\" || upper == \"INFINITY\" || upper == \"+INFINITY\") return Number.POSITIVE_INFINITY;\n        else if (upper == \"-INF\" || upper == \"-INFINITY\") return Number.NEGATIVE_INFINITY;\n        else {\n            // allow D for exponent -- old microsoft format they still support in _fctv and I support in my awbasic\n            // parseFloat will handle 'Infinity' and'-Infinity' literal\n            // parseFloat appears to be case sensitive when parsing 'Infinity'\n            // parseFloat ignores leading whitespace\n            // parseFloat() is more lenient than Number() because it ignores trailing invalid characters\n            const r = Number.parseFloat(str.replaceAll(\"D\", \"e\").replaceAll(\"d\", \"e\"));\n            return r;\n        }\n    }\n    dtoa(mem, buffer, buffer_size, value, max_precision) {\n        if (max_precision == -1) {\n            const r = value.toString();\n            mem.copyString(buffer, buffer_size, r);\n        } else {\n            let r = value.toString();\n            if (r.length > max_precision) r = value.toPrecision(max_precision);\n            mem.copyString(buffer, buffer_size, r);\n        }\n    }\n    toFixed(mem, buffer, buffer_size, value, decdigits) {\n        const r = value.toFixed(decdigits);\n        mem.copyString(buffer, buffer_size, r);\n    }\n    toExponential(mem, buffer, buffer_size, value, decdigits) {\n        const r = value.toExponential(decdigits);\n        mem.copyString(buffer, buffer_size, r);\n    }\n    // emulates the MS C lib function _fcvt_s, but doesn't support all ranges of number.\n    // Number.toFixed() has a max size of 100 fractional digits,  and values must be less than 1e+21\n    // Negative exponents must be now smaller than 1e-99\n    // fully-function C version also int he source, but this is the version enabled by default\n    fcvtS(mem, buffer, sizeInBytes, value, fracpart_numdigits, dec, sign // int *\n    ) {\n        if (buffer == 0 || sign == 0 || dec == 0 || sizeInBytes < 1) return 1;\n        let digits;\n        let decpos;\n        let s = 0; // default to positive\n        if (Number.isNaN(value)) {\n            digits = \"1#QNAN00000000000000000000000000000\".slice(0, fracpart_numdigits + 1);\n            decpos = 1;\n        } else if (!Number.isFinite(value)) {\n            digits = \"1#INF00000000000000000000000000000\".slice(0, fracpart_numdigits + 1);\n            decpos = 1;\n        } else if (value == 0) {\n            digits = \"000000000000000000000000000000000000\".slice(0, fracpart_numdigits);\n            decpos = 0;\n        } else {\n            if (value < 0) {\n                s = 1; // negative\n                value = Math.abs(value);\n            }\n            if (fracpart_numdigits > 100 || value > 1e+21 || value < 1e-99) {\n                mem.copyString(buffer, sizeInBytes, \"\");\n                mem.mem32[dec] = 0;\n                return 1;\n            }\n            const roundValStr = value.toFixed(fracpart_numdigits);\n            let [intPart = \"\", fracPart = \"\"] = roundValStr.split(\".\");\n            if (intPart == \"0\") intPart = \"\";\n            if (intPart.length > 0) {\n                decpos = intPart.length;\n                digits = intPart + fracPart;\n            } else {\n                digits = fracPart.replace(/^0+/, \"\"); // remove leading zeros\n                decpos = digits.length - fracPart.length;\n            }\n        }\n        if (sizeInBytes - 1 < digits.length) return 1;\n        mem.copyString(buffer, sizeInBytes, digits);\n        mem.setLong(dec, decpos);\n        mem.setLong(sign, s);\n        return 0;\n    /*\n        this version 'works' with larger numbers than using toFixed, but doesn't round correctly\n  \n        let decpos=0;\n        let digits:string;\n        if (value!=0) decpos=Math.floor(Math.log10(value))+1;\n  \n        if (decpos>0) { // has integer part\n           const intlen=Math.max(decpos, 0);\n           console.log(\"intlen=\",intlen, \"decpos=\",decpos);\n           const [nonExponent, exponent=0] = value.toPrecision(intlen+fracpart_numdigits).split('e');\n           digits=nonExponent.replace('.', '');\n           digits=digits.replace(/^0+/,\"\");  // remove leading zeros\n        }\n        else { // only a fraction\n           const intpart=Math.trunc(value);\n           const fracpart=value-intpart;\n           const prec=fracpart_numdigits- (-decpos);\n           console.log(\"prec=\",prec);\n           if (prec<1) {\n                 digits=\"\";\n           }\n           else {\n                 const [nonExponent, exponent=0] = fracpart.toPrecision(prec).split('e');\n                 digits=nonExponent.replace('.', '');\n                 digits=digits.replace(/^0+/,\"\");\n           }\n        }\n  \n        console.log(\"fcvtS value\",value,\"fracpart_numdigits\",fracpart_numdigits);\n        console.log('digits=',digits);\n        console.log('dec=',decpos);\n        console.log(\"sign=\",s);\n     */ }\n}\n\n});\n\nparcelRegister(\"ezn7a\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $a9b643aa1d2067d4$export$2e2bcd8739ae039);\n\nvar $9lAov = parcelRequire(\"9lAov\");\nclass $a9b643aa1d2067d4$export$2e2bcd8739ae039 extends (0, $9lAov.twrLibrary) {\n    id;\n    imports = {\n        twr_timer_single_shot: {},\n        twr_timer_repeat: {},\n        twr_timer_cancel: {},\n        twr_sleep: {\n            isAsyncFunction: true,\n            isModuleAsyncOnly: true\n        }\n    };\n    libSourcePath = new URL(\"file:///../lib-js/twrlibtimer.js\").pathname;\n    constructor(){\n        // all library constructors should start with these two lines\n        super();\n        this.id = (0, $9lAov.twrLibraryInstanceRegistry).register(this);\n    }\n    twr_timer_single_shot(callingMod, milliSeconds, eventID) {\n        return setTimeout(()=>{\n            callingMod.postEvent(eventID);\n        }, milliSeconds);\n    }\n    twr_timer_repeat(callingMod, milliSeconds, eventID) {\n        return setInterval(()=>{\n            callingMod.postEvent(eventID);\n        }, milliSeconds);\n    }\n    twr_timer_cancel(callingMod, timerID) {\n        clearInterval(timerID);\n    }\n    async twr_sleep_async(callingMod, milliSeconds) {\n        const p = new Promise((resolve)=>{\n            setTimeout(()=>{\n                resolve();\n            }, milliSeconds);\n        });\n        return p;\n    }\n}\n\n});\n\nparcelRegister(\"8YYID\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $68a306d142e55338$export$2e2bcd8739ae039);\n\nvar $9lAov = parcelRequire(\"9lAov\");\nvar $68a306d142e55338$var$NodeType;\n(function(NodeType) {\n    NodeType[NodeType[\"AudioBuffer\"] = 0] = \"AudioBuffer\";\n    NodeType[NodeType[\"HTMLAudioElement\"] = 1] = \"HTMLAudioElement\";\n})($68a306d142e55338$var$NodeType || ($68a306d142e55338$var$NodeType = {}));\nclass $68a306d142e55338$export$2e2bcd8739ae039 extends (0, $9lAov.twrLibrary) {\n    id;\n    imports = {\n        \"twrAudioFromFloatPCM\": {},\n        \"twrAudioFrom8bitPCM\": {},\n        \"twrAudioFrom16bitPCM\": {},\n        \"twrAudioFrom32bitPCM\": {},\n        \"twrAudioGetFloatPCM\": {\n            isAsyncFunction: true\n        },\n        \"twrAudioGet8bitPCM\": {\n            isAsyncFunction: true\n        },\n        \"twrAudioGet16bitPCM\": {\n            isAsyncFunction: true\n        },\n        \"twrAudioGet32bitPCM\": {\n            isAsyncFunction: true\n        },\n        \"twrAudioPlay\": {},\n        \"twrAudioPlayRange\": {},\n        \"twrAudioQueryPlaybackPosition\": {},\n        \"twrAudioLoadSync\": {\n            isAsyncFunction: true,\n            isModuleAsyncOnly: true\n        },\n        \"twrAudioLoad\": {},\n        \"twrAudioFreeID\": {},\n        \"twrAudioStopPlayback\": {},\n        \"twrAudioGetMetadata\": {},\n        \"twrAudioPlaySync\": {\n            isAsyncFunction: true,\n            isModuleAsyncOnly: true\n        },\n        \"twrAudioRangePlaySync\": {\n            isAsyncFunction: true,\n            isModuleAsyncOnly: true\n        },\n        \"twrAudioModifyPlaybackVolume\": {},\n        \"twrAudioModifyPlaybackPan\": {},\n        \"twrAudioModifyPlaybackRate\": {},\n        \"twrAudioPlayFile\": {}\n    };\n    nextID = 0;\n    nextPlaybackID = 0;\n    context = new AudioContext();\n    nodes = [];\n    playbacks = [];\n    // every library should have this line\n    libSourcePath = new URL(\"file:///../lib-js/twrlibaudio.js\").pathname;\n    constructor(){\n        // all library constructors should start with these two lines\n        super();\n        this.id = (0, $9lAov.twrLibraryInstanceRegistry).register(this);\n    }\n    //loads audio from samples using createBuffer and then loading the given data in\n    //data is expected to be a 2d array of channels with data length equal to singleChannelDataLen\n    //so if len is 10 and channels is 1, data is of total length 10\n    //if len is 10 and channels is 2, data is of total length 20, etc.\n    internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen) {\n        const arrayBuffer = this.context.createBuffer(numChannels, singleChannelDataLen, sampleRate);\n        const id = this.nextID++;\n        this.nodes[id] = [\n            $68a306d142e55338$var$NodeType.AudioBuffer,\n            arrayBuffer\n        ];\n        return [\n            arrayBuffer,\n            id\n        ];\n    }\n    twrAudioFromFloatPCM(mod, numChannels, sampleRate, dataPtr, singleChannelDataLen) {\n        const [arrayBuffer, id] = this.internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen);\n        for(let channel = 0; channel < numChannels; channel++){\n            const channelBuff = arrayBuffer.getChannelData(channel);\n            const startPos = dataPtr / 4.0 + channel * singleChannelDataLen;\n            channelBuff.set(mod.wasmMem.memF.slice(startPos, startPos + singleChannelDataLen));\n        }\n        return id;\n    }\n    twrAudioFrom8bitPCM(mod, numChannels, sampleRate, dataPtr, singleChannelDataLen) {\n        const [arrayBuffer, id] = this.internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen);\n        for(let channel = 0; channel < numChannels; channel++){\n            const channelBuff = arrayBuffer.getChannelData(channel);\n            const startPos = dataPtr / 1.0 + channel * singleChannelDataLen;\n            const dataBuff = mod.wasmMem.mem8.slice(startPos, startPos + singleChannelDataLen);\n            for(let i = 0; i < singleChannelDataLen; i++)//convert 8-bit PCM to float\n            //data is signed, so it will also need to find the negatives\n            channelBuff[i] = dataBuff[i] > 127 ? (dataBuff[i] - 256) / 128 : dataBuff[i] / 128;\n        }\n        return id;\n    }\n    twrAudioFrom16bitPCM(mod, numChannels, sampleRate, dataPtr, singleChannelDataLen) {\n        const [arrayBuffer, id] = this.internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen);\n        for(let channel = 0; channel < numChannels; channel++){\n            const channelBuff = arrayBuffer.getChannelData(channel);\n            const startPos = dataPtr / 2.0 + channel * singleChannelDataLen;\n            const dataBuff = mod.wasmMem.mem16.slice(startPos, startPos + singleChannelDataLen);\n            for(let i = 0; i < singleChannelDataLen * 2; i += 2)//convert 16-bit PCM to float\n            channelBuff[i] = dataBuff[i] > 32767 ? (dataBuff[i] - 65536) / 32768 : dataBuff[i] / 32768;\n        }\n        return id;\n    }\n    twrAudioFrom32bitPCM(mod, numChannels, sampleRate, dataPtr, singleChannelDataLen) {\n        const [arrayBuffer, id] = this.internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen);\n        for(let channel = 0; channel < numChannels; channel++){\n            const channelBuff = arrayBuffer.getChannelData(channel);\n            const startPos = dataPtr / 4.0 + channel * singleChannelDataLen;\n            const dataBuff = mod.wasmMem.mem32.slice(startPos, startPos + singleChannelDataLen);\n            for(let i = 0; i < singleChannelDataLen; i++)//convert 32-bit PCM to float\n            channelBuff[i] = dataBuff[i] > 2147483647 ? (dataBuff[i] - 4294967296) / 2147483648 : dataBuff[i] / 2147483648;\n        }\n        return id;\n    }\n    internalGetAnyPCMPart1(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        if (!(nodeID in this.nodes)) throw new Error(`twrAudioGetSamples couldn't find node of ID ${nodeID}`);\n        const node = this.nodes[nodeID];\n        if (node[0] != $68a306d142e55338$var$NodeType.AudioBuffer) throw new Error(`twrAudioGetSamples expected a node of type AudioBuffer, got ${$68a306d142e55338$var$NodeType[node[0]]}!`);\n        const audioBuffer = node[1];\n        const totalLen = audioBuffer.length * audioBuffer.numberOfChannels;\n        mod.wasmMem.setLong(singleChannelDataLenPtr, audioBuffer.length);\n        mod.wasmMem.setLong(channelPtr, audioBuffer.numberOfChannels);\n        return [\n            audioBuffer,\n            totalLen\n        ];\n    }\n    internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, dataSize, part2) {\n        const [node, totalLen] = this.internalGetSamplesPart1(mod, nodeID, singleChannelDataLenPtr, channelPtr);\n        const bufferPtr = mod.malloc(totalLen * dataSize); //len(floatArray) * dataSize bytes/item\n        part2(mod, node, bufferPtr);\n        return bufferPtr;\n    }\n    async internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, dataSize, part2) {\n        const [node, totalLen] = this.internalGetSamplesPart1(mod, nodeID, singleChannelDataLenPtr, channelPtr);\n        const bufferPtr = await mod.malloc(totalLen * dataSize); //len(floatArray) * dataSize bytes/item\n        part2(mod, node, bufferPtr);\n        return bufferPtr;\n    }\n    internalGetSamplesPart1(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        if (!(nodeID in this.nodes)) throw new Error(`twrAudioGetSamples couldn't find node of ID ${nodeID}`);\n        const node = this.nodes[nodeID];\n        if (node[0] != $68a306d142e55338$var$NodeType.AudioBuffer) throw new Error(`twrAudioGetSamples expected a node of type AudioBuffer, got ${$68a306d142e55338$var$NodeType[node[0]]}!`);\n        const audioBuffer = node[1];\n        const totalLen = audioBuffer.length * audioBuffer.numberOfChannels;\n        mod.wasmMem.setLong(singleChannelDataLenPtr, audioBuffer.length);\n        mod.wasmMem.setLong(channelPtr, audioBuffer.numberOfChannels);\n        return [\n            audioBuffer,\n            totalLen\n        ];\n    }\n    internalGetFloatPCMPart2(mod, buffer, bufferPtr) {\n        for(let channel = 0; channel < buffer.numberOfChannels; channel++){\n            let data = buffer.getChannelData(channel);\n            const startPos = bufferPtr / 4 + channel * buffer.length;\n            mod.wasmMem.memF.set(data.slice(0, buffer.length), startPos);\n        }\n    }\n    //Separated into a sync and async module, gets the total amount of data stored\n    //mallocs a buffer of appropriate size (split by sync and async since async needs await)\n    //then copies the audio buffer to the malloced memory and returns the pointer to the memory\n    twrAudioGetFloatPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return this.internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 4, this.internalGetFloatPCMPart2);\n    }\n    async twrAudioGetFloatPCM_async(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return await this.internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 4, this.internalGetFloatPCMPart2);\n    }\n    internalGet8bitPCMPart2(mod, buffer, bufferPtr) {\n        for(let channel = 0; channel < buffer.numberOfChannels; channel++){\n            let data = buffer.getChannelData(channel);\n            const startPos = bufferPtr + channel * buffer.length;\n            const retBuffer = mod.wasmMem.mem8.slice(startPos, buffer.length);\n            for(let i = 0; i < buffer.length; i++)//nergative values will automatically be converted to unsigned when assigning to retBuffer\n            retBuffer[i] = Math.round(data[i] * 128);\n        }\n    }\n    twrAudioGet8bitPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return this.internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 1, this.internalGet8bitPCMPart2);\n    }\n    async twrAudioGet8bitPCM_async(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return await this.internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 1, this.internalGet8bitPCMPart2);\n    }\n    internalGet16bitPCMPart2(mod, buffer, bufferPtr) {\n        for(let channel = 0; channel < buffer.numberOfChannels; channel++){\n            let data = buffer.getChannelData(channel);\n            const startPos = bufferPtr / 2.0 + channel * buffer.length;\n            const retBuffer = mod.wasmMem.mem16.slice(startPos, buffer.length);\n            for(let i = 0; i < buffer.length; i++)//nergative values will automatically be converted to unsigned when assigning to retBuffer\n            retBuffer[i] = Math.round(data[i] * 32768);\n        }\n    }\n    twrAudioGet16bitPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return this.internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 2, this.internalGet16bitPCMPart2);\n    }\n    async twrAudioGet16bitPCM_async(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return await this.internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 2, this.internalGet16bitPCMPart2);\n    }\n    internalGet32bitPCMPart2(mod, buffer, bufferPtr) {\n        for(let channel = 0; channel < buffer.numberOfChannels; channel++){\n            let data = buffer.getChannelData(channel);\n            const startPos = bufferPtr / 4.0 + channel * buffer.length;\n            const retBuffer = mod.wasmMem.mem32.slice(startPos, buffer.length);\n            for(let i = 0; i < buffer.length; i++)//nergative values will automatically be converted to unsigned when assigning to retBuffer\n            retBuffer[i] = Math.round(data[i] * 2147483648);\n        }\n    }\n    twrAudioGet32bitPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return this.internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 4, this.internalGet32bitPCMPart2);\n    }\n    async twrAudioGet21bitPCM_async(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return await this.internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 4, this.internalGet32bitPCMPart2);\n    }\n    //starts playing an audio node,\n    //all nodes are cloned by default so they can be played multiple times\n    //therefor, a new playback_id is returned for querying status\n    twrAudioPlay(mod, nodeID, volume = 1, pan = 0, finishCallback = null) {\n        return this.twrAudioPlayRange(mod, nodeID, 0, null, false, null, volume, pan, finishCallback);\n    }\n    internalAudioPlayRange(mod, nodeID, startSample, endSample, loop, sampleRate, volume, pan) {\n        if (!(nodeID in this.nodes)) throw new Error(`twrLibAudio twrAudioPlayNode was given a non-existant nodeID (${nodeID})!`);\n        if (sampleRate == 0) sampleRate = null;\n        const node = this.nodes[nodeID];\n        let id = this.nextPlaybackID++;\n        let promise;\n        switch(node[0]){\n            case $68a306d142e55338$var$NodeType.AudioBuffer:\n                {\n                    if (endSample == null) endSample = node[1].length;\n                    const buffer = node[1];\n                    const sourceBuffer = this.context.createBufferSource();\n                    sourceBuffer.buffer = buffer;\n                    promise = new Promise((resolve, reject)=>{\n                        sourceBuffer.onended = ()=>{\n                            delete this.playbacks[id];\n                            resolve(id);\n                        };\n                    });\n                    const startTime = startSample / node[1].sampleRate;\n                    const endTime = (endSample - startSample) / node[1].sampleRate;\n                    sourceBuffer.loop = loop;\n                    sourceBuffer.loopStart = startTime;\n                    sourceBuffer.loopEnd = endSample / node[1].sampleRate;\n                    sourceBuffer.playbackRate.value = sampleRate ? sampleRate / node[1].sampleRate : 1.0;\n                    sourceBuffer.start(0, startTime, loop ? undefined : endTime);\n                    const gainNode = this.context.createGain();\n                    gainNode.gain.value = volume;\n                    sourceBuffer.connect(gainNode);\n                    const panNode = this.context.createStereoPanner();\n                    panNode.pan.value = pan;\n                    gainNode.connect(panNode);\n                    panNode.connect(this.context.destination);\n                    this.playbacks[id] = [\n                        $68a306d142e55338$var$NodeType.AudioBuffer,\n                        sourceBuffer,\n                        new Date().getTime(),\n                        node[1].sampleRate,\n                        gainNode,\n                        panNode\n                    ];\n                }\n                break;\n            default:\n                throw new Error(`twrAudioPlayNode unknown type! ${node[0]}`);\n        }\n        return [\n            promise,\n            id\n        ];\n    }\n    twrAudioPlayRange(mod, nodeID, startSample, endSample = null, loop = false, sampleRate = null, volume = 1, pan = 0, finishCallback = null) {\n        if (finishCallback == -1000) finishCallback = null;\n        let [promise, id] = this.internalAudioPlayRange(mod, nodeID, startSample, endSample, loop, sampleRate, volume, pan);\n        if (finishCallback != null) promise.then((playback_id)=>{\n            mod.postEvent(finishCallback, playback_id);\n        });\n        return id;\n    }\n    async twrAudioPlaySync_async(mod, nodeID, volume = 1, pan = 0) {\n        return this.twrAudioPlayRangeSync_async(mod, nodeID, 0, null, false, null, volume, pan);\n    }\n    async twrAudioPlayRangeSync_async(mod, nodeID, startSample, endSample = null, loop = false, sampleRate = null, volume = 1, pan = 0) {\n        let [promise, id] = this.internalAudioPlayRange(mod, nodeID, startSample, endSample, loop, sampleRate, volume, pan);\n        await promise;\n        return id;\n    }\n    //queries current playback positions\n    //if the given ID doesn't exist, assume it was removed because it ended and return -1\n    twrAudioQueryPlaybackPosition(mod, playbackID) {\n        if (!(playbackID in this.playbacks)) return -1;\n        const playback = this.playbacks[playbackID];\n        switch(playback[0]){\n            case $68a306d142e55338$var$NodeType.AudioBuffer:\n                return new Date().getTime() - playback[2];\n            case $68a306d142e55338$var$NodeType.HTMLAudioElement:\n                return playback[1].currentTime;\n            default:\n                throw new Error(`twrAudioQueryPlaybackPosition unknown type! ${playback[0]}`);\n        }\n    }\n    async internalLoadAudio(mod, urlPtr, id) {\n        const url = mod.wasmMem.getString(urlPtr);\n        const res = await fetch(url);\n        const buffer = await this.context.decodeAudioData(await res.arrayBuffer());\n        this.nodes[id] = [\n            $68a306d142e55338$var$NodeType.AudioBuffer,\n            buffer\n        ];\n    }\n    async twrAudioLoadSync_async(mod, urlPtr) {\n        const id = this.nextID++;\n        await this.internalLoadAudio(mod, urlPtr, id);\n        return id;\n    }\n    twrAudioLoad(mod, eventID, urlPtr) {\n        const id = this.nextID++;\n        this.internalLoadAudio(mod, urlPtr, id).then(()=>{\n            mod.postEvent(eventID, id);\n        });\n        return id;\n    }\n    twrAudioFreeID(mod, nodeID) {\n        if (!(nodeID in this.nodes)) throw new Error(`twrAudioFreeID couldn't find node of ID ${nodeID}`);\n        delete this.nodes[nodeID];\n    }\n    // need to clarify some implementation details\n    twrAudioGetMetadata(mod, nodeID, metadataPtr) {\n        if (!(nodeID in this.nodes)) throw new Error(`twrAudioGetMetadata couldn't find node of ID ${nodeID}`);\n        /*\n        struct AudioMetadata {\n           long length;\n           long sample_rate;\n           long channels;\n        };*/ const node = this.nodes[nodeID];\n        switch(node[0]){\n            case $68a306d142e55338$var$NodeType.AudioBuffer:\n                mod.wasmMem.setLong(metadataPtr + 0, node[1].length);\n                mod.wasmMem.setLong(metadataPtr + 4, node[1].sampleRate);\n                mod.wasmMem.setLong(metadataPtr + 8, node[1].numberOfChannels);\n                break;\n            default:\n                throw new Error(`twrAudioGetMetadata unknown type! ${node[0]}`);\n        }\n    }\n    twrAudioStopPlayback(mod, playbackID) {\n        if (!(playbackID in this.playbacks)) {\n            console.log(`Warning: twrAudioStopPlayback was given an ID that didn't exist (${playbackID})!`);\n            return;\n        }\n        const node = this.playbacks[playbackID];\n        // console.log(\"hi!!\");\n        switch(node[0]){\n            case $68a306d142e55338$var$NodeType.AudioBuffer:\n                node[1].stop();\n                break;\n            case $68a306d142e55338$var$NodeType.HTMLAudioElement:\n                node[1].loop = false;\n                node[1].currentTime = Number.MAX_SAFE_INTEGER;\n                //delete index just in case audio hasn't loaded yet\n                delete this.playbacks[playbackID];\n                break;\n            default:\n                throw new Error(`twrAudioStopPlayback unknown type! ${node[0]}`);\n        }\n    // delete this.playbacks[playbackID];\n    }\n    twrAudioModifyPlaybackVolume(mod, playbackID, volume) {\n        if (!(playbackID in this.playbacks)) {\n            console.log(`Warning: twrAudioModifyPlaybackVolume was given an ID that didn't exist (${playbackID})!`);\n            return;\n        }\n        const node = this.playbacks[playbackID];\n        if (volume > 1 || volume < 0) {\n            console.log(`Warning! twrAudioModifyPlaybackVolume was given a volume (${volume}) that wasn't between 0 and 1!`);\n            volume = Math.max(Math.min(volume, 1), 0);\n        }\n        switch(node[0]){\n            case $68a306d142e55338$var$NodeType.AudioBuffer:\n                {\n                    const gainNode = node[4];\n                    gainNode.gain.value = volume;\n                }\n                break;\n            case $68a306d142e55338$var$NodeType.HTMLAudioElement:\n                {\n                    const audio = node[1];\n                    audio.volume = volume;\n                }\n                break;\n        }\n    }\n    twrAudioModifyPlaybackPan(mod, playbackID, pan) {\n        if (!(playbackID in this.playbacks)) {\n            console.log(`Warning: twrAudioModifyPlaybackPan was given an ID that didn't exist (${playbackID})!`);\n            return;\n        }\n        const node = this.playbacks[playbackID];\n        switch(node[0]){\n            case $68a306d142e55338$var$NodeType.AudioBuffer:\n                {\n                    const panNode = node[5];\n                    panNode.pan.value = pan;\n                }\n                break;\n            case $68a306d142e55338$var$NodeType.HTMLAudioElement:\n                throw new Error(\"Can't modify the pan of a playback started by twrAudioPlayFile!\");\n        }\n    }\n    twrAudioModifyPlaybackRate(mod, playbackID, sampleRate) {\n        if (!(playbackID in this.playbacks)) {\n            console.log(`Warning: twrAudioModifyPlaybackRate was given an ID that didn't exist (${playbackID})!`);\n            return;\n        }\n        const node = this.playbacks[playbackID];\n        switch(node[0]){\n            case $68a306d142e55338$var$NodeType.AudioBuffer:\n                {\n                    const playback = node[1];\n                    const baseSampleRate = node[3];\n                    playback.playbackRate.value = sampleRate / baseSampleRate;\n                }\n                break;\n            case $68a306d142e55338$var$NodeType.HTMLAudioElement:\n                {\n                    const audio = node[1];\n                    audio.playbackRate = sampleRate;\n                }\n                break;\n        }\n    }\n    twrAudioPlayFile(mod, fileURLPtr, volume = 1.0, playbackRate = 1.0, loop = false) {\n        const playbackID = this.nextPlaybackID++;\n        const fileURL = mod.wasmMem.getString(fileURLPtr);\n        const audio = new Audio(fileURL);\n        audio.volume = volume;\n        audio.loop = loop;\n        audio.playbackRate = playbackRate;\n        audio.onended = ()=>{\n            delete this.playbacks[playbackID];\n        };\n        audio.play();\n        this.playbacks[playbackID] = [\n            $68a306d142e55338$var$NodeType.HTMLAudioElement,\n            audio\n        ];\n        return playbackID;\n    }\n}\n\n});\n\nparcelRegister(\"3kGIl\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $26d45f890e168707$export$2e2bcd8739ae039);\n\nvar $9lAov = parcelRequire(\"9lAov\");\nclass $26d45f890e168707$export$2e2bcd8739ae039 extends (0, $9lAov.twrLibrary) {\n    id;\n    imports = {\n        twrTimeEpoch: {\n            isCommonCode: true\n        }\n    };\n    libSourcePath = new URL(\"file:///../lib-js/twrlibdate.js\").pathname;\n    constructor(){\n        // all library constructors should start with these two lines\n        super();\n        this.id = (0, $9lAov.twrLibraryInstanceRegistry).register(this);\n    }\n    // return ms since epoch as int64_t\n    twrTimeEpoch(callingMod) {\n        return BigInt(Date.now());\n    }\n}\n\n});\n\nparcelRegister(\"7qdpQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $56755e380ef9440b$export$2e2bcd8739ae039);\n\nvar $9lAov = parcelRequire(\"9lAov\");\nclass $56755e380ef9440b$export$2e2bcd8739ae039 extends (0, $9lAov.twrLibrary) {\n    id;\n    imports = {\n        twrConCharOut: {\n            noBlock: true\n        },\n        twrConGetProp: {},\n        twrConPutStr: {\n            noBlock: true\n        },\n        twrConCharIn: {\n            isAsyncFunction: true,\n            isModuleAsyncOnly: true\n        },\n        twrConSetFocus: {\n            noBlock: true\n        },\n        twrConSetC32: {\n            noBlock: true\n        },\n        twrConCls: {\n            noBlock: true\n        },\n        twrConSetRange: {\n            noBlock: true\n        },\n        twrConSetReset: {\n            noBlock: true\n        },\n        twrConPoint: {},\n        twrConSetCursor: {\n            noBlock: true\n        },\n        twrConSetCursorXY: {\n            noBlock: true\n        },\n        twrConSetColors: {\n            noBlock: true\n        },\n        twrConDrawSeq: {},\n        twrConLoadImage: {\n            isModuleAsyncOnly: true,\n            isAsyncFunction: true\n        }\n    };\n    libSourcePath = new URL(\"file:///../lib-js/twrcondummy.js\").pathname;\n    interfaceName = \"twrConsole\";\n    constructor(){\n        // all library constructors should start with these two lines\n        super();\n        this.id = (0, $9lAov.twrLibraryInstanceRegistry).register(this);\n    }\n    twrConGetProp(callingMod, pn) {\n        throw new Error(\"internal error\");\n    }\n    keyDown(ev) {\n        throw new Error(\"internal error\");\n    }\n    twrConCharOut(callingMod, c, codePage) {\n        throw new Error(\"internal error\");\n    }\n    twrConPutStr(callingMod, chars, codePage) {\n        throw new Error(\"internal error\");\n    }\n    twrConSetC32(callingMod, location, c32) {\n        throw new Error(\"internal error\");\n    }\n    twrConCls() {\n        throw new Error(\"internal error\");\n    }\n    twrConSetRange(callingMod, chars, start, len) {\n        throw new Error(\"internal error\");\n    }\n    setRangeJS(start, values) {\n        throw new Error(\"internal error\");\n    }\n    twrConSetReset(callingMod, x, y, isset) {\n        throw new Error(\"internal error\");\n    }\n    twrConPoint(callingMod, x, y) {\n        throw new Error(\"internal error\");\n    }\n    twrConSetCursor(callingMod, location) {\n        throw new Error(\"internal error\");\n    }\n    twrConSetCursorXY(callingMod, x, y) {\n        throw new Error(\"internal error\");\n    }\n    twrConSetColors(callingMod, foreground, background) {\n        throw new Error(\"internal error\");\n    }\n    async twrConCharIn_async(callingMod) {\n        throw new Error(\"internal error\");\n    }\n    twrConSetFocus() {\n        throw new Error(\"internal error\");\n    }\n    twrConDrawSeq(mod, ds) {\n        throw new Error(\"internal error\");\n    }\n    getProp(name) {\n        throw new Error(\"internal error\");\n    }\n    putStr(str) {\n        throw new Error(\"internal error\");\n    }\n    charOut(c32) {\n        throw new Error(\"internal error\");\n    }\n    twrConLoadImage_async(mod, urlPtr, id) {\n        throw new Error(\"internal error\");\n    }\n}\n\n});\n\n\n\nparcelRegister(\"U6Thw\", function(module, exports) {\n\n$parcel$export(module.exports, \"twrWasmModuleAsync\", () => $0a8a936a2dc396bf$export$678fe6e36ab9a6ff);\n\nvar $4Jz48 = parcelRequire(\"4Jz48\");\n\nvar $eZP3w = parcelRequire(\"eZP3w\");\n\nvar $3tyux = parcelRequire(\"3tyux\");\n\nvar $7KBfz = parcelRequire(\"7KBfz\");\n\nvar $9lAov = parcelRequire(\"9lAov\");\n\nvar $6QEzV = parcelRequire(\"6QEzV\");\n\nvar $kwtqA = parcelRequire(\"kwtqA\");\n\nclass $0a8a936a2dc396bf$export$678fe6e36ab9a6ff {\n    myWorker;\n    loadWasmResolve;\n    loadWasmReject;\n    callCMap;\n    uniqueInt;\n    initLW = false;\n    io;\n    ioNamesToID;\n    wasmMem;\n    callCInstance;\n    eventQueueSend = new (0, $6QEzV.twrEventQueueSend);\n    isTwrWasmModuleAsync = true;\n    // divLog is deprecated.  Use IConsole.putStr or log\n    divLog;\n    log;\n    // IWasmMemory\n    // These are deprecated, use wasmMem instead.\n    memory;\n    exports;\n    mem8;\n    mem32;\n    memD;\n    stringToU8;\n    copyString;\n    getLong;\n    setLong;\n    getDouble;\n    setDouble;\n    getShort;\n    getString;\n    getU8Arr;\n    getU32Arr;\n    malloc;\n    free;\n    putString;\n    putU8;\n    putArrayBuffer;\n    constructor(opts){\n        [this.io, this.ioNamesToID] = (0, $eZP3w.parseModOptions)(opts);\n        this.callCMap = new Map();\n        this.uniqueInt = 1;\n        if (!window.Worker) throw new Error(\"This browser doesn't support web workers.\");\n        const url = new URL((parcelRequire(\"6WTYx\")));\n        this.myWorker = new Worker(url, {\n            type: \"module\"\n        });\n        this.myWorker.onerror = (event)=>{\n            console.log(\"this.myWorker.onerror (undefined message typically means Worker failed to load)\");\n            console.log(\"event.message: \" + event.message);\n            throw event;\n        };\n        this.myWorker.onmessage = this.processMsg.bind(this);\n        this.log = (0, $4Jz48.logToCon).bind(undefined, this.io.stdio);\n        this.divLog = this.log;\n    }\n    async loadWasm(pathToLoad) {\n        if (this.initLW) throw new Error(\"twrWasmModuleAsync::loadWasm can only be called once per instance\");\n        this.initLW = true;\n        // load builtin libraries\n        await (0, $kwtqA.twrLibBuiltIns)();\n        return new Promise((resolve, reject)=>{\n            this.loadWasmResolve = resolve;\n            this.loadWasmReject = reject;\n            // libProxyParams will be everything needed to create Proxy versions of all twrLibraries\n            // libClassInstances has one entry per class, even if multiple instances of same class are registered (ie, interfaceName set)\n            let libProxyParams = [];\n            for(let i = 0; i < (0, $9lAov.twrLibraryInstanceRegistry).libInterfaceInstances.length; i++)libProxyParams.push((0, $9lAov.twrLibraryInstanceRegistry).libInterfaceInstances[i].getProxyParams());\n            const allProxyParams = {\n                libProxyParams: libProxyParams,\n                ioNamesToID: this.ioNamesToID,\n                eventQueueBuffer: this.eventQueueSend.circBuffer.saBuffer\n            };\n            const urlToLoad = new URL(pathToLoad, document.URL);\n            const startMsg = {\n                urlToLoad: urlToLoad.href,\n                allProxyParams: allProxyParams\n            };\n            this.myWorker.postMessage([\n                \"startup\",\n                startMsg\n            ]);\n        });\n    }\n    postEvent(eventID, ...params) {\n        this.eventQueueSend.postEvent(eventID, ...params);\n        this.myWorker.postMessage([\n            \"tickleEventLoop\"\n        ]);\n    }\n    async callC(params) {\n        const cparams = await this.callCInstance.preCallC(params); // will also validate params[0]\n        const retval = await this.callCImpl(params[0], cparams);\n        await this.callCInstance.postCallC(cparams, params);\n        return retval;\n    }\n    async callCImpl(fname, cparams = []) {\n        return new Promise((resolve, reject)=>{\n            const p = {\n                callCResolve: resolve,\n                callCReject: reject\n            };\n            this.callCMap.set(++this.uniqueInt, p);\n            this.myWorker.postMessage([\n                \"callC\",\n                this.uniqueInt,\n                fname,\n                cparams\n            ]);\n        });\n    }\n    // this implementation piggybacks of callCImpl -- it is essentially a specific version of callC\n    // instead of sending a message to the twrWasmModuleAsync thread (as callCImpl does), we post a malloc command\n    // in the eventQueue.  This allows it to be processed  by the twrWasmModuleAsync event loop.  malloc was previously sent using callCImpl, but \n    // callCImpl uses postMessage, and the twrWasmModuleAsync thread will not process the callCImpl message while inside another callC,\n    // and malloc may be used by wasmMem.putXX functions, inside twrWasmLibrary derived classes, which are called from C, inside of a callC.\n    //\n    async mallocImpl(size) {\n        return new Promise((resolve, reject)=>{\n            const p = {\n                callCResolve: resolve,\n                callCReject: reject\n            };\n            this.callCMap.set(++this.uniqueInt, p);\n            this.eventQueueSend.postMalloc(this.uniqueInt, size);\n            this.myWorker.postMessage([\n                \"tickleEventLoop\"\n            ]);\n        });\n    }\n    // the API user can call this to default to stdio\n    // or the API user can call keyDown on a particular console\n    keyDown(ev) {\n        if (!this.io.stdio) throw new Error(\"internal error - stdio not defined\");\n        if (!this.io.stdio.keyDown) throw new Error(\"stdio.keyDown not defined. Console must implemented IConsoleStreamIn.\");\n        this.io.stdio.keyDown(ev);\n    }\n    // this function is deprecated and here for backward compatibility\n    keyDownDiv(ev) {\n        if (this.io.stdio.element && this.io.stdio.element.id == \"twr_iodiv\") this.keyDown(ev);\n        else throw new Error(\"keyDownDiv is deprecated, but in any case should only be used with twr_iodiv\");\n    }\n    // this function is deprecated and here for backward compatibility\n    keyDownCanvas(ev) {\n        if (this.io.stdio.element && this.io.stdio.element.id == \"twr_iocanvas\") this.keyDown(ev);\n        else throw new Error(\"keyDownCanvas is deprecated, but in any case should only be used with twr_iocanvas\");\n    }\n    //  this.myWorker.onmessage = this.processMsg.bind(this);\n    async processMsg(event) {\n        const msg = event.data;\n        const [msgClass, id] = msg;\n        //console.log(\"twrWasmAsyncModule - got message: \"+event.data)\n        if (msgClass === \"twrWasmModule\") {\n            const [, , msgType, ...params] = msg;\n            switch(msgType){\n                case \"setmemory\":\n                    this.memory = params[0];\n                    if (!this.memory) throw new Error(\"unexpected error - undefined memory\");\n                    this.wasmMem = new (0, $3tyux.twrWasmMemoryAsync)(this.memory, this.mallocImpl.bind(this), this.callCImpl.bind(this));\n                    this.callCInstance = new (0, $7KBfz.twrWasmModuleCallAsync)(this.wasmMem, this.callCImpl.bind(this));\n                    // backwards compatible\n                    this.mem8 = this.wasmMem.mem8;\n                    this.mem32 = this.wasmMem.mem32;\n                    this.memD = this.wasmMem.memD;\n                    this.stringToU8 = this.wasmMem.stringToU8;\n                    this.copyString = this.wasmMem.copyString;\n                    this.getLong = this.wasmMem.getLong;\n                    this.setLong = this.wasmMem.setLong;\n                    this.getDouble = this.wasmMem.getDouble;\n                    this.setDouble = this.wasmMem.setDouble;\n                    this.getShort = this.wasmMem.getShort;\n                    this.getString = this.wasmMem.getString;\n                    this.getU8Arr = this.wasmMem.getU8Arr;\n                    this.getU32Arr = this.wasmMem.getU32Arr;\n                    this.malloc = this.wasmMem.malloc;\n                    this.free = this.wasmMem.free;\n                    this.putString = this.wasmMem.putString;\n                    this.putU8 = this.wasmMem.putU8;\n                    this.putArrayBuffer = this.wasmMem.putArrayBuffer;\n                    break;\n                case \"startupFail\":\n                    const [returnCode] = params;\n                    if (this.loadWasmReject) this.loadWasmReject(returnCode);\n                    else throw new Error(\"twrWasmAsyncModule.processMsg unexpected error (undefined loadWasmReject)\");\n                    break;\n                case \"startupOkay\":\n                    if (this.loadWasmResolve) this.loadWasmResolve(undefined);\n                    else throw new Error(\"twrWasmAsyncModule.processMsg unexpected error (undefined loadWasmResolve)\");\n                    break;\n                case \"callCFail\":\n                    {\n                        const [returnCode] = params;\n                        const p = this.callCMap.get(id);\n                        if (!p) throw new Error(\"internal error\");\n                        this.callCMap.delete(id);\n                        if (p.callCReject) p.callCReject(returnCode);\n                        else throw new Error(\"twrWasmAsyncModule.processMsg unexpected error (undefined callCReject)\");\n                    }\n                    break;\n                case \"callCOkay\":\n                    {\n                        const [returnCode] = params;\n                        const p = this.callCMap.get(id);\n                        if (!p) throw new Error(\"internal error\");\n                        this.callCMap.delete(id);\n                        if (p.callCResolve) p.callCResolve(returnCode);\n                        else throw new Error(\"twrWasmAsyncModule.processMsg unexpected error (undefined callCResolve)\");\n                        break;\n                    }\n                default:\n                    throw new Error(\"internal error: \" + msgType);\n            }\n        } else if (msgClass === \"twrLibrary\") {\n            const lib = (0, $9lAov.twrLibraryInstanceRegistry).getLibraryInstance(id);\n            const msgLib = msg;\n            await lib.processMessageFromProxy(msg, this);\n        } else throw new Error(\"twrWasmAsyncModule - unknown and unexpected msgClass: \" + msgClass);\n    }\n    // given a url, load its contents, and stuff into Wasm memory similar to Unint8Array\n    async fetchAndPutURL(fnin) {\n        if (!(typeof fnin === \"object\" && fnin instanceof URL)) throw new Error(\"fetchAndPutURL param must be URL\");\n        try {\n            let response = await fetch(fnin);\n            let buffer = await response.arrayBuffer();\n            let src = new Uint8Array(buffer);\n            let dest = await this.wasmMem.putU8(src);\n            return [\n                dest,\n                src.length\n            ];\n        } catch (err) {\n            console.log(\"fetchAndPutURL Error. URL: \" + fnin + \"\\n\" + err + (err.stack ? \"\\n\" + err.stack : \"\"));\n            throw err;\n        }\n    }\n}\n\n});\nparcelRegister(\"6WTYx\", function(module, exports) {\nmodule.exports = new URL(\"../twrmodasyncproxy.205483dd.js\", import.meta.url).toString();\n\n});\n\n\n\n\n//# sourceMappingURL=index.e96d9fe1.js.map\n","export * from \"./twrwasmbase.js\"\nexport * from \"./twrmod.js\"\nexport * from \"./twrwasmmem.js\"\nexport * from \"./twrmodasync.js\"\nexport * from \"./twrcondiv.js\"\nexport * from \"./twrconterm.js\"\nexport * from \"./twrcon.js\"\nexport * from \"./twrcondebug.js\"\nexport * from \"./twrconcanvas.js\"\nexport * from \"./twrlibrary.js\"\n\n\n\n\n","import { twrWasmMemory } from './twrwasmmem.js';\nimport { twrWasmCall } from \"./twrwasmcall.js\";\nimport { twrEventQueueReceive } from './twreventqueue.js';\nexport class twrWasmBase {\n    exports;\n    wasmMem;\n    wasmCall;\n    callC;\n    /*********************************************************************/\n    getImports(imports) {\n        return {\n            ...imports,\n            twr_register_callback: this.registerCallback.bind(this)\n        };\n    }\n    async loadWasm(pathToLoad, imports) {\n        let response;\n        try {\n            response = await fetch(pathToLoad);\n            if (!response.ok)\n                throw new Error(\"Fetch response error on file '\" + pathToLoad + \"'\\n\" + response.statusText);\n        }\n        catch (err) {\n            console.log('loadWasm() failed to fetch: ' + pathToLoad);\n            throw err;\n        }\n        let instance;\n        try {\n            const wasmBytes = await response.arrayBuffer();\n            instance = await WebAssembly.instantiate(wasmBytes, { env: this.getImports(imports) });\n        }\n        catch (err) {\n            console.log('Wasm instantiate error: ' + err + (err.stack ? \"\\n\" + err.stack : ''));\n            throw err;\n        }\n        if (this.exports)\n            throw new Error(\"Unexpected error -- this.exports already set\");\n        if (!instance.instance.exports)\n            throw new Error(\"Unexpected error - undefined instance.exports\");\n        this.exports = instance.instance.exports;\n        const memory = this.exports.memory;\n        if (!memory)\n            throw new Error(\"Unexpected error - undefined exports.memory\");\n        const malloc = this.exports.malloc;\n        const free = this.exports.free;\n        this.wasmMem = new twrWasmMemory(memory, free, malloc);\n        this.wasmCall = new twrWasmCall(this.wasmMem, this.exports);\n        this.callC = this.wasmCall.callC.bind(this.wasmCall);\n    }\n    //see twrWasmModule.constructor - imports - twr_register_callback:this.registerCallback.bind(this), \n    registerCallback(funcNameIdx) {\n        const funcName = this.wasmMem.getString(funcNameIdx);\n        const onEventCallback = this.exports[funcName];\n        return twrEventQueueReceive.registerCallback(funcName, onEventCallback);\n    }\n}\n//# sourceMappingURL=twrwasmbase.js.map","import {IWasmMemory, twrWasmMemory} from './twrwasmmem.js'\nimport {twrWasmCall} from \"./twrwasmcall.js\"\nimport { twrEventQueueReceive } from './twreventqueue.js';\n\n\n// twrWasmBase is the common code for any twrWasmModuleXXX that loads a .wasm file into its thread.  \n// This is twrWasmModule and twrWasmModuleAsyncProxy.\n// twrWasmBase implements loadWasm (which is passed an import list), as well as containing the classes \n// twrWasmMemory (to access wasm memory) and twrWasmCall (to call wasm exports)\n\nexport type TOnEventCallback = (eventID:number, ...args:number[])=>void;\n\nexport class twrWasmBase {\n   exports!:WebAssembly.Exports;\n   wasmMem!: IWasmMemory;\n   wasmCall!: twrWasmCall;\n   callC!:twrWasmCall[\"callC\"];\n\n   /*********************************************************************/\n\n   private getImports(imports:WebAssembly.ModuleImports) {\n      return {\n         ...imports, \n         twr_register_callback:this.registerCallback.bind(this)\n      }\n   }\n\n   async loadWasm(pathToLoad:string, imports:WebAssembly.ModuleImports) {\n      let response;\n      try {\n         response=await fetch(pathToLoad);\n         if (!response.ok) throw new Error(\"Fetch response error on file '\"+pathToLoad+\"'\\n\"+response.statusText);\n      } catch(err:any) {\n         console.log('loadWasm() failed to fetch: '+pathToLoad);\n         throw err;\n      }\n\n      let instance;\n      try {\n         const wasmBytes = await response.arrayBuffer();\n         instance = await WebAssembly.instantiate(wasmBytes, {env: this.getImports(imports)});\n      } catch(err:any) {\n         console.log('Wasm instantiate error: ' + err + (err.stack ? \"\\n\" + err.stack : ''));\n         throw err;\n      }\n\n      if (this.exports) throw new Error (\"Unexpected error -- this.exports already set\");\n      if (!instance.instance.exports) throw new Error(\"Unexpected error - undefined instance.exports\");\n      this.exports=instance.instance.exports;\n\n      const memory=this.exports.memory as WebAssembly.Memory;\n      if (!memory) throw new Error(\"Unexpected error - undefined exports.memory\");\n\n      const malloc=this.exports.malloc as (size:number)=>number;\n      const free=this.exports.free as (size:number)=>number;\n      this.wasmMem=new twrWasmMemory(memory, free, malloc);\n      this.wasmCall=new twrWasmCall(this.wasmMem, this.exports);\n      this.callC=this.wasmCall.callC.bind(this.wasmCall);\n   }\n\n   \n   //see twrWasmModule.constructor - imports - twr_register_callback:this.registerCallback.bind(this), \n   registerCallback(funcNameIdx:number) {\n      const funcName=this.wasmMem.getString(funcNameIdx);\n      const onEventCallback = this.exports[funcName] as TOnEventCallback;\n      return twrEventQueueReceive.registerCallback(funcName, onEventCallback);\n   }\n\n}\n","import { codePageUTF8, codePage1252, codePageASCII, to1252, toASCII } from \"./twrliblocale.js\";\n/**********************************************************************************************/\n/**********************************************************************************************/\n/**********************************************************************************************/\n/**********************************************************************************************/\nexport class twrWasmMemoryBase {\n    memory;\n    mem8;\n    mem16;\n    mem32;\n    memF;\n    memD;\n    constructor(memory) {\n        this.memory = memory;\n        this.mem8 = new Uint8Array(memory.buffer);\n        this.mem16 = new Uint16Array(memory.buffer);\n        this.mem32 = new Uint32Array(memory.buffer);\n        this.memF = new Float32Array(memory.buffer);\n        this.memD = new Float64Array(memory.buffer);\n    }\n    // convert a Javascript string into byte sequence that encodes the string using UTF8, or the requested codePage\n    stringToU8(sin, codePage = codePageUTF8) {\n        let ru8;\n        if (codePage == codePageUTF8) {\n            const encoder = new TextEncoder();\n            ru8 = encoder.encode(sin);\n        }\n        else if (codePage == codePage1252) {\n            ru8 = new Uint8Array(sin.length);\n            for (let i = 0; i < sin.length; i++) {\n                ru8[i] = to1252(sin[i]);\n            }\n        }\n        else if (codePage == codePageASCII) {\n            ru8 = new Uint8Array(sin.length);\n            for (let i = 0; i < sin.length; i++) {\n                const r = toASCII(sin[i]);\n                ru8[i] = r;\n            }\n        }\n        else {\n            throw new Error(\"unknown codePage: \" + codePage);\n        }\n        return ru8;\n    }\n    // copy a string into existing buffer in the webassembly module memory as utf8 (or specified codePage)\n    // result always null terminated\n    copyString(buffer, buffer_size, sin, codePage = codePageUTF8) {\n        if (buffer_size < 1)\n            throw new Error(\"copyString buffer_size must have length > 0 (room for terminating 0): \" + buffer_size);\n        const ru8 = this.stringToU8(sin, codePage);\n        let i;\n        for (i = 0; i < ru8.length && i < buffer_size - 1; i++)\n            this.mem8[buffer + i] = ru8[i];\n        this.mem8[buffer + i] = 0;\n    }\n    getLong(idx) {\n        const idx32 = Math.floor(idx / 4);\n        if (idx32 * 4 != idx)\n            throw new Error(\"getLong passed non long aligned address\");\n        if (idx32 < 0 || idx32 >= this.mem32.length)\n            throw new Error(\"invalid index passed to getLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\n        const long = this.mem32[idx32];\n        return long;\n    }\n    setLong(idx, value) {\n        const idx32 = Math.floor(idx / 4);\n        if (idx32 * 4 != idx)\n            throw new Error(\"setLong passed non long aligned address\");\n        if (idx32 < 0 || idx32 >= this.mem32.length - 1)\n            throw new Error(\"invalid index passed to setLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\n        this.mem32[idx32] = value;\n    }\n    getDouble(idx) {\n        const idx64 = Math.floor(idx / 8);\n        if (idx64 * 8 != idx)\n            throw new Error(\"getLong passed non Float64 aligned address\");\n        const long = this.memD[idx64];\n        return long;\n    }\n    setDouble(idx, value) {\n        const idx64 = Math.floor(idx / 8);\n        if (idx64 * 8 != idx)\n            throw new Error(\"setDouble passed non Float64 aligned address\");\n        this.memD[idx64] = value;\n    }\n    getShort(idx) {\n        if (idx < 0 || idx >= this.mem8.length)\n            throw new Error(\"invalid index passed to getShort: \" + idx);\n        const short = this.mem8[idx] + this.mem8[idx + 1] * 256;\n        return short;\n    }\n    // get a string out of module memory\n    // null terminated, up until max of (optional) len bytes\n    // len may be longer than the number of characters, if characters are utf-8 encoded\n    getString(strIndex, len, codePage = codePageUTF8) {\n        if (strIndex < 0 || strIndex >= this.mem8.length)\n            throw new Error(\"invalid strIndex passed to getString: \" + strIndex);\n        if (len) {\n            if (len < 0 || len + strIndex > this.mem8.length)\n                throw new Error(\"invalid len  passed to getString: \" + len);\n        }\n        else {\n            len = this.mem8.indexOf(0, strIndex);\n            if (len == -1)\n                throw new Error(\"string is not null terminated\");\n            len = len - strIndex;\n        }\n        let encodeFormat;\n        if (codePage == codePageUTF8)\n            encodeFormat = 'utf-8';\n        else if (codePage == codePage1252)\n            encodeFormat = 'windows-1252';\n        else\n            throw new Error(\"Unsupported codePage: \" + codePage);\n        const td = new TextDecoder(encodeFormat);\n        const u8todecode = new Uint8Array(this.mem8.buffer, strIndex, len);\n        // chrome throws exception when using TextDecoder on SharedArrayBuffer\n        // BUT, instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error, so don't check directly\n        if (this.mem8.buffer instanceof ArrayBuffer) {\n            const sout = td.decode(u8todecode);\n            return sout;\n        }\n        else { // must be SharedArrayBuffer\n            const regularArrayBuffer = new ArrayBuffer(len);\n            const regularUint8Array = new Uint8Array(regularArrayBuffer);\n            regularUint8Array.set(u8todecode);\n            const sout = td.decode(regularUint8Array);\n            return sout;\n        }\n    }\n    // get a byte array out of module memory when passed in index to [size, dataptr]\n    getU8Arr(idx) {\n        if (idx < 0 || idx >= this.mem8.length)\n            throw new Error(\"invalid index passed to getU8: \" + idx);\n        const rv = new Uint32Array((this.mem8.slice(idx, idx + 8)).buffer);\n        let size = rv[0];\n        let dataptr = rv[1];\n        if (dataptr < 0 || dataptr >= (this.mem8.length))\n            throw new Error(\"invalid idx.dataptr passed to getU8\");\n        if (size < 0 || size > (this.mem8.length - dataptr))\n            throw new Error(\"invalid idx.size passed to  getU8\");\n        const u8 = this.mem8.slice(dataptr, dataptr + size);\n        return u8;\n    }\n    // get a int32 array out of module memory when passed in index to [size, dataptr]\n    getU32Arr(idx) {\n        if (idx < 0 || idx >= this.mem8.length)\n            throw new Error(\"invalid index passed to getU32: \" + idx);\n        const rv = new Uint32Array((this.mem8.slice(idx, idx + 8)).buffer);\n        let size = rv[0];\n        let dataptr = rv[1];\n        if (dataptr < 0 || dataptr >= (this.mem8.length))\n            throw new Error(\"invalid idx.dataptr passed to getU32\");\n        if (size < 0 || size > (this.mem8.length - dataptr))\n            throw new Error(\"invalid idx.size passed to  getU32\");\n        if (size % 4 != 0)\n            throw new Error(\"idx.size is not an integer number of 32 bit words\");\n        const u32 = new Uint32Array((this.mem8.slice(dataptr, dataptr + size)).buffer);\n        return u32;\n    }\n}\n/**********************************************************************************************/\n/**********************************************************************************************/\n/**********************************************************************************************/\n/**********************************************************************************************/\nexport class twrWasmMemory extends twrWasmMemoryBase {\n    malloc;\n    free;\n    constructor(memory, free, malloc) {\n        super(memory);\n        this.free = free;\n        this.malloc = malloc;\n    }\n    // allocate and copy a string into the webassembly module memory as utf8 (or the specified codePage)\n    putString(sin, codePage = codePageUTF8) {\n        const ru8 = this.stringToU8(sin, codePage);\n        const strIndex = this.malloc(ru8.length + 1);\n        this.mem8.set(ru8, strIndex);\n        this.mem8[strIndex + ru8.length] = 0;\n        return strIndex;\n    }\n    // allocate and copy a Uint8Array into Wasm mod memory\n    putU8(u8a) {\n        let dest = this.malloc(u8a.length);\n        this.mem8.set(u8a, dest);\n        return dest;\n    }\n    putArrayBuffer(ab) {\n        const u8 = new Uint8Array(ab);\n        return this.putU8(u8);\n    }\n}\n/**********************************************************************************************/\n/**********************************************************************************************/\n/**********************************************************************************************/\n/**********************************************************************************************/\nexport class twrWasmMemoryAsync extends twrWasmMemoryBase {\n    malloc;\n    free;\n    constructor(memory, mallocImpl, callCImpl) {\n        super(memory);\n        this.free = (size) => {\n            return callCImpl(\"free\", [size]);\n        };\n        this.malloc = mallocImpl;\n    }\n    // allocate and copy a string into the webassembly module memory as utf8 (or the specified codePage)\n    async putString(sin, codePage = codePageUTF8) {\n        const ru8 = this.stringToU8(sin, codePage);\n        const strIndex = await this.malloc(ru8.length + 1);\n        this.mem8.set(ru8, strIndex);\n        this.mem8[strIndex + ru8.length] = 0;\n        return strIndex;\n    }\n    // allocate and copy a Uint8Array into Wasm mod memory\n    async putU8(u8a) {\n        let dest = await this.malloc(u8a.length);\n        this.mem8.set(u8a, dest);\n        return dest;\n    }\n    async putArrayBuffer(ab) {\n        const u8 = new Uint8Array(ab);\n        return this.putU8(u8);\n    }\n}\n//# sourceMappingURL=twrwasmmem.js.map","import {codePageUTF8, codePage1252, codePageASCII, to1252, toASCII} from \"./twrliblocale.js\"\n\n// IWasmMemoryBase operate on shared memory, so they will function in any WasmModule \nexport interface IWasmMemoryBase {\n   memory:WebAssembly.Memory;\n   mem8:Uint8Array;\n   mem16:Uint16Array;\n   mem32:Uint32Array;\n   memF:Float32Array;\n   memD:Float64Array;\n   stringToU8(sin:string, codePage?:number):Uint8Array;\n   copyString(buffer:number, buffer_size:number, sin:string, codePage?:number):void;\n   getLong(idx:number): number;\n   setLong(idx:number, value:number):void;\n   getDouble(idx:number): number;\n   setDouble(idx:number, value:number):void;\n   getShort(idx:number): number;\n   getString(strIndex:number, len?:number, codePage?:number): string;\n   getU8Arr(idx:number): Uint8Array;\n   getU32Arr(idx:number): Uint32Array;\n}\n\n// IWasmMemory does not support await, and so will only work in a thread that has the module loaded\n// That would be twrWasmModule, twrWasmModuleAsyncProxy\nexport interface IWasmMemory extends IWasmMemoryBase {\n   malloc:(size:number)=>number;\n   free:(size:number)=>void;\n   putString(sin:string, codePage?:number):number;\n   putU8(u8a:Uint8Array):number;\n   putArrayBuffer(ab:ArrayBuffer):number;\n}\n\n// IWasmMemoryAsync must be used from an async function since await is needed\nexport interface IWasmMemoryAsync extends IWasmMemoryBase {\n   malloc:(size:number)=>Promise<number>;\n   free:(size:number)=>Promise<void>;\n   putString(sin:string, codePage?:number):Promise<number>;\n   putU8(u8a:Uint8Array):Promise<number>;\n   putArrayBuffer(ab:ArrayBuffer):Promise<number>;\n}\n\n/**********************************************************************************************/\n/**********************************************************************************************/\n/**********************************************************************************************/\n/**********************************************************************************************/\n\nexport class twrWasmMemoryBase implements IWasmMemoryBase {\n   memory:WebAssembly.Memory;\n   mem8:Uint8Array;\n   mem16:Uint16Array;\n   mem32:Uint32Array;\n   memF:Float32Array;\n   memD:Float64Array;\n\n   constructor(memory:WebAssembly.Memory) {\n      this.memory=memory;\n      this.mem8 = new Uint8Array(memory.buffer);\n      this.mem16 = new Uint16Array(memory.buffer);\n      this.mem32 = new Uint32Array(memory.buffer);\n      this.memF = new Float32Array(memory.buffer);\n      this.memD = new Float64Array(memory.buffer);\n   }\n\n   // convert a Javascript string into byte sequence that encodes the string using UTF8, or the requested codePage\n   stringToU8(sin:string, codePage=codePageUTF8) {\n\n      let ru8:Uint8Array;\n      if (codePage==codePageUTF8) {\n         const encoder = new TextEncoder();\n         ru8=encoder.encode(sin);\n      }\n      else if (codePage==codePage1252) {\n         ru8=new Uint8Array(sin.length);\n         for (let i = 0; i < sin.length; i++) {\n            ru8[i]=to1252(sin[i]);\n          }\n      }\n      else if (codePage==codePageASCII) {\n         ru8=new Uint8Array(sin.length);\n         for (let i = 0; i < sin.length; i++) {\n            const r=toASCII(sin[i]);\n            ru8[i]=r;\n          }\n      }\n      else {\n         throw new Error(\"unknown codePage: \"+codePage);\n      }\n\n      return ru8;\n   }\n\n   // copy a string into existing buffer in the webassembly module memory as utf8 (or specified codePage)\n   // result always null terminated\n   copyString(buffer:number, buffer_size:number, sin:string, codePage=codePageUTF8):void {\n      if (buffer_size<1) throw new Error(\"copyString buffer_size must have length > 0 (room for terminating 0): \"+buffer_size);\n      \n      const ru8=this.stringToU8(sin, codePage);\n\n      let i;\n      for (i=0; i<ru8.length && i<buffer_size-1; i++)\n         this.mem8[buffer+i]=ru8[i];\n\n      this.mem8[buffer+i]=0;\n   }\n\n   getLong(idx:number): number {\n      const idx32=Math.floor(idx/4);\n      if (idx32*4!=idx) throw new Error(\"getLong passed non long aligned address\")\n      if (idx32<0 || idx32 >= this.mem32.length) throw new Error(\"invalid index passed to getLong: \"+idx+\", this.mem32.length: \"+this.mem32.length);\n      const long:number = this.mem32[idx32];\n      return long;\n   }\n   \n   setLong(idx:number, value:number) {\n        const idx32 = Math.floor(idx / 4);\n        if (idx32 * 4 != idx)\n            throw new Error(\"setLong passed non long aligned address\");\n        if (idx32 < 0 || idx32 >= this.mem32.length-1)\n            throw new Error(\"invalid index passed to setLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\n        this.mem32[idx32]=value;\n    }\n\n   getDouble(idx:number): number {\n      const idx64=Math.floor(idx/8);\n      if (idx64*8!=idx) throw new Error(\"getLong passed non Float64 aligned address\")\n      const long:number = this.memD[idx64];\n      return long;\n   }\n\n   setDouble(idx:number, value:number) {\n      const idx64=Math.floor(idx/8);\n      if (idx64*8!=idx) throw new Error(\"setDouble passed non Float64 aligned address\")\n      this.memD[idx64]=value;\n   }\n\n   getShort(idx:number): number {\n      if (idx<0 || idx>= this.mem8.length) throw new Error(\"invalid index passed to getShort: \"+idx);\n      const short:number = this.mem8[idx]+this.mem8[idx+1]*256;\n      return short;\n   }\n\n   // get a string out of module memory\n   // null terminated, up until max of (optional) len bytes\n   // len may be longer than the number of characters, if characters are utf-8 encoded\n   getString(strIndex:number, len?:number, codePage=codePageUTF8): string {\n      if (strIndex<0 || strIndex >= this.mem8.length) throw new Error(\"invalid strIndex passed to getString: \"+strIndex);\n\n      if (len) {\n         if (len<0 || len+strIndex > this.mem8.length) throw new Error(\"invalid len  passed to getString: \"+len);\n      }\n      else {\n         len = this.mem8.indexOf(0, strIndex);\n         if (len==-1) throw new Error(\"string is not null terminated\");\n         len=len-strIndex;\n      }\n\n      let encodeFormat;\n      if (codePage==codePageUTF8) encodeFormat='utf-8';\n      else if (codePage==codePage1252) encodeFormat='windows-1252';\n      else throw new Error(\"Unsupported codePage: \"+codePage);\n\n      const td=new TextDecoder(encodeFormat);\n      const u8todecode=new Uint8Array(this.mem8.buffer, strIndex, len);\n\n   // chrome throws exception when using TextDecoder on SharedArrayBuffer\n   // BUT, instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error, so don't check directly\n      if (this.mem8.buffer instanceof ArrayBuffer) { \n         const sout:string = td.decode(u8todecode);\n         return sout;\n      }\n      else {  // must be SharedArrayBuffer\n         const regularArrayBuffer = new ArrayBuffer(len);\n         const regularUint8Array = new Uint8Array(regularArrayBuffer);\n         regularUint8Array.set(u8todecode);\n         const sout:string = td.decode(regularUint8Array);\n         return sout;\n      }\n   }\n\n   // get a byte array out of module memory when passed in index to [size, dataptr]\n   getU8Arr(idx:number): Uint8Array {\n      if (idx<0 || idx>= this.mem8.length) throw new Error(\"invalid index passed to getU8: \"+idx);\n\n      const rv = new Uint32Array( (this.mem8.slice(idx, idx+8)).buffer );\n      let size:number=rv[0];\n      let dataptr:number=rv[1];\n\n      if (dataptr <0 || dataptr >= (this.mem8.length)) throw new Error(\"invalid idx.dataptr passed to getU8\")\n      if (size <0 || size > (this.mem8.length-dataptr)) throw new Error(\"invalid idx.size passed to  getU8\")\n\n      const u8=this.mem8.slice(dataptr, dataptr+size);\n      return u8;\n   }\n\n   // get a int32 array out of module memory when passed in index to [size, dataptr]\n   getU32Arr(idx:number): Uint32Array {\n      if (idx<0 || idx>= this.mem8.length) throw new Error(\"invalid index passed to getU32: \"+idx);\n\n      const rv = new Uint32Array( (this.mem8.slice(idx, idx+8)).buffer );\n      let size:number=rv[0];\n      let dataptr:number=rv[1];\n\n      if (dataptr <0 || dataptr >= (this.mem8.length)) throw new Error(\"invalid idx.dataptr passed to getU32\")\n      if (size <0 || size > (this.mem8.length-dataptr)) throw new Error(\"invalid idx.size passed to  getU32\")\n\n      if (size%4!=0) throw new Error(\"idx.size is not an integer number of 32 bit words\");\n\n      const u32 = new Uint32Array( (this.mem8.slice(dataptr, dataptr+size)).buffer );\n      return u32;\n   }\n}\n\n/**********************************************************************************************/\n/**********************************************************************************************/\n/**********************************************************************************************/\n/**********************************************************************************************/\n\nexport class twrWasmMemory extends twrWasmMemoryBase implements IWasmMemory {\n   malloc:(size:number)=>number;\n   free:(size:number)=>void;\n\n   constructor(memory:WebAssembly.Memory, free:(size:number)=>void, malloc:(size:number)=>number) {\n      super(memory);\n      this.free=free;\n      this.malloc=malloc;\n   }\n\n   // allocate and copy a string into the webassembly module memory as utf8 (or the specified codePage)\n   putString(sin:string, codePage=codePageUTF8) {\n      const ru8=this.stringToU8(sin, codePage);\n      const strIndex:number=this.malloc(ru8.length+1);\n      this.mem8.set(ru8, strIndex);\n      this.mem8[strIndex+ru8.length]=0;\n\n      return strIndex;\n   }\n\n   // allocate and copy a Uint8Array into Wasm mod memory\n   putU8(u8a:Uint8Array) {\n      let dest:number=this.malloc(u8a.length); \n      this.mem8.set(u8a, dest);\n      return dest;\n   }\n\n   putArrayBuffer(ab:ArrayBuffer) {\n      const u8=new Uint8Array(ab);\n      return this.putU8(u8);\n   }\n}\n\n/**********************************************************************************************/\n/**********************************************************************************************/\n/**********************************************************************************************/\n/**********************************************************************************************/\n\nexport class twrWasmMemoryAsync extends twrWasmMemoryBase implements IWasmMemoryAsync {\n   malloc:(size:number)=>Promise<number>;\n   free:(size:number)=>Promise<void>;\n\n   constructor(memory:WebAssembly.Memory, mallocImpl:(size:number)=>Promise<number>, callCImpl:(funcName:string, any:[...any])=>Promise<any>) {\n      super(memory);\n      this.free = (size:number) => {\n         return callCImpl(\"free\", [size]) as Promise<void>;\n      }\n      this.malloc = mallocImpl;\n   }\n\n   // allocate and copy a string into the webassembly module memory as utf8 (or the specified codePage)\n   async putString(sin:string, codePage=codePageUTF8) {\n      const ru8=this.stringToU8(sin, codePage);\n      const strIndex:number=await this.malloc(ru8.length+1);\n      this.mem8.set(ru8, strIndex);\n      this.mem8[strIndex+ru8.length]=0;\n\n      return strIndex;\n   }\n\n   // allocate and copy a Uint8Array into Wasm mod memory\n   async putU8(u8a:Uint8Array) {\n      let dest:number=await this.malloc(u8a.length); \n      this.mem8.set(u8a, dest);\n      return dest;\n   }\n\n  async putArrayBuffer(ab:ArrayBuffer) {\n      const u8=new Uint8Array(ab);\n      return this.putU8(u8);\n   }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","import { twrLibrary, twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\n///////////////////////////////////////////////////////////////////////////////////////\n// these match C #defines in locale.h\nexport const codePageASCII = 0;\nexport const codePage1252 = 1252;\nexport const codePageUTF8 = 65001;\nexport const codePageUTF32 = 12000;\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\nexport default class twrLibLocale extends twrLibrary {\n    id;\n    imports = {\n        twrUnicodeCodePointToCodePage: { isCommonCode: true },\n        twrCodePageToUnicodeCodePoint: { isCommonCode: true },\n        twrUserLanguage: { isCommonCode: true },\n        twrTimeTmLocal: { isCommonCode: true },\n        twrUserLconv: { isCommonCode: true },\n        twrRegExpTest1252: { isCommonCode: true },\n        twrToUpper1252: { isCommonCode: true },\n        twrToLower1252: { isCommonCode: true },\n        twrStrcoll: { isCommonCode: true },\n        twrGetDtnames: { isCommonCode: true },\n    };\n    libSourcePath = new URL(import.meta.url).pathname;\n    cpTranslate = new twrCodePageToUnicodeCodePoint();\n    cpTranslate2 = new twrCodePageToUnicodeCodePoint();\n    constructor() {\n        // all library constructors should start with these two lines\n        super();\n        this.id = twrLibraryInstanceRegistry.register(this);\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////\n    twrCodePageToUnicodeCodePoint(callingMod, c, codePage) {\n        return this.cpTranslate2.convert(c, codePage);\n    }\n    twrUnicodeCodePointToCodePage(callingMod, outstr, cp, codePage) {\n        const ru8 = callingMod.wasmMem.stringToU8(String.fromCodePoint(cp), codePage);\n        callingMod.wasmMem.mem8.set(ru8, outstr);\n        return ru8.length;\n    }\n    twrUserLanguage(callingMod) {\n        // navigator.language works in JS main thread and Worker thread\n        return callingMod.wasmMem.putString(navigator.language, codePageASCII);\n    }\n    // checks if the character c, when converted to a string, is matched by the passed in regexp string \n    // utf-8 version not needed since this function is used for a single byte ('char'), \n    // and non-ascii range utf-8 single byte are not valid\n    twrRegExpTest1252(callingMod, regexpStrIdx, c) {\n        const regexpStr = callingMod.wasmMem.getString(regexpStrIdx);\n        const regexp = new RegExp(regexpStr, 'u');\n        const cstr = this.cpTranslate.decoder1252.decode(new Uint8Array([c]));\n        const r = regexp.test(cstr);\n        if (r)\n            return 1;\n        else\n            return 0;\n    }\n    // utf-8 version not needed since this function is used for a single byte ('char'), \n    // and non-ascii range utf-8 single byte are not valid\n    twrToLower1252(callingMod, c) {\n        const cstr = this.cpTranslate.decoder1252.decode(new Uint8Array([c]));\n        const regexp = new RegExp(\"^\\\\p{Letter}$\", 'u');\n        if (regexp.test(cstr)) {\n            const r = to1252(cstr.toLocaleLowerCase());\n            //console.log(\"twrToLower1252Impl: isLetter\", c, cstr, cstr.codePointAt(0), cstr.toLocaleLowerCase(), cstr.toLocaleLowerCase().codePointAt(0), r);\n            return r;\n        }\n        else {\n            //console.log(\"twrToLower1252Impl: isNOTLetter\", c, cstr, cstr.codePointAt(0));\n            return c;\n        }\n    }\n    //utf-8 version not needed since this function is used for a single byte ('char'), \n    // and non-ascii range utf-8 single byte are not valid\n    twrToUpper1252(callingMod, c) {\n        const cstr = this.cpTranslate.decoder1252.decode(new Uint8Array([c]));\n        if (cstr.codePointAt(0) == 402)\n            return c; // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is ƒ\n        if (cstr.codePointAt(0) == 181)\n            return c; // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is µ\n        if (cstr.codePointAt(0) == 223)\n            return c; // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is ß'\n        if (cstr == \"µ\")\n            return c; // upper case version doesn't fit in 1252\n        if (cstr == 'ƒ')\n            return c; // upper case version doesn't fit in 1252\n        if (cstr == 'ß')\n            return c; // toLocaleUpperCase() will convert beta to SS\n        const regexp = new RegExp(\"^\\\\p{Letter}$\", 'u');\n        if (regexp.test(cstr)) {\n            return to1252(cstr.toLocaleUpperCase());\n        }\n        else {\n            return c;\n        }\n    }\n    twrStrcoll(callingMod, lhs, rhs, codePage) {\n        const lhStr = callingMod.wasmMem.getString(lhs, undefined, codePage);\n        const rhStr = callingMod.wasmMem.getString(rhs, undefined, codePage);\n        // c strcmp(): A positive integer if str1 is greater than str2.\n        // 1 if string 1 (lh) comes after string 2 (rh)\n        const collator = new Intl.Collator();\n        const r = collator.compare(lhStr, rhStr);\n        return r;\n    }\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    //struct tm {\n    //\tint\ttm_sec;\t\t/* seconds after the minute [0-60] */\n    //\tint\ttm_min;\t\t/* minutes after the hour [0-59] */\n    //\tint\ttm_hour;\t\t/* hours since midnight [0-23] */\n    //\tint\ttm_mday;\t\t/* day of the month [1-31] */\n    //\tint\ttm_mon;\t\t/* months since January [0-11] */\n    //\tint\ttm_year;\t\t/* years since 1900 */\n    //\tint\ttm_wday;\t\t/* days since Sunday [0-6] */\n    //\tint\ttm_yday;\t\t/* days since January 1 [0-365] */\n    //\tint\ttm_isdst;\t/* Daylight Saving Time flag */\n    //\tlong\ttm_gmtoff;\t/* offset from UTC in seconds */\n    //\tchar\t*tm_zone;\t/* timezone abbreviation */\n    //};\n    // fill in struct tm\n    // epcohSecs as 32bit int will overflow January 19, 2038. \n    twrTimeTmLocal(callingMod, tmIdx, epochSecs) {\n        const d = new Date(epochSecs * 1000);\n        callingMod.wasmMem.setLong(tmIdx, d.getSeconds());\n        callingMod.wasmMem.setLong(tmIdx + 4, d.getMinutes());\n        callingMod.wasmMem.setLong(tmIdx + 8, d.getHours());\n        callingMod.wasmMem.setLong(tmIdx + 12, d.getDate());\n        callingMod.wasmMem.setLong(tmIdx + 16, d.getMonth());\n        callingMod.wasmMem.setLong(tmIdx + 20, d.getFullYear() - 1900);\n        callingMod.wasmMem.setLong(tmIdx + 24, d.getDay());\n        callingMod.wasmMem.setLong(tmIdx + 28, this.getDayOfYear(d));\n        callingMod.wasmMem.setLong(tmIdx + 32, this.isDst());\n        callingMod.wasmMem.setLong(tmIdx + 36, -d.getTimezoneOffset() * 60);\n        callingMod.wasmMem.setLong(tmIdx + 40, callingMod.wasmMem.putString(this.getTZ(d), codePageASCII));\n    }\n    getDayOfYear(date) {\n        const start = new Date(date.getFullYear(), 0, 1);\n        const diff = date.getTime() - start.getTime(); // Difference in milliseconds\n        const oneDay = 1000 * 60 * 60 * 24; // Number of milliseconds in one day\n        const day = Math.floor(diff / oneDay);\n        return day;\n    }\n    isDst() {\n        const timeString = new Date().toLocaleTimeString('en-US', { timeZoneName: 'long' });\n        if (timeString.includes('Daylight')) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    getTZ(date) {\n        const timeZone = date.toLocaleTimeString('en-US', { timeZoneName: 'short' }).split(' ').pop();\n        return timeZone ? timeZone : \"UTC\";\n    }\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    setAndPutString(mem, idx, sin, codePage) {\n        const stridx = mem.putString(sin, codePage);\n        mem.setLong(idx, stridx);\n    }\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    //struct lconv {\n    //\tchar\t*decimal_point;   \t\t0\n    //\tchar\t*thousands_sep;\t\t\t4\n    //\tchar\t*grouping;\t\t\t\t\t8\n    //\tchar\t*int_curr_symbol;\t\t\t12\n    //\tchar\t*currency_symbol;\t\t\t16\n    //\tchar\t*mon_decimal_point;\t\t20\n    //\tchar\t*mon_thousands_sep;\t\t24\n    //\tchar\t*mon_grouping;\t\t\t\t28\n    //\tchar\t*positive_sign;\t\t\t32\n    //\tchar\t*negative_sign;\t\t\t36\n    //\tchar\tint_frac_digits;\t\t\t40\n    //\tchar\tfrac_digits;\t\t\t\t44\n    //\tchar\tp_cs_precedes;\t\t\t\t48\n    //\tchar\tp_sep_by_space;\t\t\t52\n    //\tchar\tn_cs_precedes;\t\t\t\t56\n    //\tchar\tn_sep_by_space;\t\t\t60\n    //\tchar\tp_sign_posn;\t\t\t\t64\n    //\tchar\tn_sign_posn;\t\t\t\t68\n    //};\n    twrUserLconv(callingMod, lconvIdx, codePage) {\n        const locDec = this.getLocaleDecimalPoint();\n        const locSep = this.getLocaleThousandsSeparator();\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 0, locDec, codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 4, locSep, codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 20, locDec, codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 24, locSep, codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 24, locSep, codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 24, locSep, codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 32, \"+\", codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 36, \"-\", codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 12, this.getLocalCurrencySymbol(), codePage);\n        this.setAndPutString(callingMod.wasmMem, lconvIdx + 16, this.getLocalCurrencySymbol(), codePage);\n    }\n    getLocaleDecimalPoint() {\n        const formatter = new Intl.NumberFormat();\n        //console.log(\"dec resolvedOptions\", formatter.resolvedOptions());\n        // Format a test number to find out the decimal point.\n        const formattedNumber = formatter.format(1.1);\n        //console.log(\"dec formattedNumber\", formattedNumber);\n        // Find the character between the numeric parts.\n        const decimalPoint = formattedNumber.replace(/[0-9]/g, '').charAt(0);\n        return decimalPoint;\n    }\n    getLocaleThousandsSeparator() {\n        const formatter = new Intl.NumberFormat(undefined, {\n            minimumFractionDigits: 0 // Ensure no decimal part interferes\n        });\n        // Format a test number to include a thousands separator.\n        const formattedNumber = formatter.format(1000);\n        //console.log(\"sep formattedNumber\", formattedNumber);\n        // Extract the thousands separator by removing numeric characters and possible decimal points.\n        // This may need adjustment depending on whether other characters are present.\n        let thousandsSeparator = formattedNumber.replace(/[0-9]/g, '').charAt(0); // Assumes separator is the first character.\n        //console.log(\"sep code\",  thousandsSeparator.codePointAt(0));\n        return thousandsSeparator;\n    }\n    // this doesn't work, localeCurrency is not correct\n    getLocaleCurrencyDecimalPoint() {\n        // Create an initial NumberFormat object to detect the locale's currency\n        const tempFormatter = new Intl.NumberFormat(undefined, { style: 'currency', currency: 'USD' });\n        const localeCurrency = tempFormatter.resolvedOptions().currency;\n        const formatter = new Intl.NumberFormat(undefined, {\n            style: 'currency',\n            currency: localeCurrency\n        });\n        // Format a test number to find out the decimal point.\n        const formattedNumber = formatter.format(1.1);\n        // Find the character between the numeric parts.\n        // char(0) is the currency symbol\n        const decimalPoint = formattedNumber.replace(/[0-9]/g, '').charAt(1);\n        return decimalPoint;\n    }\n    getLocalCurrencySymbol() {\n        switch (navigator.language) {\n            case \"en-US\":\n            case \"en-CA\":\n            case \"fr-CA\":\n            case \"en-AU\":\n            case \"es-MX\":\n            case \"es-AR\":\n            case \"es-CL\":\n            case \"es-CO\":\n            case \"es-EC\":\n            case \"en-GY\":\n            case \"nl-SR\":\n            case \"es-UY\":\n            case \"en-BZ\":\n            case \"es-SV\":\n            case \"es-PA\":\n                return \"$\";\n            case \"es-BO\":\n            case \"es-VE\":\n                return \"Bs.\";\n            case \"es-PY\":\n                return \"₲\";\n            case \"es-PE\":\n                return \"S/\";\n            case \"es-CR\":\n                return \"₡\";\n            case \"es-GT\":\n                return \"Q\";\n            case \"es-HN\":\n                return \"L\";\n            case \"es-NI\":\n                return \"C$\";\n            case \"en-GB\":\n                return \"£\";\n            case \"en-IE\":\n            case \"de-DE\":\n            case \"fr-FR\":\n            case \"de-AT\":\n            case \"nl-BE\":\n            case \"fr-BE\":\n            case \"el-CY\":\n            case \"et-EE\":\n            case \"fi-FI\":\n            case \"sv-FI\":\n            case \"el-GR\":\n            case \"it-IT\":\n            case \"lv-LV\":\n            case \"lt-LT\":\n            case \"fr-LU\":\n            case \"de-LU\":\n            case \"lb-LU\":\n            case \"mt-MT\":\n            case \"nl-NL\":\n            case \"pt-PT\":\n            case \"sk-SK\":\n            case \"sl-SI\":\n            case \"es-ES\":\n                return \"€\";\n            case \"ja-JP\":\n                return \"¥\";\n            case \"zh-CN\":\n                return \"¥\";\n            case \"de-CH\":\n            case \"fr-CH\":\n            case \"it-CH\":\n                return \"CHF\";\n            case \"sv-SE\":\n            case \"da-DK\":\n            case \"nb-NO\":\n                return \"kr\";\n            case \"ru-RU\":\n                return \"₽\";\n            case \"ko-KR\":\n                return \"₩\";\n            case \"en-IN\":\n                return \"₹\";\n            case \"pt-BR\":\n                return \"R$\";\n            case \"he-IL\":\n                return \"₪\";\n            case \"tr-TR\":\n                return \"₺\";\n            default:\n                return \"\";\n        }\n    }\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /*\n    struct locale_dtnames {\n       const char* day[7];\n       const char* abday[7];\n       const char* month[12];\n       const char* abmonth[12];\n       const char* ampm[2];\n    };\n    */\n    twrGetDtnames(callingMod, codePage) {\n        const malloc = callingMod.wasmMem.malloc;\n        const dtnamesStructIdx = malloc(40 * 4);\n        for (let i = 0; i < 7; i++)\n            this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx + i * 4, this.getLocalizedDayName(i, 'long'), codePage);\n        for (let i = 0; i < 7; i++)\n            this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx + (i + 7) * 4, this.getLocalizedDayName(i, 'short'), codePage);\n        for (let i = 0; i < 12; i++)\n            this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx + (i + 14) * 4, this.getLocalizedMonthNames(i, 'long'), codePage);\n        for (let i = 0; i < 12; i++)\n            this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx + (i + 14 + 12) * 4, this.getLocalizedMonthNames(i, 'short'), codePage);\n        this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx + (0 + 14 + 24) * 4, this.getLocalizedAM(), codePage);\n        this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx + (1 + 14 + 24) * 4, this.getLocalizedPM(), codePage);\n        return dtnamesStructIdx;\n    }\n    getLocalizedDayName(n, weekdayType) {\n        // Create a Date object for the desired day of the week\n        const date = new Date();\n        date.setDate(date.getDate() - date.getDay() + n);\n        // Create an Intl.DateTimeFormat object with the desired locale and options\n        const formatter = new Intl.DateTimeFormat(undefined, { weekday: weekdayType });\n        // Format the date to get the full day name\n        return formatter.format(date);\n    }\n    getLocalizedMonthNames(n, monthType) {\n        const formatter = new Intl.DateTimeFormat(undefined, { month: monthType });\n        const date = new Date(2000, n, 1);\n        return formatter.format(date);\n    }\n    getLocalizedAM() {\n        // Create a Date object for a time in the morning\n        const morningDate = new Date(2000, 0, 1, 9, 0, 0);\n        // Create an Intl.DateTimeFormat object with the desired locale and options\n        const formatter = new Intl.DateTimeFormat(undefined, {\n            hour: 'numeric',\n            hour12: true\n        });\n        // Format the date and get the parts\n        const formattedParts = formatter.formatToParts(morningDate);\n        // Find the part of the formatted string that corresponds to the day period (AM/PM)\n        const dayPeriodPart = formattedParts.find(part => part.type === 'dayPeriod');\n        return dayPeriodPart ? dayPeriodPart.value : '';\n    }\n    getLocalizedPM() {\n        // Create a Date object for a time in the afternoon\n        const afternoonDate = new Date(2000, 0, 1, 15, 0, 0);\n        // Create an Intl.DateTimeFormat object with the desired locale and options\n        const formatter = new Intl.DateTimeFormat(undefined, {\n            hour: 'numeric',\n            hour12: true\n        });\n        // Format the date and get the parts\n        const formattedParts = formatter.formatToParts(afternoonDate);\n        // Find the part of the formatted string that corresponds to the day period (AM/PM)\n        const dayPeriodPart = formattedParts.find(part => part.type === 'dayPeriod');\n        return dayPeriodPart ? dayPeriodPart.value : '';\n    }\n}\n///////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\nexport function to1252(instr) {\n    if (instr.codePointAt(0) == 8239)\n        return 32; // turn narrow-no-break-space into space\n    // this first switch statment fixes what appears to be a bug in safari 15.6.1 (17613.3.9.1.16) (comparisons to the character string fail)\n    let cp = instr.codePointAt(0) || 0;\n    switch (cp) {\n        case 338: return 0x8C;\n        case 339: return 0x9C;\n        case 352: return 0x8A;\n        case 353: return 0x9A;\n        case 376: return 0x9F;\n        case 381: return 0x8E;\n        case 382: return 0x9E;\n        case 402: return 0x83;\n        case 710: return 0x88;\n    }\n    switch (instr.normalize()) {\n        case '€': return 0x80;\n        case '‚': return 0x82;\n        case 'ƒ': return 0x83;\n        case '„': return 0x84;\n        case '…': return 0x85;\n        case '†': return 0x86;\n        case '‡': return 0x87;\n        case 'ˆ': return 0x88;\n        case '‰': return 0x89;\n        case 'Š': return 0x8A;\n        case '‹': return 0x8B;\n        case 'Œ': return 0x8C;\n        case 'Ž': return 0x8E;\n        case '‘': return 0x91;\n        case '’': return 0x92;\n        case '“': return 0x93;\n        case '”': return 0x94;\n        case '•': return 0x95;\n        case '–': return 0x96;\n        case '—': return 0x97;\n        case '˜': return 0x98;\n        case '™': return 0x99;\n        case 'š': return 0x9A;\n        case '›': return 0x9B;\n        case 'œ': return 0x9C;\n        case 'ž': return 0x9E;\n        case 'Ÿ': return 0x9F;\n    }\n    if (cp > 255) {\n        console.log(\"twr-wasm.to1252(): unable to convert: \", instr, cp);\n        cp = 0;\n    }\n    return cp;\n}\n///////////////////////////////////////////////////////////////////////////////////////////////\nexport function toASCII(instr) {\n    if (instr == 'ƒ')\n        return 102; // lowercase 'f'\n    if (instr.codePointAt(0) == 8239)\n        return 32; // turn narrow-no-break-space into space\n    let cp = instr.codePointAt(0) || 0;\n    if (cp > 127)\n        return 63; // ASCII for \"?\"\n    return cp;\n}\n///////////////////////////////////////////////////////////////////////////////////////////////\nexport class twrCodePageToUnicodeCodePoint {\n    decoderUTF8 = new TextDecoder('utf-8');\n    decoder1252 = new TextDecoder('windows-1252');\n    convert(c, codePage) {\n        let outstr;\n        if (codePage == codePageUTF8) {\n            outstr = this.decoderUTF8.decode(new Uint8Array([c]), { stream: true });\n        }\n        else if (codePage == codePage1252) {\n            outstr = this.decoder1252.decode(new Uint8Array([c]));\n        }\n        else if (codePage == codePageASCII) {\n            if (c > 127)\n                outstr = \"\";\n            else\n                outstr = String.fromCharCode(c);\n        }\n        else if (codePage == codePageUTF32) {\n            outstr = String.fromCodePoint(c);\n        }\n        else {\n            throw new Error(\"unsupported CodePage: \" + codePage);\n        }\n        return outstr.codePointAt(0) || 0;\n    }\n}\n//# sourceMappingURL=twrliblocale.js.map","import {twrLibrary, TLibImports, twrLibraryInstanceRegistry} from \"./twrlibrary.js\";\nimport {IWasmMemory} from \"./twrwasmmem.js\";\nimport {IWasmModule} from \"./twrmod.js\"\nimport {twrWasmBase} from \"./twrwasmbase.js\"\n\n///////////////////////////////////////////////////////////////////////////////////////\n\n// these match C #defines in locale.h\nexport const codePageASCII=0;\nexport const codePage1252=1252;\nexport const codePageUTF8=65001;\nexport const codePageUTF32=12000;\n\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n\nexport default class twrLibLocale extends twrLibrary {\n   id:number;\n   imports:TLibImports = {\n      twrUnicodeCodePointToCodePage:{isCommonCode: true},\n      twrCodePageToUnicodeCodePoint:{isCommonCode: true},\n      twrUserLanguage:{isCommonCode: true},\n      twrTimeTmLocal:{isCommonCode: true},\n      twrUserLconv:{isCommonCode: true},\n      twrRegExpTest1252:{isCommonCode: true},\n      twrToUpper1252:{isCommonCode: true},\n      twrToLower1252:{isCommonCode: true},\n      twrStrcoll:{isCommonCode: true},\n      twrGetDtnames:{isCommonCode: true},\n   }\n\n   libSourcePath = new URL(import.meta.url).pathname;\n\n   cpTranslate = new twrCodePageToUnicodeCodePoint();\n   cpTranslate2 = new twrCodePageToUnicodeCodePoint();\n\n   constructor() {\n      // all library constructors should start with these two lines\n      super();\n      this.id=twrLibraryInstanceRegistry.register(this);\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////\n\n   twrCodePageToUnicodeCodePoint(callingMod:IWasmModule|twrWasmBase, c:number, codePage:number) {\n      return this.cpTranslate2.convert(c, codePage);\n   }\n   \n   twrUnicodeCodePointToCodePage(callingMod:IWasmModule|twrWasmBase, outstr:number, cp:number, codePage:number) {\n      const ru8=callingMod.wasmMem.stringToU8(String.fromCodePoint(cp), codePage);\n      callingMod.wasmMem.mem8.set(ru8, outstr);\n      return ru8.length;\n   }\n\n   twrUserLanguage(callingMod:IWasmModule|twrWasmBase,) {\n      // navigator.language works in JS main thread and Worker thread\n      return callingMod.wasmMem.putString(navigator.language, codePageASCII);\n\n   }\n\n   // checks if the character c, when converted to a string, is matched by the passed in regexp string \n   // utf-8 version not needed since this function is used for a single byte ('char'), \n   // and non-ascii range utf-8 single byte are not valid\n   twrRegExpTest1252(callingMod:IWasmModule|twrWasmBase, regexpStrIdx:number, c:number) {\n\n      const regexpStr=callingMod.wasmMem.getString(regexpStrIdx);\n      const regexp=new RegExp(regexpStr, 'u');\n      const cstr:string = this.cpTranslate.decoder1252.decode(new Uint8Array([c]));\n      const r=regexp.test(cstr);\n      if (r) return 1; else return 0;\n\n   }\n\n   // utf-8 version not needed since this function is used for a single byte ('char'), \n   // and non-ascii range utf-8 single byte are not valid\n   twrToLower1252(callingMod:IWasmModule|twrWasmBase, c:number) {\n\n      const cstr:string = this.cpTranslate.decoder1252.decode(new Uint8Array([c]));\n      const regexp=new RegExp(\"^\\\\p{Letter}$\", 'u');\n      if (regexp.test(cstr)) {\n         const r = to1252(cstr.toLocaleLowerCase());\n         //console.log(\"twrToLower1252Impl: isLetter\", c, cstr, cstr.codePointAt(0), cstr.toLocaleLowerCase(), cstr.toLocaleLowerCase().codePointAt(0), r);\n         return r;\n      }\n      else {\n         //console.log(\"twrToLower1252Impl: isNOTLetter\", c, cstr, cstr.codePointAt(0));\n         return c;\n      }\n\n   }\n\n   //utf-8 version not needed since this function is used for a single byte ('char'), \n   // and non-ascii range utf-8 single byte are not valid\n   twrToUpper1252(callingMod:IWasmModule|twrWasmBase, c:number) {\n\n      const cstr:string = this.cpTranslate.decoder1252.decode(new Uint8Array([c]));\n\n      if (cstr.codePointAt(0)==402) return c;  // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is ƒ\n      if (cstr.codePointAt(0)==181) return c;  // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is µ\n      if (cstr.codePointAt(0)==223) return c;  // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is ß'\n      \n      if (cstr==\"µ\") return c;  // upper case version doesn't fit in 1252\n      if (cstr=='ƒ') return c;  // upper case version doesn't fit in 1252\n      if (cstr=='ß') return c;  // toLocaleUpperCase() will convert beta to SS\n\n      const regexp=new RegExp(\"^\\\\p{Letter}$\", 'u');\n      if (regexp.test(cstr)) {\n         return to1252(cstr.toLocaleUpperCase());\n      }\n      else {\n         return c;\n      }\n\n   }\n\n   twrStrcoll(callingMod:IWasmModule|twrWasmBase, lhs:number, rhs:number, codePage:number) {\n      const lhStr=callingMod.wasmMem.getString(lhs, undefined, codePage);\n      const rhStr=callingMod.wasmMem.getString(rhs, undefined, codePage);\n\n      // c strcmp(): A positive integer if str1 is greater than str2.\n      // 1 if string 1 (lh) comes after string 2 (rh)\n      const collator = new Intl.Collator();\n      const r = collator.compare(lhStr, rhStr);\n\n      return r;\n   }\n\n   /////////////////////////////////////////////////////////////////////////////////////////////\n   /////////////////////////////////////////////////////////////////////////////////////////////\n   /////////////////////////////////////////////////////////////////////////////////////////////\n\n   //struct tm {\n   //\tint\ttm_sec;\t\t/* seconds after the minute [0-60] */\n   //\tint\ttm_min;\t\t/* minutes after the hour [0-59] */\n   //\tint\ttm_hour;\t\t/* hours since midnight [0-23] */\n   //\tint\ttm_mday;\t\t/* day of the month [1-31] */\n   //\tint\ttm_mon;\t\t/* months since January [0-11] */\n   //\tint\ttm_year;\t\t/* years since 1900 */\n   //\tint\ttm_wday;\t\t/* days since Sunday [0-6] */\n   //\tint\ttm_yday;\t\t/* days since January 1 [0-365] */\n   //\tint\ttm_isdst;\t/* Daylight Saving Time flag */\n   //\tlong\ttm_gmtoff;\t/* offset from UTC in seconds */\n   //\tchar\t*tm_zone;\t/* timezone abbreviation */\n   //};\n\n   // fill in struct tm\n   // epcohSecs as 32bit int will overflow January 19, 2038. \n   twrTimeTmLocal(callingMod:IWasmModule|twrWasmBase, tmIdx:number, epochSecs:number) {\n\n      const d=new Date(epochSecs*1000);\n      callingMod.wasmMem.setLong(tmIdx, d.getSeconds());\n      callingMod.wasmMem.setLong(tmIdx+4, d.getMinutes());\n      callingMod.wasmMem.setLong(tmIdx+8, d.getHours());\n      callingMod.wasmMem.setLong(tmIdx+12, d.getDate());\n      callingMod.wasmMem.setLong(tmIdx+16, d.getMonth());\n      callingMod.wasmMem.setLong(tmIdx+20, d.getFullYear()-1900);\n      callingMod.wasmMem.setLong(tmIdx+24, d.getDay());\n      callingMod.wasmMem.setLong(tmIdx+28, this.getDayOfYear(d));\n      callingMod.wasmMem.setLong(tmIdx+32, this.isDst());\n      callingMod.wasmMem.setLong(tmIdx+36, \t-d.getTimezoneOffset()*60);\n      callingMod.wasmMem.setLong(tmIdx+40, \tcallingMod.wasmMem.putString(this.getTZ(d), codePageASCII)); \n\n   }\n\n   private getDayOfYear(date:Date) {\n      const start = new Date(date.getFullYear(), 0, 1); \n      const diff = date.getTime() - start.getTime(); // Difference in milliseconds\n      const oneDay = 1000 * 60 * 60 * 24; // Number of milliseconds in one day\n      const day = Math.floor(diff / oneDay);\n      return day;\n   }\n\n   private isDst() {\n      const timeString = new Date().toLocaleTimeString('en-US', { timeZoneName: 'long' });\n      if (timeString.includes('Daylight')) {\n         return 1;\n      } else {\n         return 0;\n      }\n   }\n\n   private  getTZ(date:Date) {\n      const timeZone = date.toLocaleTimeString('en-US', {timeZoneName: 'short'}).split(' ').pop();\n      return timeZone?timeZone:\"UTC\";\n   }\n\n   /////////////////////////////////////////////////////////////////////////////////////////////\n   /////////////////////////////////////////////////////////////////////////////////////////////\n   /////////////////////////////////////////////////////////////////////////////////////////////\n\n   private setAndPutString(mem: IWasmMemory, idx:number, sin:string,  codePage:number) {\n      const stridx=mem.putString(sin, codePage);\n      mem.setLong(idx, stridx);\n   }\n\n   /////////////////////////////////////////////////////////////////////////////////////////////\n   /////////////////////////////////////////////////////////////////////////////////////////////\n   /////////////////////////////////////////////////////////////////////////////////////////////\n\n   //struct lconv {\n   //\tchar\t*decimal_point;   \t\t0\n   //\tchar\t*thousands_sep;\t\t\t4\n   //\tchar\t*grouping;\t\t\t\t\t8\n   //\tchar\t*int_curr_symbol;\t\t\t12\n   //\tchar\t*currency_symbol;\t\t\t16\n   //\tchar\t*mon_decimal_point;\t\t20\n   //\tchar\t*mon_thousands_sep;\t\t24\n   //\tchar\t*mon_grouping;\t\t\t\t28\n   //\tchar\t*positive_sign;\t\t\t32\n   //\tchar\t*negative_sign;\t\t\t36\n   //\tchar\tint_frac_digits;\t\t\t40\n   //\tchar\tfrac_digits;\t\t\t\t44\n   //\tchar\tp_cs_precedes;\t\t\t\t48\n   //\tchar\tp_sep_by_space;\t\t\t52\n   //\tchar\tn_cs_precedes;\t\t\t\t56\n   //\tchar\tn_sep_by_space;\t\t\t60\n   //\tchar\tp_sign_posn;\t\t\t\t64\n   //\tchar\tn_sign_posn;\t\t\t\t68\n   //};\n\n   twrUserLconv(callingMod:IWasmModule|twrWasmBase, lconvIdx:number, codePage:number) {\n      const locDec=this.getLocaleDecimalPoint();\n      const locSep=this.getLocaleThousandsSeparator();\n      this.setAndPutString(callingMod.wasmMem, lconvIdx+0, locDec, codePage);\n      this.setAndPutString(callingMod.wasmMem, lconvIdx+4, locSep, codePage);\n      this.setAndPutString(callingMod.wasmMem, lconvIdx+20, locDec, codePage);\n      this.setAndPutString(callingMod.wasmMem, lconvIdx+24, locSep, codePage);\n      this.setAndPutString(callingMod.wasmMem, lconvIdx+24, locSep, codePage);\n      this.setAndPutString(callingMod.wasmMem, lconvIdx+24, locSep, codePage);\n      this.setAndPutString(callingMod.wasmMem, lconvIdx+32, \"+\", codePage);\n      this.setAndPutString(callingMod.wasmMem, lconvIdx+36, \"-\", codePage);\n      this.setAndPutString(callingMod.wasmMem, lconvIdx+12, this.getLocalCurrencySymbol(), codePage);\n      this.setAndPutString(callingMod.wasmMem, lconvIdx+16, this.getLocalCurrencySymbol(), codePage);\n   }\n\n   private getLocaleDecimalPoint() {\n      const formatter = new Intl.NumberFormat();\n\n      //console.log(\"dec resolvedOptions\", formatter.resolvedOptions());\n\n      // Format a test number to find out the decimal point.\n      const formattedNumber = formatter.format(1.1);\n      //console.log(\"dec formattedNumber\", formattedNumber);\n\n      // Find the character between the numeric parts.\n      const decimalPoint = formattedNumber.replace(/[0-9]/g, '').charAt(0);\n\n      return decimalPoint;\n   }\n\n   private getLocaleThousandsSeparator() {\n      const formatter = new Intl.NumberFormat(undefined, {\n         minimumFractionDigits: 0  // Ensure no decimal part interferes\n      });\n\n      // Format a test number to include a thousands separator.\n      const formattedNumber = formatter.format(1000);\n      //console.log(\"sep formattedNumber\", formattedNumber);\n\n      // Extract the thousands separator by removing numeric characters and possible decimal points.\n      // This may need adjustment depending on whether other characters are present.\n      let thousandsSeparator = formattedNumber.replace(/[0-9]/g, '').charAt(0);  // Assumes separator is the first character.\n      //console.log(\"sep code\",  thousandsSeparator.codePointAt(0));\n      return thousandsSeparator;\n   }\n\n   // this doesn't work, localeCurrency is not correct\n   private getLocaleCurrencyDecimalPoint() {\n      // Create an initial NumberFormat object to detect the locale's currency\n      const tempFormatter = new Intl.NumberFormat(undefined, { style: 'currency', currency: 'USD' });\n      const localeCurrency = tempFormatter.resolvedOptions().currency;\n      const formatter = new Intl.NumberFormat(undefined, {\n         style: 'currency',\n         currency: localeCurrency\n   });\n      // Format a test number to find out the decimal point.\n      const formattedNumber = formatter.format(1.1);\n\n      // Find the character between the numeric parts.\n      // char(0) is the currency symbol\n      const decimalPoint = formattedNumber.replace(/[0-9]/g, '').charAt(1);\n\n      return decimalPoint;\n   }\n\n   private getLocalCurrencySymbol() {\n      switch (navigator.language) {\n         case \"en-US\":\n         case \"en-CA\":\n         case \"fr-CA\":\n         case \"en-AU\":\n         case \"es-MX\":\n         case \"es-AR\":\n         case \"es-CL\":\n         case \"es-CO\":\n         case \"es-EC\":\n         case \"en-GY\":\n         case \"nl-SR\":\n         case \"es-UY\":\n         case \"en-BZ\":\n         case \"es-SV\":\n         case \"es-PA\":\n            return \"$\";\n\n         case \"es-BO\":\n         case \"es-VE\":\n            return \"Bs.\";\n\n         case \"es-PY\":\n            return \"₲\";\n\n         case \"es-PE\":\n            return \"S/\";\n\n         case \"es-CR\":\n            return \"₡\";\n\n         case \"es-GT\":\n            return \"Q\";\t\t\n               \n         case \"es-HN\":\n            return \"L\";\n            \n         case \"es-NI\":\n            return \"C$\";\n\n         case \"en-GB\":\n            return \"£\"\n\n         case \"en-IE\":\n         case \"de-DE\":\n         case \"fr-FR\":\n         case \"de-AT\":\n         case \"nl-BE\":\n         case \"fr-BE\":\n         case \"el-CY\":\n         case \"et-EE\":\n         case \"fi-FI\":\n         case \"sv-FI\":\n         case \"el-GR\":\n         case \"it-IT\":\n         case \"lv-LV\":\n         case \"lt-LT\":\n         case \"fr-LU\":\n         case \"de-LU\":\n         case \"lb-LU\":\n         case \"mt-MT\":\n         case \"nl-NL\":\n         case \"pt-PT\":\n         case \"sk-SK\":\n         case \"sl-SI\":\n         case \"es-ES\":\n            return \"€\"\n\n         case \"ja-JP\":\n            return \"¥\"\n\n         case \"zh-CN\":\n            return \"¥\"\n\n         case \"de-CH\":\n         case \"fr-CH\":\n         case \"it-CH\":\n            return \"CHF\"\n\n         case \"sv-SE\":\n         case \"da-DK\":\n         case \"nb-NO\":\n            return \"kr\"\n\n         case \"ru-RU\":\n            return \"₽\"\n\n         case \"ko-KR\":\n            return \"₩\"\n\n         case \"en-IN\":\n            return \"₹\"\n\n         case \"pt-BR\":\n         return \"R$\"\n\n         case \"he-IL\":\n         return \"₪\"\n\n         case \"tr-TR\":\n         return \"₺\"\n\n         default:\n            return \"\";\n      }\n   }\n\n\n   /////////////////////////////////////////////////////////////////////////////////////////////\n   /////////////////////////////////////////////////////////////////////////////////////////////\n   /////////////////////////////////////////////////////////////////////////////////////////////\n\n   /*\n   struct locale_dtnames {\n      const char* day[7];\n      const char* abday[7];\n      const char* month[12];\n      const char* abmonth[12];\n      const char* ampm[2];\n   };\n   */\n\n   twrGetDtnames(callingMod:IWasmModule|twrWasmBase, codePage:number) {\n\n      const malloc=callingMod.wasmMem.malloc;\n      const dtnamesStructIdx:number=malloc(40*4);\n      for (let i=0; i<7; i++)\n         this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx+i*4, this.getLocalizedDayName(i, 'long'), codePage);\n\n      for (let i=0; i<7; i++)\n         this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx+(i+7)*4, this.getLocalizedDayName(i, 'short'), codePage);\n\n      for (let i=0; i<12; i++)\n         this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx+(i+14)*4, this.getLocalizedMonthNames(i, 'long'), codePage);\n\n      for (let i=0; i<12; i++)\n         this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx+(i+14+12)*4, this.getLocalizedMonthNames(i, 'short'), codePage);\n\n      this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx+(0+14+24)*4, this.getLocalizedAM(), codePage);\n      this.setAndPutString(callingMod.wasmMem, dtnamesStructIdx+(1+14+24)*4, this.getLocalizedPM(), codePage);\n\n      return dtnamesStructIdx;\n   }\n\n   private getLocalizedDayName(n:number, weekdayType:'long'|'short') {\n      // Create a Date object for the desired day of the week\n      const date = new Date();\n      date.setDate(date.getDate() - date.getDay() + n);\n      \n      // Create an Intl.DateTimeFormat object with the desired locale and options\n      const formatter = new Intl.DateTimeFormat(undefined, { weekday: weekdayType });\n      \n      // Format the date to get the full day name\n      return formatter.format(date);\n   }\n\n   private getLocalizedMonthNames(n:number, monthType:'long'|'short') {\n      const formatter = new Intl.DateTimeFormat(undefined, { month: monthType });\n      const date = new Date(2000, n, 1);\n      return formatter.format(date);\n   }\n\n   private getLocalizedAM() {\n      // Create a Date object for a time in the morning\n      const morningDate = new Date(2000, 0, 1, 9, 0, 0);\n\n      // Create an Intl.DateTimeFormat object with the desired locale and options\n      const formatter = new Intl.DateTimeFormat(undefined, {\n         hour: 'numeric',\n         hour12: true\n      });\n\n      // Format the date and get the parts\n      const formattedParts = formatter.formatToParts(morningDate);\n\n      // Find the part of the formatted string that corresponds to the day period (AM/PM)\n      const dayPeriodPart = formattedParts.find(part => part.type === 'dayPeriod');\n\n      return dayPeriodPart ? dayPeriodPart.value : '';\n   }\n\n   private getLocalizedPM() {\n      // Create a Date object for a time in the afternoon\n      const afternoonDate = new Date(2000, 0, 1, 15, 0, 0);\n\n      // Create an Intl.DateTimeFormat object with the desired locale and options\n      const formatter = new Intl.DateTimeFormat(undefined, {\n         hour: 'numeric',\n         hour12: true\n      });\n\n      // Format the date and get the parts\n      const formattedParts = formatter.formatToParts(afternoonDate);\n\n      // Find the part of the formatted string that corresponds to the day period (AM/PM)\n      const dayPeriodPart = formattedParts.find(part => part.type === 'dayPeriod');\n\n      return dayPeriodPart ? dayPeriodPart.value : '';\n   }\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\n\n\nexport function to1252(instr:string) {\n\n   if (instr.codePointAt(0)==8239) return 32;  // turn narrow-no-break-space into space\n\n\n   // this first switch statment fixes what appears to be a bug in safari 15.6.1 (17613.3.9.1.16) (comparisons to the character string fail)\n   let cp=instr.codePointAt(0) || 0;\n\n   switch(cp) {\n      case 338: return 0x8C;\n      case 339: return 0x9C;\n      case 352: return 0x8A;\n      case 353: return 0x9A;\n      case 376: return 0x9F;\n      case 381: return 0x8E;\n      case 382: return 0x9E;\n      case 402: return 0x83;\n      case 710: return 0x88;\n   }\n\n   switch (instr.normalize()) {\n      case '€': return 0x80;\n      case '‚': return 0x82;\n      case 'ƒ': return 0x83;\n      case '„': return 0x84;\n      case '…': return 0x85;\n      case '†': return 0x86;\n      case '‡': return 0x87;\n      case 'ˆ': return 0x88;\n      case '‰': return 0x89;\n      case 'Š': return 0x8A; \n      case '‹': return 0x8B;\n      case 'Œ': return 0x8C;\n      case 'Ž': return 0x8E;\n      case '‘': return 0x91;\n      case '’': return 0x92;\n      case '“': return 0x93;\n      case '”': return 0x94;\n      case '•': return 0x95;\n      case '–': return 0x96;\n      case '—': return 0x97;\n      case '˜': return 0x98;\n      case '™': return 0x99;\n      case 'š': return 0x9A;\n      case '›': return 0x9B;\n      case 'œ': return 0x9C;\n      case 'ž': return 0x9E;\n      case 'Ÿ': return 0x9F;\n   }\n   \n   if (cp>255) {\n      console.log(\"twr-wasm.to1252(): unable to convert: \", instr, cp);\n      cp=0;\n   }\n\n   return cp;\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////\n\n\nexport function toASCII(instr:string) {\n   if (instr=='ƒ') return 102; // lowercase 'f'\n   if (instr.codePointAt(0)==8239) return 32;  // turn narrow-no-break-space into space\n\n   let cp=instr.codePointAt(0) || 0;\n   if (cp>127) return 63; // ASCII for \"?\"\n   return cp;\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////\n\nexport class twrCodePageToUnicodeCodePoint {\n\tdecoderUTF8 = new TextDecoder('utf-8');\n\tdecoder1252 = new TextDecoder('windows-1252');\n\n\tconvert(c:number, codePage:number) {\n\t\tlet outstr:string;\n\t\tif (codePage==codePageUTF8) {\n\t\t\toutstr=this.decoderUTF8.decode(new Uint8Array([c]), {stream: true});\n\t\t}\n\t\telse if (codePage==codePage1252) {\n\t\t\toutstr = this.decoder1252.decode(new Uint8Array([c]));\n\t\t}\n\t\telse if (codePage==codePageASCII) {\n\t\t\tif (c>127) outstr=\"\";\n\t\t\telse outstr=String.fromCharCode(c);\n\t\t}\n\t\telse if (codePage==codePageUTF32) {\n\t\t\toutstr=String.fromCodePoint(c);\n\t\t}\n\t\telse {\n\t\t\tthrow new Error(\"unsupported CodePage: \"+codePage)\n\t\t}\n\n\t\treturn outstr.codePointAt(0) || 0;\n\t}\n}\n","import { twrEventQueueReceive } from \"./twreventqueue.js\";\n/////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////\nexport class twrLibrary {\n    // set to unique name if multiple instances allowed (must all expose the same interface) (e.g. consoles).  \n    // When true, APIs will expect first arg to be library ID.\n    interfaceName;\n    constructor() {\n    }\n    // the actual twrLibrary is created outside of a specific wasm module, so isn't paired to a specific module\n    // however, each call to getImports is paired to a specific wasm module\n    // getImports returns Wasm Module imports that will be added to this wasm module's WebAssembly.ModuleImports\n    // getImports expects that the derived class has created a \"this.import\" with a list of function names (as strings)\n    // getImports is called by twrWasmModule\n    getImports(callingMod) {\n        if (callingMod.isTwrWasmModuleAsync)\n            throw new Error(\"unsupported module type (expecting twrWasmModule\");\n        let wasmImports = {};\n        const derivedInstanceThis = this;\n        if (this.imports === undefined)\n            throw new Error(\"twrLibrary derived class is missing imports.\");\n        if (this.libSourcePath === undefined)\n            throw new Error(\"twrLibrary derived class is missing libSourcePath.\");\n        for (let funcName in this.imports) {\n            if (this.imports[funcName].isModuleAsyncOnly) {\n                const nullFun = () => {\n                    throw new Error(\"Invalid call to unimplemented twrLibrary 'import' function (isModuleAsyncOnly was used): \" + funcName);\n                };\n                wasmImports[funcName] = nullFun;\n            }\n            else {\n                if (!derivedInstanceThis[funcName])\n                    throw new Error(\"twrLibrary 'import' function is missing: \" + funcName);\n                if (this.interfaceName) {\n                    // in this case, this particular instance represents the class\n                    // but the actual instance needs to be retrieved at runtime using the libID & registry\n                    // since only once set of WasmImports is created for each class\n                    const libFunc = (funcName, mod, libID, ...params) => {\n                        const lib = twrLibraryInstanceRegistry.getLibraryInstance(libID);\n                        const derivedLib = lib;\n                        const f = derivedLib[funcName];\n                        if (!f)\n                            throw new Error(`Library function not found. id=${libID}, funcName=${funcName}`);\n                        return f.call(derivedLib, mod, ...params);\n                    };\n                    wasmImports[funcName] = libFunc.bind(null, funcName, callingMod); // rest of function args are also passed to libFunc when using bind\n                }\n                else {\n                    wasmImports[funcName] = derivedInstanceThis[funcName].bind(this, callingMod);\n                }\n            }\n        }\n        return wasmImports;\n    }\n    // this function is called by twrWasmModuleAsync, and sent to the corresponding twrWasmModuleAsyncProxy\n    getProxyParams() {\n        return [\"twrLibraryProxy\", this.id, this.imports, this.libSourcePath, this.interfaceName];\n    }\n    // called by twrWasmModuleAsync\n    async processMessageFromProxy(msg, mod) {\n        const [msgClass, libID, funcName, doAwait, returnValueEventID, ...params] = msg;\n        if (this.interfaceName && twrLibraryInstanceRegistry.getLibraryInstance(libID).libSourcePath != this.libSourcePath)\n            throw new Error(\"internal error\"); // should never happen\n        else if (libID != this.id)\n            throw new Error(\"internal error\"); // should never happen\n        if (!mod.isTwrWasmModuleAsync)\n            throw new Error(\"internal error\");\n        const libThis = twrLibraryInstanceRegistry.getLibraryInstance(libID);\n        const derivedInstance = libThis;\n        if (!derivedInstance[funcName])\n            throw new Error(\"twrLibrary derived class missing 'import' function: \" + funcName);\n        let retVal;\n        if (doAwait)\n            retVal = await derivedInstance[funcName](mod, ...params);\n        else\n            retVal = derivedInstance[funcName](mod, ...params);\n        if (returnValueEventID > -1) // -1 means noBlock true\n            mod.eventQueueSend.postEvent(returnValueEventID, retVal);\n    }\n}\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\nexport class twrLibraryProxy {\n    id;\n    imports;\n    libSourcePath;\n    interfaceName;\n    called = false;\n    //every module instance has its own twrLibraryProxy\n    constructor(params) {\n        const [className, id, imports, libSourcePath, interfaceName] = params;\n        this.id = id;\n        this.imports = imports;\n        this.libSourcePath = libSourcePath;\n        this.interfaceName = interfaceName;\n    }\n    remoteProcedureCall(ownerMod, funcName, isAsyncFunction, returnValueEventID, interfaceName, ...args) {\n        let msg;\n        if (interfaceName)\n            msg = [\"twrLibrary\", args[0], funcName, isAsyncFunction, returnValueEventID, ...args.slice(1)];\n        else\n            msg = [\"twrLibrary\", this.id, funcName, isAsyncFunction, returnValueEventID, ...args];\n        // postMessage sends message to the JS Main thread that created the twrModAsyncProxy thread\n        // the message processing code discriminates the destination instance by:  \"twrLibrary\", this.id,\n        postMessage(msg);\n        //TODO!! a void return type isn't particularly supported -- it will presumably returned undefined from the JS function, \n        //which will put a zero into the Int32Array used for returnValue\n        if (returnValueEventID == -1) { // -1 means noBlock true\n            return 0;\n        }\n        const [id, retVals] = ownerMod.eventQueueReceive.waitEvent(returnValueEventID);\n        if (id != returnValueEventID)\n            throw new Error(\"internal error\");\n        if (retVals.length != 1)\n            throw new Error(\"internal error\");\n        return retVals[0];\n    }\n    // getProxyImports is called by twrWasmModuleAsyncProxy\n    // it provides the functions that the twrWasmModuleAsync's C code will call\n    // these will RPC to the JS main thread (unless isCommonCode set) and then wait for a return value (unless noBlock) \n    async getProxyImports(ownerMod) {\n        if (this.called === true)\n            throw new Error(\"getProxyImports should only be called once per twrLibraryProxy instance\");\n        this.called = true;\n        let wasmImports = {};\n        let libClass;\n        // now for each twrLibrary import, create the functions that will be added to wasm module imports\n        for (let funcName in this.imports) {\n            if (this.imports[funcName].isCommonCode) {\n                if (this.imports[funcName].isAsyncFunction)\n                    throw new Error(\"isAsyncFunction can not be used with isCommonCode\");\n                if (libClass === undefined) {\n                    if (this.libSourcePath === undefined)\n                        throw new Error(\"undefined libSourcePath\");\n                    const libMod = await import(this.libSourcePath);\n                    libClass = new libMod.default;\n                }\n                wasmImports[funcName] = libClass[funcName].bind(libClass, ownerMod);\n            }\n            else {\n                if (this.imports[funcName].isAsyncFunction) {\n                    wasmImports[funcName] = this.remoteProcedureCall.bind(this, ownerMod, funcName + \"_async\", this.imports[funcName].isAsyncFunction ? true : false, this.imports[funcName].noBlock ? -1 : twrEventQueueReceive.registerEvent(), this.interfaceName);\n                }\n                else {\n                    wasmImports[funcName] = this.remoteProcedureCall.bind(this, ownerMod, funcName, this.imports[funcName].isAsyncFunction ? true : false, this.imports[funcName].noBlock ? -1 : twrEventQueueReceive.registerEvent(), this.interfaceName);\n                }\n            }\n        }\n        return wasmImports;\n    }\n}\n/////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////\n// this is global in the JS main thread address space\n// all libraries are registered here\nexport class twrLibraryInstanceRegistry {\n    // every twrLibrary instance goes here\n    static libInstances = [];\n    // Each unique interface has one representative and arbitrary instance in libInterfaceInstances.\n    // A unique interfaceName represents a unique interface.  Multiple classes may have the same interfaceName.\n    // (A class is identified by libSourcePath)\n    // An undefined interfaceName (anonymous interface) means that only one instance of that class is allowed\n    // and also means that the class has a unique anonymous interface.\n    static libInterfaceInstances = [];\n    // create a pairing between an instance of type ILibraryBase and an integer ID\n    static register(libInstance) {\n        if (libInstance.imports === undefined)\n            throw new Error(\"twrLibrary derived class is missing imports.\");\n        if (libInstance.libSourcePath === undefined)\n            throw new Error(\"twrLibrary derived class is missing libSourcePath.\");\n        // register the new instance\n        twrLibraryInstanceRegistry.libInstances.push(libInstance);\n        const id = twrLibraryInstanceRegistry.libInstances.length - 1;\n        // if this has a named interface, add it to the interface list, but only add it once.\n        if (libInstance.interfaceName) {\n            const interfaceID = this.getLibraryInstanceByInterfaceName(libInstance.interfaceName);\n            if (interfaceID === undefined)\n                twrLibraryInstanceRegistry.libInterfaceInstances.push(libInstance);\n            else {\n                // verify the interface are compatible.  If they don't its a coding error\n                const alreadyRegisteredLibInstance = twrLibraryInstanceRegistry.libInterfaceInstances[interfaceID];\n                for (let i = 0; i < twrLibraryInstanceRegistry.libInterfaceInstances.length; i++)\n                    if (twrLibraryInstanceRegistry.libInterfaceInstances[i].interfaceName === libInstance.interfaceName)\n                        if (!CompareImports(twrLibraryInstanceRegistry.libInterfaceInstances[i].imports, libInstance.imports))\n                            throw new Error(`interface definitions (imports) ${libInstance.interfaceName} are not compatible between class ${libInstance.libSourcePath} and ${alreadyRegisteredLibInstance.libSourcePath}`);\n                // TODO!!  This is here to make twrcondummy.ts work correctly (a console without a complete interface might be loaded before twrcondummy.ts)\n                if (Object.keys(libInstance.imports).length > Object.keys(alreadyRegisteredLibInstance.imports).length)\n                    twrLibraryInstanceRegistry.libInterfaceInstances[interfaceID] = libInstance;\n            }\n        }\n        // else this the type of Class that should only have a single instance\n        else {\n            // then check for the error where a Class is registered more than once\n            if (this.getLibraryInstanceByClass(libInstance.libSourcePath))\n                throw new Error(\"A second twrLibrary instance was registered but interfaceName===undefined\");\n            // if no error, than add anonymous interface to the list\n            twrLibraryInstanceRegistry.libInterfaceInstances.push(libInstance);\n        }\n        return id;\n    }\n    static getLibraryInstance(id) {\n        if (id < 0 || id >= twrLibraryInstanceRegistry.libInstances.length)\n            throw new Error(\"Invalid console ID: \" + id);\n        return twrLibraryInstanceRegistry.libInstances[id];\n    }\n    static getLibraryInstanceByInterfaceName(name) {\n        for (let i = 0; i < twrLibraryInstanceRegistry.libInterfaceInstances.length; i++)\n            if (twrLibraryInstanceRegistry.libInterfaceInstances[i].interfaceName === name)\n                return i;\n        return undefined;\n    }\n    static getLibraryInstanceByClass(path) {\n        for (let i = 0; i < twrLibraryInstanceRegistry.libInterfaceInstances.length; i++)\n            if (twrLibraryInstanceRegistry.libInstances[i].libSourcePath === path)\n                return twrLibraryInstanceRegistry.libInstances;\n        return undefined;\n    }\n    static getLibraryInstanceID(libInstance) {\n        for (let i = 0; i < twrLibraryInstanceRegistry.libInstances.length; i++)\n            if (twrLibraryInstanceRegistry.libInstances[i] == libInstance)\n                return i;\n        throw new Error(\"libInstance not in registry\");\n    }\n}\n// this is created in each twrWasmModuleAsyncProxy Worker thread\n// if there are multiple twrWasmModuleAsyncProxy instances, there will one Registry in each Worker\n// TODO!! This isn't used or probably correct\nexport class twrLibraryInstanceProxyRegistry {\n    static libProxyInstances = [];\n    // create a pairing between an instance of type IConsole and an integer ID\n    static registerProxy(libProxyInstance) {\n        twrLibraryInstanceProxyRegistry.libProxyInstances[libProxyInstance.id] = libProxyInstance;\n        return libProxyInstance.id;\n    }\n    static getLibraryInstanceProxy(id) {\n        if (id < 0 || id >= twrLibraryInstanceProxyRegistry.libProxyInstances.length)\n            throw new Error(\"Invalid console ID: \" + id);\n        return twrLibraryInstanceProxyRegistry.libProxyInstances[id];\n    }\n    static getLibraryInstanceID(libProxyInstance) {\n        for (let i = 0; i < twrLibraryInstanceProxyRegistry.libProxyInstances.length; i++)\n            if (twrLibraryInstanceProxyRegistry.libProxyInstances[i] == libProxyInstance)\n                return i;\n        throw new Error(\"libProxyInstance not in registry\");\n    }\n}\nfunction shallowEqual(obj1, obj2) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    // If the objects have different numbers of keys, they aren't equal\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    // Check if all keys and their values are equal\n    return keys1.every(key => obj1[key] === obj2[key]);\n}\nfunction CompareImports(obj1, obj2) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    // they don't have to have the same number of imports, but every import that exists in both needs to match\n    for (let i = 0; i < keys1.length; i++) {\n        const k = keys1[i];\n        if (obj2[k] && !shallowEqual(obj1[k], obj2[k]))\n            return false;\n    }\n    for (let i = 0; i < keys2.length; i++) {\n        const k = keys2[i];\n        if (obj1[k] && !shallowEqual(obj1[k], obj2[k]))\n            return false;\n    }\n    return true;\n}\n//# sourceMappingURL=twrlibrary.js.map","import {IWasmModule} from \"./twrmod.js\"\nimport {IWasmModuleAsync} from \"./twrmodasync.js\"\nimport {twrWasmModuleAsyncProxy} from \"./twrmodasyncproxy.js\"\nimport {twrEventQueueReceive} from \"./twreventqueue.js\"\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\n// TODO List\n// Should we:  Allow callbacks while blocking call is waiting? Not on \"return value\" waits, but on functions like sleep.\n// add a function to allow twrWasmModuleAsync c code (like main) to process events without returning to JavaScript\n// fix example/lib/out and .gitignore so correct build artifacts are checked in  \n// resolve fact that libraries with interfaces are passed in the \"io\" option.  Eg Allow \"libs\" or other synonym.\n// current implementation has no libs: (akin to io:).  \n// consider if  twrcondummy should be removed.  Search for TODO, there are multiple places needing fixing.  Possible solutions:\n//     (a) have interfaceName also list every function in the interface.  \n//         create placholder \"internal error\" functions when a console/library does not implement an interface function.\n//     (b) require each function in interface in list each import correctly (either add isUnused or add dummy functions with exception)\n//     (c) merge imports (this won't work because a complete set of functions might not be loaded by api user)\n//     also search for \"TODO!!  This is here to make twrcondummy.ts\"\n// changed conterm example to use debug -- either change back, or change index description\n// deal with twrConGetIDFromNameImpl.  Note that twr_register_callback and twrConGetIDFromNameImpl are added in two different places.  Unify\n// change callingMod:IWasmModule|IWasmModuleAsync to IWasmBase ?\n// add IWasmBase instead of using twrWasmBase\n// add IWasmModuleBase ?\n// Consider and handle app exit (stop events from being posted post app exit)\n// Add postEvent example that includes arguments\n// Implement event loop processing (get_next_event, get_filter_event)\n// Issue with above: how do I get the event parameters?\n// implement event loop in twrWasmModule (currently only in twrWasmModuleAsync) ?\n// Need better name collision prevention on imported functions\n// Are too many inefficient tickleEventLoop being sent?\n// add codepage arg to register callback?\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\nexport type TLibImports = { [key:string]: {isAsyncFunction?:boolean, isModuleAsyncOnly?:boolean, isCommonCode?:boolean, noBlock?:boolean}};\nexport type TLibraryProxyParams = [\"twrLibraryProxy\", libID:number, imports:TLibImports, libSourcePath:string, interfaceName: string|undefined];\n\n// TLibraryMessage is sent from twrWasmModuleAsyncProxy (worker thread) to twrWasmModuleAsync\nexport type TLibraryMessage = [\"twrLibrary\", libID:number, funcName:string, isAsyncOverride:boolean, returnValueEventID:number, ...args:any[]];\n\n/////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////\n\nexport abstract class twrLibrary  {\n   abstract id: number;\n\n   // must be set by derived class to describe each library function.  See docs.\n   abstract imports: TLibImports;\n\n   // libSourcePath must be set like this:\n   //    use \"libSourcePath = new URL(import.meta.url).pathname\" \n   //    above works for both bundled and unbundled -- at least with parcel\n   //    example: \"/lib-js/twrlibmath.js\" \n   abstract libSourcePath: string;\n\n   // set to unique name if multiple instances allowed (must all expose the same interface) (e.g. consoles).  \n   // When true, APIs will expect first arg to be library ID.\n   interfaceName?:string;\n\n   constructor() {\n   }\n\n   // the actual twrLibrary is created outside of a specific wasm module, so isn't paired to a specific module\n   // however, each call to getImports is paired to a specific wasm module\n   // getImports returns Wasm Module imports that will be added to this wasm module's WebAssembly.ModuleImports\n   // getImports expects that the derived class has created a \"this.import\" with a list of function names (as strings)\n   // getImports is called by twrWasmModule\n   getImports(callingMod:IWasmModule) {\n      if (callingMod.isTwrWasmModuleAsync) throw new Error(\"unsupported module type (expecting twrWasmModule\");\n\n      let wasmImports:{[key:string]: Function}={};\n      const derivedInstanceThis=(this as unknown) as {[key:string]:(mod:IWasmModule, ...params:any)=>void};\n\n      if (this.imports===undefined) throw new Error(\"twrLibrary derived class is missing imports.\");\n      if (this.libSourcePath===undefined) throw new Error(\"twrLibrary derived class is missing libSourcePath.\");\n      \n      for (let funcName in this.imports) {\n         if (this.imports[funcName].isModuleAsyncOnly) {\n            const nullFun=() => {\n               throw new Error(\"Invalid call to unimplemented twrLibrary 'import' function (isModuleAsyncOnly was used): \"+funcName);\n            }\n            wasmImports[funcName]=nullFun;\n         }\n         else {\n            if (!derivedInstanceThis[funcName]) \n               throw new Error(\"twrLibrary 'import' function is missing: \"+funcName);\n\n            if (this.interfaceName) {\n               // in this case, this particular instance represents the class\n               // but the actual instance needs to be retrieved at runtime using the libID & registry\n               // since only once set of WasmImports is created for each class\n\n               const libFunc = (funcName: string, mod:IWasmModule, libID:number, ...params: any[]):any => {\n                  const lib=twrLibraryInstanceRegistry.getLibraryInstance(libID);\n                  const derivedLib=(lib as unknown) as {[key:string]:(callingMod:IWasmModule, ...params:any)=>void};\n                  const f=derivedLib[funcName];\n                  if (!f) throw new Error(`Library function not found. id=${libID}, funcName=${funcName}`);\n                  return f.call(derivedLib, mod, ...params);\n               }\n               \n               wasmImports[funcName]=libFunc.bind(null, funcName, callingMod);  // rest of function args are also passed to libFunc when using bind\n            }\n            else {\n               wasmImports[funcName]=derivedInstanceThis[funcName].bind(this, callingMod);\n            }\n         }\n      }\n\n      return wasmImports;\n   }\n\n   // this function is called by twrWasmModuleAsync, and sent to the corresponding twrWasmModuleAsyncProxy\n   getProxyParams() : TLibraryProxyParams {\n      return [\"twrLibraryProxy\", this.id, this.imports, this.libSourcePath, this.interfaceName];\n   }\n\n   // called by twrWasmModuleAsync\n   async processMessageFromProxy(msg:TLibraryMessage, mod:IWasmModuleAsync) {\n      const [msgClass, libID, funcName, doAwait, returnValueEventID, ...params]=msg;\n      if (this.interfaceName && twrLibraryInstanceRegistry.getLibraryInstance(libID).libSourcePath!=this.libSourcePath)\n            throw new Error(\"internal error\");  // should never happen\n      else if (libID!=this.id) throw new Error(\"internal error\");  // should never happen\n      \n      if (!mod.isTwrWasmModuleAsync) throw new Error(\"internal error\");\n\n      const libThis=twrLibraryInstanceRegistry.getLibraryInstance(libID);\n      const derivedInstance=(libThis as unknown) as {[key:string]: ( (mod:IWasmModuleAsync|IWasmModule, ...params:any[])=>any) };\n      if (!derivedInstance[funcName]) throw new Error(\"twrLibrary derived class missing 'import' function: \"+funcName);\n      \n      let retVal;\n      if (doAwait)\n         retVal=await derivedInstance[funcName](mod, ...params);\n      else\n         retVal=derivedInstance[funcName](mod, ...params);\n\n      if (returnValueEventID>-1) // -1 means noBlock true\n         mod.eventQueueSend.postEvent(returnValueEventID, retVal);\n   }   \n\n}\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\nexport class twrLibraryProxy {\n   id:number;\n   imports: TLibImports;\n   libSourcePath:string;\n   interfaceName?:string;\n   called=false;\n\n   //every module instance has its own twrLibraryProxy\n\n   constructor(params:TLibraryProxyParams) {\n       const [className, id, imports, libSourcePath, interfaceName] = params;\n       this.id=id;\n       this.imports=imports;\n       this.libSourcePath=libSourcePath;\n       this.interfaceName=interfaceName;\n   }\n\n   private remoteProcedureCall(ownerMod:twrWasmModuleAsyncProxy, funcName:string, isAsyncFunction:boolean, returnValueEventID:number, interfaceName:string|undefined, ...args:any[]) {\n      let msg:TLibraryMessage;\n\n      if (interfaceName)\n         msg=[\"twrLibrary\", args[0], funcName, isAsyncFunction, returnValueEventID, ...args.slice(1)];\n      else\n         msg=[\"twrLibrary\", this.id, funcName, isAsyncFunction, returnValueEventID, ...args];\n\n      // postMessage sends message to the JS Main thread that created the twrModAsyncProxy thread\n      // the message processing code discriminates the destination instance by:  \"twrLibrary\", this.id,\n      postMessage(msg);\n      //TODO!! a void return type isn't particularly supported -- it will presumably returned undefined from the JS function, \n      //which will put a zero into the Int32Array used for returnValue\n\n      if (returnValueEventID==-1) {  // -1 means noBlock true\n         return 0;\n      }\n\n      const [id, retVals]=ownerMod.eventQueueReceive.waitEvent(returnValueEventID);\n      if (id!=returnValueEventID) throw new Error(\"internal error\");\n      if (retVals.length!=1) throw new Error(\"internal error\"); \n      return retVals[0];\n   }\n\n   // getProxyImports is called by twrWasmModuleAsyncProxy\n   // it provides the functions that the twrWasmModuleAsync's C code will call\n   // these will RPC to the JS main thread (unless isCommonCode set) and then wait for a return value (unless noBlock) \n   async getProxyImports(ownerMod:twrWasmModuleAsyncProxy) {\n      if (this.called===true) throw new Error(\"getProxyImports should only be called once per twrLibraryProxy instance\");\n      this.called=true;\n\n      let wasmImports:{[key:string]: Function}={};\n      let libClass;\n\n   // now for each twrLibrary import, create the functions that will be added to wasm module imports\n   for (let funcName in this.imports) {\n\n         if (this.imports[funcName].isCommonCode) {\n            if (this.imports[funcName].isAsyncFunction) \n               throw new Error(\"isAsyncFunction can not be used with isCommonCode\");\n            if (libClass===undefined) {\n               if (this.libSourcePath===undefined) \n                  throw new Error(\"undefined libSourcePath\");\n               const libMod=await import(this.libSourcePath);\n               libClass=new libMod.default;\n            }\n            wasmImports[funcName]=libClass[funcName].bind(libClass, ownerMod);\n         }\n         else {\n            if (this.imports[funcName].isAsyncFunction) {\n               wasmImports[funcName]=this.remoteProcedureCall.bind(this, ownerMod, funcName+\"_async\", this.imports[funcName].isAsyncFunction?true:false, this.imports[funcName].noBlock?-1:twrEventQueueReceive.registerEvent(), this.interfaceName);\n            }\n            else {\n               wasmImports[funcName]=this.remoteProcedureCall.bind(this, ownerMod, funcName, this.imports[funcName].isAsyncFunction?true:false, this.imports[funcName].noBlock?-1:twrEventQueueReceive.registerEvent(), this.interfaceName);\n            }\n         }\n      }\n\n      return wasmImports;\n   }\n}\n\n/////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////\n\n// this is global in the JS main thread address space\n// all libraries are registered here\nexport class twrLibraryInstanceRegistry {\n\n   // every twrLibrary instance goes here\n   static libInstances: twrLibrary[]=[];\n\n   // Each unique interface has one representative and arbitrary instance in libInterfaceInstances.\n   // A unique interfaceName represents a unique interface.  Multiple classes may have the same interfaceName.\n   // (A class is identified by libSourcePath)\n   // An undefined interfaceName (anonymous interface) means that only one instance of that class is allowed\n   // and also means that the class has a unique anonymous interface.\n   static libInterfaceInstances: twrLibrary[]=[];\n\n   // create a pairing between an instance of type ILibraryBase and an integer ID\n   static register(libInstance:twrLibrary) {\n\n      if (libInstance.imports===undefined) throw new Error(\"twrLibrary derived class is missing imports.\");\n      if (libInstance.libSourcePath===undefined) throw new Error(\"twrLibrary derived class is missing libSourcePath.\");\n\n      // register the new instance\n      twrLibraryInstanceRegistry.libInstances.push(libInstance);\n      const id=twrLibraryInstanceRegistry.libInstances.length-1;\n\n      // if this has a named interface, add it to the interface list, but only add it once.\n      if (libInstance.interfaceName) {\n         const interfaceID=this.getLibraryInstanceByInterfaceName(libInstance.interfaceName);\n         if (interfaceID===undefined)\n            twrLibraryInstanceRegistry.libInterfaceInstances.push(libInstance);\n         else {\n            // verify the interface are compatible.  If they don't its a coding error\n            const alreadyRegisteredLibInstance=twrLibraryInstanceRegistry.libInterfaceInstances[interfaceID];\n            for (let i=0; i<twrLibraryInstanceRegistry.libInterfaceInstances.length; i++)\n               if (twrLibraryInstanceRegistry.libInterfaceInstances[i].interfaceName===libInstance.interfaceName)\n                  if (!CompareImports(twrLibraryInstanceRegistry.libInterfaceInstances[i].imports, libInstance.imports))\n                     throw new Error(`interface definitions (imports) ${libInstance.interfaceName} are not compatible between class ${libInstance.libSourcePath} and ${alreadyRegisteredLibInstance.libSourcePath}`);\n \n            // TODO!!  This is here to make twrcondummy.ts work correctly (a console without a complete interface might be loaded before twrcondummy.ts)\n            if (Object.keys(libInstance.imports).length > Object.keys(alreadyRegisteredLibInstance.imports).length)\n               twrLibraryInstanceRegistry.libInterfaceInstances[interfaceID]=libInstance;\n         }\n      }\n\n      // else this the type of Class that should only have a single instance\n      else {\n          // then check for the error where a Class is registered more than once\n         if (this.getLibraryInstanceByClass(libInstance.libSourcePath)) \n            throw new Error(\"A second twrLibrary instance was registered but interfaceName===undefined\")\n\n         // if no error, than add anonymous interface to the list\n         twrLibraryInstanceRegistry.libInterfaceInstances.push(libInstance);\n      }\n\n      return id;\n   }\n\n   static getLibraryInstance(id:number) {\n      if (id<0 || id >= twrLibraryInstanceRegistry.libInstances.length)\n         throw new Error(\"Invalid console ID: \"+id);\n\n      return twrLibraryInstanceRegistry.libInstances[id];\n   }\n\n   static getLibraryInstanceByInterfaceName(name:string) {\n      for (let i=0; i<twrLibraryInstanceRegistry.libInterfaceInstances.length; i++)\n         if (twrLibraryInstanceRegistry.libInterfaceInstances[i].interfaceName===name)\n            return i;\n      \n      return undefined;\n   }\n\n   static getLibraryInstanceByClass(path:string) {\n      for (let i=0; i<twrLibraryInstanceRegistry.libInterfaceInstances.length; i++)\n         if (twrLibraryInstanceRegistry.libInstances[i].libSourcePath===path)\n            return twrLibraryInstanceRegistry.libInstances;\n      \n      return undefined;\n   }\n\n   static getLibraryInstanceID(libInstance:twrLibrary) {\n      for (let i=0; i<twrLibraryInstanceRegistry.libInstances.length; i++)\n         if (twrLibraryInstanceRegistry.libInstances[i]==libInstance)\n            return i;\n\n      throw new Error(\"libInstance not in registry\");\n   }\n\n}\n\n// this is created in each twrWasmModuleAsyncProxy Worker thread\n// if there are multiple twrWasmModuleAsyncProxy instances, there will one Registry in each Worker\n// TODO!! This isn't used or probably correct\nexport class twrLibraryInstanceProxyRegistry {\n\n   static libProxyInstances: twrLibraryProxy[]=[];\n\n   // create a pairing between an instance of type IConsole and an integer ID\n   static registerProxy(libProxyInstance:twrLibraryProxy) {\n      twrLibraryInstanceProxyRegistry.libProxyInstances[libProxyInstance.id]=libProxyInstance;\n      return libProxyInstance.id;\n   }\n\n   static getLibraryInstanceProxy(id:number) {\n      if (id<0 || id >= twrLibraryInstanceProxyRegistry.libProxyInstances.length)\n         throw new Error(\"Invalid console ID: \"+id);\n\n      return twrLibraryInstanceProxyRegistry.libProxyInstances[id];\n   }\n\n   static getLibraryInstanceID(libProxyInstance:twrLibraryProxy) {\n      for (let i=0; i<twrLibraryInstanceProxyRegistry.libProxyInstances.length; i++)\n         if (twrLibraryInstanceProxyRegistry.libProxyInstances[i]==libProxyInstance)\n            return i;\n\n      throw new Error(\"libProxyInstance not in registry\");\n   }\n\n}\n\nfunction shallowEqual(obj1:any, obj2:any) {\n   const keys1 = Object.keys(obj1);\n   const keys2 = Object.keys(obj2);\n \n   // If the objects have different numbers of keys, they aren't equal\n   if (keys1.length !== keys2.length) {\n     return false;\n   }\n \n   // Check if all keys and their values are equal\n   return keys1.every(key => obj1[key] === obj2[key]);\n }\n\nfunction CompareImports(obj1:TLibImports, obj2:TLibImports) {\n   const keys1 = Object.keys(obj1);\n   const keys2 = Object.keys(obj2);\n \n   // they don't have to have the same number of imports, but every import that exists in both needs to match\n   for (let i=0; i<keys1.length; i++) {\n      const k=keys1[i];\n      if (obj2[k] && !shallowEqual(obj1[k], obj2[k])) \n         return false;\n   }\n\n   for (let i=0; i<keys2.length; i++) {\n      const k=keys2[i];\n      if (obj1[k] && !shallowEqual(obj1[k], obj2[k])) \n         return false;\n   }\n\n   return true;\n }","import { twrSharedCircularBuffer } from \"./twrcircular.js\";\nconst eventMarker = 0x684610d6; // random positive 32 bit value\nconst mallocMarker = 0x51949385; // random positive 32 bit value\nexport class twrEventQueueSend {\n    circBuffer = new twrSharedCircularBuffer();\n    //TOOD!! unify / rename TOnEventCallback = (eventID:number, ...args:number[])=>void;\n    postEvent(eventID, ...params) {\n        this.circBuffer.writeArray([eventMarker, eventID, params.length, ...params]);\n    }\n    postMalloc(mallocID, size) {\n        this.circBuffer.writeArray([mallocMarker, mallocID, size]);\n    }\n}\nexport class twrEventQueueReceive {\n    circBuffer;\n    pendingEventIDs;\n    pendingEventArgs;\n    ownerMod;\n    static unqiueInt = 1;\n    static onEventCallbacks = [];\n    constructor(ownerMod, eventQueueBuffer) {\n        this.circBuffer = new twrSharedCircularBuffer(eventQueueBuffer);\n        this.pendingEventIDs = [];\n        this.pendingEventArgs = [];\n        this.ownerMod = ownerMod;\n    }\n    readEventRemainder() {\n        const eventID = this.circBuffer.read();\n        if (eventID === undefined)\n            throw new Error(\"internal error\");\n        const argLen = this.circBuffer.read();\n        if (argLen === undefined)\n            throw new Error(\"internal error\");\n        const args = [];\n        for (let i = 0; i < argLen; i++) {\n            const arg = this.circBuffer.read();\n            if (arg === undefined)\n                throw new Error(\"internal error\");\n            args.push(arg);\n        }\n        if (!(eventID in twrEventQueueReceive.onEventCallbacks))\n            throw new Error(\"internal error\");\n        this.pendingEventIDs.push(eventID);\n        this.pendingEventArgs.push(args);\n    }\n    readMallocRemainder() {\n        const mallocID = this.circBuffer.read();\n        if (mallocID === undefined)\n            throw new Error(\"internal error\");\n        const size = this.circBuffer.read();\n        if (size === undefined)\n            throw new Error(\"internal error\");\n        const ptr = this.ownerMod.wasmMem.malloc(size);\n        postMessage([\"twrWasmModule\", mallocID, \"callCOkay\", ptr]); // we are in the twrWasmModuleAsyncProxy main thread\n    }\n    readCommandRemainder(firstValue) {\n        if (firstValue === eventMarker)\n            this.readEventRemainder();\n        else if (firstValue === mallocMarker)\n            this.readMallocRemainder();\n        else\n            throw new Error(\"internal error -- eventMarker or mallocMarker expected but not found\");\n    }\n    // called only if circBuffer not empty\n    readCommand() {\n        const firstValue = this.circBuffer.read();\n        this.readCommandRemainder(firstValue);\n    }\n    readWaitCommand() {\n        const firstValue = this.circBuffer.readWait();\n        this.readCommandRemainder(firstValue);\n    }\n    findEvent(filterEvent) {\n        if (filterEvent === undefined) {\n            return [this.pendingEventIDs.shift(), this.pendingEventArgs.shift(), 0];\n        }\n        const index = this.pendingEventIDs.indexOf(filterEvent);\n        if (index != -1)\n            return [this.pendingEventIDs.splice(index, 1)[0], this.pendingEventArgs.splice(index, 1)[0], index];\n        return [undefined, undefined, undefined];\n    }\n    waitEvent(filterEvent) {\n        while (true) {\n            // empty the queue\n            while (!this.circBuffer.isEmpty())\n                this.readCommand();\n            // is our event in the queue?\n            const [eventID, args, index] = this.findEvent(filterEvent);\n            // execute callbacks up to this filterEvent (so as to call them in order)\n            // if filterEvent not found, index is undefined, which causes doCallbacks to execute all pendingEventIDs\n            // this call commented out so that the C events act like JavaScript events/callbacks (only called when main function finishes)\n            // to consider: allow callbacks in sync blocking functions like sleep (that use await in their implementations)\n            //this.doCallbacks(index); \n            if (eventID && args) {\n                return [eventID, args];\n            }\n            // wait for a new event\n            this.readWaitCommand();\n        }\n    }\n    doCallbacks(upToIndex) {\n        const end = upToIndex ? upToIndex : this.pendingEventIDs.length;\n        console.log(\"end\", end, upToIndex, this.pendingEventIDs.length);\n        for (let i = 0; i < end; i++) {\n            const eventID = this.pendingEventIDs[i];\n            const args = this.pendingEventArgs[i];\n            const onEventCallback = twrEventQueueReceive.onEventCallbacks[eventID];\n            if (onEventCallback) {\n                onEventCallback(eventID, ...args);\n                this.pendingEventIDs.splice(i, 1);\n                this.pendingEventArgs.splice(i, 1);\n            }\n        }\n    }\n    processIncomingCommands() {\n        while (!this.circBuffer.isEmpty())\n            this.readCommand();\n        this.doCallbacks();\n    }\n    //see twrWasmModule.constructor - imports - twr_register_callback:this.registerCallback.bind(this), \n    //TODO!! This static method works for twrWasmModuleAsync, but when/if I implement message loop for twrWasmModule, this may need to change?\n    static registerCallback(funcName, onEventCallback) {\n        if (!onEventCallback)\n            throw new Error(\"registerCallback called with a function name that is not exported from the module\");\n        this.onEventCallbacks[++this.unqiueInt] = onEventCallback;\n        return this.unqiueInt;\n    }\n    static registerEvent() {\n        this.onEventCallbacks[++this.unqiueInt] = undefined;\n        return this.unqiueInt;\n    }\n}\n//# sourceMappingURL=twreventqueue.js.map","import {twrSharedCircularBuffer} from \"./twrcircular.js\"\nimport {twrWasmModuleAsyncProxy} from \"./twrmodasyncproxy.js\";\n\nconst eventMarker=0x684610d6;    // random positive 32 bit value\nconst mallocMarker=0x51949385;   // random positive 32 bit value\n\nexport class twrEventQueueSend {\n   circBuffer: twrSharedCircularBuffer=new twrSharedCircularBuffer();\n\n//TOOD!! unify / rename TOnEventCallback = (eventID:number, ...args:number[])=>void;\n   postEvent(eventID:number, ...params:number[]):void {\n      this.circBuffer.writeArray([eventMarker, eventID, params.length, ...params]);\n   }\n\n   postMalloc(mallocID:number, size:number) {\n      this.circBuffer.writeArray([mallocMarker, mallocID, size]);\n   }\n}\n\nexport type TOnEventCallback = (eventID:number, ...args:number[])=>void;\n\n\nexport class twrEventQueueReceive {\n   circBuffer: twrSharedCircularBuffer;\n   pendingEventIDs: number[];\n   pendingEventArgs: (number[])[];\n   ownerMod:twrWasmModuleAsyncProxy;\n   static unqiueInt:number=1;\n   static onEventCallbacks:(TOnEventCallback|undefined)[]=[];\n\n   constructor(ownerMod:twrWasmModuleAsyncProxy, eventQueueBuffer:SharedArrayBuffer) {\n      this.circBuffer=new twrSharedCircularBuffer(eventQueueBuffer);\n      this.pendingEventIDs=[];\n      this.pendingEventArgs=[];\n      this.ownerMod=ownerMod;\n   }\n\n   private readEventRemainder() {\n      const eventID=this.circBuffer.read();\n      if (eventID===undefined) throw new Error (\"internal error\");\n      const argLen=this.circBuffer.read();\n      if (argLen===undefined) throw new Error (\"internal error\");\n      const args:number[]=[];\n      for (let i=0; i < argLen; i++) {\n         const arg=this.circBuffer.read();\n         if (arg===undefined) throw new Error (\"internal error\");\n         args.push(arg);\n      }\n\n      if (!(eventID in twrEventQueueReceive.onEventCallbacks))\n         throw new Error(\"internal error\");\n\n      this.pendingEventIDs.push(eventID);\n      this.pendingEventArgs.push(args);\n   }\n\n   private readMallocRemainder() {\n      const mallocID=this.circBuffer.read();\n      if (mallocID===undefined) throw new Error (\"internal error\");\n      const size=this.circBuffer.read();\n      if (size===undefined) throw new Error (\"internal error\");\n      const ptr=this.ownerMod.wasmMem.malloc(size);\n      postMessage([\"twrWasmModule\", mallocID, \"callCOkay\", ptr]); // we are in the twrWasmModuleAsyncProxy main thread\n   }\n\n   private readCommandRemainder(firstValue:number|undefined) {\n      if (firstValue===eventMarker) \n         this.readEventRemainder();\n      else if (firstValue===mallocMarker) \n         this.readMallocRemainder();\n      else\n         throw new Error (\"internal error -- eventMarker or mallocMarker expected but not found\");\n   }\n\n   // called only if circBuffer not empty\n   private readCommand() {\n      const firstValue=this.circBuffer.read();\n      this.readCommandRemainder(firstValue);\n   }\n\n   private readWaitCommand() {\n      const firstValue=this.circBuffer.readWait();\n      this.readCommandRemainder(firstValue);\n   }\n\n   private findEvent(filterEvent:number) : [undefined | number, undefined | number[], undefined | number] {\n\n      if (filterEvent===undefined) {\n         return [this.pendingEventIDs.shift(), this.pendingEventArgs.shift(), 0]\n      }\n\n      const index=this.pendingEventIDs.indexOf(filterEvent);\n      if (index!=-1)\n         return [this.pendingEventIDs.splice(index, 1)[0], this.pendingEventArgs.splice(index, 1)[0], index];\n\n      return [undefined, undefined, undefined];\n   }\n\n   \n   waitEvent(filterEvent:number) : [eventID:number, args:number[]] {\n      while (true) {\n         // empty the queue\n         while (!this.circBuffer.isEmpty())\n            this.readCommand();\n\n         // is our event in the queue?\n         const [eventID, args, index]=this.findEvent(filterEvent);\n         // execute callbacks up to this filterEvent (so as to call them in order)\n         // if filterEvent not found, index is undefined, which causes doCallbacks to execute all pendingEventIDs\n         // this call commented out so that the C events act like JavaScript events/callbacks (only called when main function finishes)\n         // to consider: allow callbacks in sync blocking functions like sleep (that use await in their implementations)\n         //this.doCallbacks(index); \n         if (eventID && args) {\n         return [eventID, args];\n         }\n\n         // wait for a new event\n         this.readWaitCommand();\n      }\n   }\n\n   private doCallbacks(upToIndex?:number) {\n      const end=upToIndex?upToIndex:this.pendingEventIDs.length;\n      console.log(\"end\",end, upToIndex, this.pendingEventIDs.length);\n      for (let i=0; i<end; i++) {\n         const eventID=this.pendingEventIDs[i];\n         const args=this.pendingEventArgs[i];\n         const onEventCallback=twrEventQueueReceive.onEventCallbacks[eventID];\n         if (onEventCallback) {\n            onEventCallback(eventID, ...args);\n            this.pendingEventIDs.splice(i, 1);\n            this.pendingEventArgs.splice(i, 1);\n         }\n      }\n   }\n\n   processIncomingCommands() {\n      while (!this.circBuffer.isEmpty())\n         this.readCommand();\n\n      this.doCallbacks();\n   }\n\n   //see twrWasmModule.constructor - imports - twr_register_callback:this.registerCallback.bind(this), \n   //TODO!! This static method works for twrWasmModuleAsync, but when/if I implement message loop for twrWasmModule, this may need to change?\n   static registerCallback(funcName:string, onEventCallback:TOnEventCallback) {\n      if (!onEventCallback) throw new Error(\"registerCallback called with a function name that is not exported from the module\")\n      this.onEventCallbacks[++this.unqiueInt]=onEventCallback;\n      return this.unqiueInt;\n   }\n\n   static registerEvent() {\n      this.onEventCallbacks[++this.unqiueInt]=undefined;\n      return this.unqiueInt;\n   }\n\n}","//\n// This class implements a circular buffer that the main javascript thread can write to, \n// and a blocking WebWorker thread can read from.  This allows keyboard characters to be transferred from the main JS thread to a WebWorker thread.\n// The WebWorker can use the readWait() function to sleep, w/o participating in the normal \n// async callback dispatch method.  This allows a C program that is a single blocking loop to receive input from the primary javascript thread.\n// readWait() is used used when io_getc32() or io_mbgetstr() is called from a C function.\n//\nconst RDIDX = 0;\nconst WRIDX = 1;\nconst LEN = 256;\n// A single thread can read and a separate single thread can write.  With these constraints Atomic operations are not needed.\n// the first 256 array entries are the circular buffer\n// the next two are used for the read and write index\n//!!!! I am using --enable-features=SharedArrayBuffer; see the SharedArrayBuffer docs for COR issues when going to a live web server\nexport class twrSharedCircularBuffer {\n    saBuffer;\n    f64Array;\n    i32Array;\n    constructor(sa) {\n        if (typeof window !== 'undefined') { // this check only works if window defined (not a worker thread)\n            if (!crossOriginIsolated && !(window.location.protocol === 'file:'))\n                throw new Error(\"twrSharedCircularBuffer constructor, crossOriginIsolated=\" + crossOriginIsolated + \". See SharedArrayBuffer docs.\");\n        }\n        if (sa)\n            this.saBuffer = sa;\n        else\n            this.saBuffer = new SharedArrayBuffer(LEN * 8 + 4 + 4); // LEN Float64's + RDIDX and WRIDX (both Int32)\n        this.f64Array = new Float64Array(this.saBuffer, 8);\n        this.i32Array = new Int32Array(this.saBuffer, 0, 2);\n        this.i32Array[RDIDX] = 0;\n        this.i32Array[WRIDX] = 0;\n    }\n    silentWrite(n) {\n        let i = this.i32Array[WRIDX];\n        this.f64Array[i] = n;\n        i++;\n        if (i == LEN)\n            i = 0;\n        this.i32Array[WRIDX] = i;\n    }\n    writeArray(arr) {\n        if (arr.length > 0) {\n            for (let i = 0; i < arr.length; i++)\n                this.silentWrite(arr[i]);\n            Atomics.notify(this.i32Array, WRIDX);\n        }\n    }\n    write(n) {\n        this.silentWrite(n);\n        Atomics.notify(this.i32Array, WRIDX);\n    }\n    read() {\n        if (!this.isEmpty()) {\n            let i = this.i32Array[RDIDX];\n            let n = this.f64Array[i];\n            i++;\n            if (i == LEN)\n                i = 0;\n            this.i32Array[RDIDX] = i;\n            return n;\n        }\n        else\n            return undefined;\n    }\n    readWait() {\n        let retVal = this.read();\n        if (retVal !== undefined)\n            return retVal;\n        const rdptr = this.i32Array[RDIDX];\n        // verifies that a shared memory location still contains a given value and if so sleeps until notified.\n        Atomics.wait(this.i32Array, WRIDX, rdptr);\n        retVal = this.read();\n        if (retVal === undefined)\n            throw new Error(\"internal error\");\n        return retVal;\n    }\n    isEmpty() {\n        return this.i32Array[RDIDX] == this.i32Array[WRIDX];\n    }\n}\n//# sourceMappingURL=twrcircular.js.map","//\n// This class implements a circular buffer that the main javascript thread can write to, \n// and a blocking WebWorker thread can read from.  This allows keyboard characters to be transferred from the main JS thread to a WebWorker thread.\n// The WebWorker can use the readWait() function to sleep, w/o participating in the normal \n// async callback dispatch method.  This allows a C program that is a single blocking loop to receive input from the primary javascript thread.\n// readWait() is used used when io_getc32() or io_mbgetstr() is called from a C function.\n//\n\nconst RDIDX=0;\nconst WRIDX=1;\nconst LEN=256;\n\n// A single thread can read and a separate single thread can write.  With these constraints Atomic operations are not needed.\n// the first 256 array entries are the circular buffer\n// the next two are used for the read and write index\n\n//!!!! I am using --enable-features=SharedArrayBuffer; see the SharedArrayBuffer docs for COR issues when going to a live web server\n\nexport class twrSharedCircularBuffer {\n   saBuffer:SharedArrayBuffer;\n   f64Array:Float64Array;\n   i32Array:Int32Array;\n \n   constructor (sa?:SharedArrayBuffer) {\n      if (typeof window !== 'undefined') {  // this check only works if window defined (not a worker thread)\n         if (!crossOriginIsolated && !(window.location.protocol === 'file:')) \n            throw new Error(\"twrSharedCircularBuffer constructor, crossOriginIsolated=\"+crossOriginIsolated+\". See SharedArrayBuffer docs.\");\n      }\n      if (sa) this.saBuffer=sa;\n      else this.saBuffer=new SharedArrayBuffer(LEN*8+4+4);  // LEN Float64's + RDIDX and WRIDX (both Int32)\n      this.f64Array=new Float64Array(this.saBuffer, 8);\n      this.i32Array=new Int32Array(this.saBuffer, 0, 2);\n      this.i32Array[RDIDX]=0;\n      this.i32Array[WRIDX]=0;\n   }\n\n   private silentWrite(n:number) {\n      let i=this.i32Array[WRIDX];\n      this.f64Array[i]=n;\n      i++;\n      if (i==LEN) i=0;\n      this.i32Array[WRIDX]=i;  \n   }\n\n   writeArray(arr:number[]) {\n      if (arr.length>0) {\n         for (let i=0; i<arr.length; i++)\n            this.silentWrite(arr[i]);\n         Atomics.notify(this.i32Array, WRIDX);\n      }\n   }\n\n   write(n:number) {\n      this.silentWrite(n);\n      Atomics.notify(this.i32Array, WRIDX);   \n   }\n\n   read() {\n        if (!this.isEmpty()) {\n            let i=this.i32Array[RDIDX];\n            let n=this.f64Array[i];\n            i++;\n            if (i==LEN) i=0;\n            this.i32Array[RDIDX]=i;\n            return n;\n        }\n      else\n         return undefined;\n   }\n\n   readWait():number {\n      let retVal=this.read();\n      if (retVal!==undefined) return retVal;\n\n      const rdptr=this.i32Array[RDIDX];\n      // verifies that a shared memory location still contains a given value and if so sleeps until notified.\n      Atomics.wait(this.i32Array, WRIDX, rdptr);\n      retVal=this.read();\n      if (retVal===undefined) throw new Error(\"internal error\");\n      return retVal;\n   }\n\n    isEmpty():boolean {\n        return this.i32Array[RDIDX]==this.i32Array[WRIDX];\n    }\n}\n","/*\n    * callC takes an array where:\n    * the first entry is the name of the C function in the Wasm module to call (must be exported, typically via the --export clang flag)\n    * and the next entries are a variable number of arguments to pass to the C function, of type\n    * number - converted to int32 or float64 as appropriate\n   * bigint - converted to int64\n    * string - converted to a an index (ptr) into a module Memory returned via stringToMem()\n    * ArrayBuffer - the array is loaded into module memory via putArrayBuffer\n    */\nexport class twrWasmCall {\n    exports;\n    mem;\n    constructor(mem, exports) {\n        if (!exports)\n            throw new Error(\"WebAssembly.Exports undefined\");\n        this.exports = exports;\n        this.mem = mem;\n    }\n    callCImpl(fname, cparams = []) {\n        if (!this.exports[fname])\n            throw new Error(\"callC: function '\" + fname + \"' not in export table.  Use --export wasm-ld flag.\");\n        const f = this.exports[fname];\n        let cr = f(...cparams);\n        return cr;\n    }\n    callC(params) {\n        const cparams = this.preCallC(params);\n        let retval = this.callCImpl(params[0], cparams);\n        this.postCallC(cparams, params);\n        return retval;\n    }\n    // convert an array of arguments to numbers by stuffing contents into malloc'd Wasm memory\n    preCallC(params) {\n        if (!(params.constructor === Array))\n            throw new Error(\"callC: params must be array, first arg is function name\");\n        if (params.length == 0)\n            throw new Error(\"callC: missing function name\");\n        let cparams = [];\n        let ci = 0;\n        for (let i = 1; i < params.length; i++) {\n            const p = params[i];\n            switch (typeof p) {\n                case 'number':\n                case 'bigint':\n                    cparams[ci++] = p;\n                    break;\n                case 'string':\n                    cparams[ci++] = this.mem.putString(p);\n                    break;\n                case 'object':\n                    if (p instanceof URL) {\n                        throw new Error(\"URL arg in callC is no longer supported directly.  use module.fetchAndPutURL\");\n                    }\n                    else if (p instanceof ArrayBuffer) {\n                        const r = this.mem.putArrayBuffer(p);\n                        cparams[ci++] = r; // mem index\n                        break;\n                    }\n                default:\n                    throw new Error(\"callC: invalid object type passed in\");\n            }\n        }\n        return cparams;\n    }\n    // free the mallocs; copy array buffer data from malloc back to arraybuffer\n    postCallC(cparams, params) {\n        let ci = 0;\n        for (let i = 1; i < params.length; i++) {\n            const p = params[i];\n            switch (typeof p) {\n                case 'number':\n                case 'bigint':\n                    ci++;\n                    break;\n                case 'string':\n                    this.callCImpl('free', [cparams[ci]]);\n                    ci++;\n                    break;\n                case 'object':\n                    if (p instanceof URL) {\n                        //this.callCImpl('free',[cparams[ci]])\n                        //ci=ci+2;\n                        throw new Error(\"internal error\");\n                    }\n                    else if (p instanceof ArrayBuffer) {\n                        const u8 = new Uint8Array(p);\n                        const idx = cparams[ci];\n                        for (let j = 0; j < u8.length; j++)\n                            u8[j] = this.mem.mem8[idx + j];\n                        this.callCImpl('free', [idx]);\n                        ci++;\n                        break;\n                    }\n                    else\n                        throw new Error(\"postCallC: internal error A\");\n                default:\n                    throw new Error(\"postCallC: internal error B\");\n            }\n        }\n        return cparams;\n    }\n}\nexport class twrWasmModuleCallAsync {\n    mem;\n    callCImpl;\n    constructor(mem, callCImpl) {\n        this.mem = mem;\n        this.callCImpl = callCImpl;\n    }\n    // convert an array of arguments to numbers by stuffing contents into malloc'd Wasm memory\n    async preCallC(params) {\n        if (!(params.constructor === Array))\n            throw new Error(\"callC: params must be array, first arg is function name\");\n        if (params.length == 0)\n            throw new Error(\"callC: missing function name\");\n        let cparams = [];\n        let ci = 0;\n        for (let i = 1; i < params.length; i++) {\n            const p = params[i];\n            switch (typeof p) {\n                case 'number':\n                case 'bigint':\n                    cparams[ci++] = p;\n                    break;\n                case 'string':\n                    cparams[ci++] = await this.mem.putString(p);\n                    break;\n                case 'object':\n                    if (p instanceof URL) {\n                        throw new Error(\"URL arg in callC is no longer supported directly.  use module.fetchAndPutURL\");\n                    }\n                    else if (p instanceof ArrayBuffer) {\n                        const r = await this.mem.putArrayBuffer(p);\n                        cparams[ci++] = r; // mem index\n                        break;\n                    }\n                default:\n                    throw new Error(\"callC: invalid object type passed in\");\n            }\n        }\n        return cparams;\n    }\n    // free the mallocs; copy array buffer data from malloc back to arraybuffer\n    async postCallC(cparams, params) {\n        let ci = 0;\n        for (let i = 1; i < params.length; i++) {\n            const p = params[i];\n            switch (typeof p) {\n                case 'number':\n                case 'bigint':\n                    ci++;\n                    break;\n                case 'string':\n                    await this.callCImpl('free', [cparams[ci]]);\n                    ci++;\n                    break;\n                case 'object':\n                    if (p instanceof URL) {\n                        //await this.callCImpl('free',[cparams[ci]])\n                        //ci=ci+2;\n                        throw new Error(\"internal error\");\n                    }\n                    else if (p instanceof ArrayBuffer) {\n                        const u8 = new Uint8Array(p);\n                        const idx = cparams[ci];\n                        for (let j = 0; j < u8.length; j++)\n                            u8[j] = this.mem.mem8[idx + j]; // mem8 is a Uint8Array view of the module's WebAssembly Memory\n                        await this.callCImpl('free', [idx]);\n                        ci++;\n                        break;\n                    }\n                    else\n                        throw new Error(\"postCallC: internal error A\");\n                default:\n                    throw new Error(\"postCallC: internal error B\");\n            }\n        }\n        return cparams;\n    }\n}\n//# sourceMappingURL=twrwasmcall.js.map","/* \n\t* callC takes an array where:\n\t* the first entry is the name of the C function in the Wasm module to call (must be exported, typically via the --export clang flag)\n\t* and the next entries are a variable number of arguments to pass to the C function, of type\n\t* number - converted to int32 or float64 as appropriate\n   * bigint - converted to int64\n\t* string - converted to a an index (ptr) into a module Memory returned via stringToMem()\n\t* ArrayBuffer - the array is loaded into module memory via putArrayBuffer\n    */\n\nimport {twrWasmMemory, twrWasmMemoryAsync} from \"./twrwasmmem\";\n\n\nexport class twrWasmCall {\n   exports: WebAssembly.Exports;\n   mem: twrWasmMemory;\n\n   constructor(mem:twrWasmMemory, exports:WebAssembly.Exports) {\n      if (!exports) throw new Error(\"WebAssembly.Exports undefined\");\n\n      this.exports=exports;\n      this.mem=mem;\n   }\n\n   callCImpl(fname:string, cparams:(number|bigint)[]=[]) {\n      if (!this.exports[fname]) throw new Error(\"callC: function '\"+fname+\"' not in export table.  Use --export wasm-ld flag.\");\n      const f = this.exports[fname] as Function;\n      let cr=f(...cparams);\n\n      return cr;\n   }\n\n   callC(params:[string, ...(string|number|bigint|ArrayBuffer)[]]) {\n      const cparams=this.preCallC(params);\n      let retval = this.callCImpl(params[0], cparams);\n      this.postCallC(cparams, params);\n      return retval;\n   }\n   \n   // convert an array of arguments to numbers by stuffing contents into malloc'd Wasm memory\n   preCallC(params:[string, ...(string|number|bigint|ArrayBuffer)[]]) {\n   \n      if (!(params.constructor === Array)) throw new Error (\"callC: params must be array, first arg is function name\");\n      if (params.length==0) throw new Error(\"callC: missing function name\");\n   \n      let cparams:(number|bigint)[]=[];\n      let ci=0;\n      for (let i=1; i < params.length; i++) {\n         const p=params[i];\n         switch (typeof p) {\n            case 'number':\n            case 'bigint':\n               cparams[ci++]=p;\n               break;\n            case 'string':\n               cparams[ci++]=this.mem.putString(p);\n               break;\n            case 'object':\n               if (p instanceof URL) {\n                  throw new Error(\"URL arg in callC is no longer supported directly.  use module.fetchAndPutURL\");\n               }\n               else if (p instanceof ArrayBuffer) {\n                  const r=this.mem.putArrayBuffer(p);\n                  cparams[ci++]=r;  // mem index\n                  break;\n               }\n            default:\n               throw new Error (\"callC: invalid object type passed in\");\n         }\n      }\n   \n      return cparams;\n   }\n\n   // free the mallocs; copy array buffer data from malloc back to arraybuffer\n   postCallC(cparams:(number|bigint)[], params:[string, ...(string|number|bigint|ArrayBuffer)[]]) {\n\n      let ci=0;\n      for (let i=1; i < params.length; i++) {\n         const p=params[i];\n         switch (typeof p) {\n            case 'number':\n            case 'bigint':\n               ci++;\n               break;\n\n            case 'string':\n               this.callCImpl('free',[cparams[ci]])\n               ci++;\n               break;\n               \n            case 'object':\n               if (p instanceof URL) {\n                  //this.callCImpl('free',[cparams[ci]])\n                  //ci=ci+2;\n                  throw new Error(\"internal error\");\n               }\n               else if (p instanceof ArrayBuffer) {\n                  const u8=new Uint8Array(p);\n                  const idx=cparams[ci] as number;\n                  for (let j=0; j<u8.length; j++) \n                     u8[j]=this.mem.mem8[idx+j];  \n                  this.callCImpl('free',[idx])\n                  ci++;\n                  break;\n               }\n               else \n                  throw new Error (\"postCallC: internal error A\");\n\n            default:\n               throw new Error (\"postCallC: internal error B\");\n         }\n      }\n\n      return cparams;\n   }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n  \nexport type TCallCImplAsync=(fname:string, cparams:(number|bigint)[])=>Promise<any>;\nexport type TCallCAsync=(params:[string, ...(string|number|bigint|ArrayBuffer)[]])=>Promise<any>;\n\nexport class twrWasmModuleCallAsync {\n   mem: twrWasmMemoryAsync;\n   callCImpl: TCallCImplAsync;\n\n   constructor(mem:twrWasmMemoryAsync, callCImpl:TCallCImplAsync) {\n      this.mem=mem;\n      this.callCImpl=callCImpl;\n   }\n\n   // convert an array of arguments to numbers by stuffing contents into malloc'd Wasm memory\n   async preCallC(params:[string, ...(string|number|bigint|ArrayBuffer)[]]) {\n\n      if (!(params.constructor === Array)) throw new Error (\"callC: params must be array, first arg is function name\");\n      if (params.length==0) throw new Error(\"callC: missing function name\");\n\n      let cparams:(number|bigint)[]=[];\n      let ci=0;\n      for (let i=1; i < params.length; i++) {\n         const p=params[i];\n         switch (typeof p) {\n            case 'number':\n            case 'bigint':\n               cparams[ci++]=p;\n               break;\n            case 'string':\n               cparams[ci++]=await this.mem.putString(p);\n               break;\n            case 'object':\n               if (p instanceof URL) {\n                  throw new Error(\"URL arg in callC is no longer supported directly.  use module.fetchAndPutURL\");\n               }\n               else if (p instanceof ArrayBuffer) {\n                  const r=await this.mem.putArrayBuffer(p);\n                  cparams[ci++]=r;  // mem index\n                  break;\n               }\n            default:\n               throw new Error (\"callC: invalid object type passed in\");\n         }\n      }\n\n      return cparams;\n   }\n\n   // free the mallocs; copy array buffer data from malloc back to arraybuffer\n   async postCallC(cparams:(number|bigint)[], params:[string, ...(string|number|bigint|ArrayBuffer)[]]) {\n\n      let ci=0;\n      for (let i=1; i < params.length; i++) {\n         const p=params[i];\n         switch (typeof p) {\n            case 'number':\n            case 'bigint':\n               ci++;\n               break;\n\n            case 'string':\n               await this.callCImpl('free',[cparams[ci]])\n               ci++;\n               break;\n               \n            case 'object':\n               if (p instanceof URL) {\n                  //await this.callCImpl('free',[cparams[ci]])\n                  //ci=ci+2;\n                  throw new Error(\"internal error\");\n               }\n               else if (p instanceof ArrayBuffer) {\n                  const u8=new Uint8Array(p);\n                  const idx=cparams[ci] as number;\n                  for (let j=0; j<u8.length; j++) \n                     u8[j]=this.mem.mem8[idx+j];   // mem8 is a Uint8Array view of the module's WebAssembly Memory\n                  await this.callCImpl('free',[idx])\n                  ci++;\n                  break;\n               }\n               else \n                  throw new Error (\"postCallC: internal error A\");\n\n            default:\n               throw new Error (\"postCallC: internal error B\");\n         }\n      }\n\n      return cparams;\n   }\n\n}\n","import { parseModOptions } from \"./twrmodutil.js\";\nimport { logToCon } from \"./twrcon.js\";\nimport { twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\nimport { twrWasmBase } from \"./twrwasmbase.js\";\nimport { twrEventQueueReceive } from \"./twreventqueue.js\";\nimport { twrLibBuiltIns } from \"./twrlibbuiltin.js\";\n/*********************************************************************/\nexport class twrWasmModule extends twrWasmBase {\n    io;\n    ioNamesToID;\n    isTwrWasmModuleAsync = false;\n    // divLog is deprecated.  Use IConsole.putStr or log\n    divLog;\n    log;\n    // IWasmMemory\n    // These are deprecated, use wasmMem instead.\n    memory;\n    mem8;\n    mem32;\n    memD;\n    stringToU8;\n    copyString;\n    getLong;\n    setLong;\n    getDouble;\n    setDouble;\n    getShort;\n    getString;\n    getU8Arr;\n    getU32Arr;\n    malloc;\n    free;\n    putString;\n    putU8;\n    putArrayBuffer;\n    /*********************************************************************/\n    constructor(opts = {}) {\n        super();\n        [this.io, this.ioNamesToID] = parseModOptions(opts);\n        this.log = logToCon.bind(undefined, this.io.stdio);\n        this.divLog = this.log;\n    }\n    /*********************************************************************/\n    async loadWasm(pathToLoad) {\n        // load builtin libraries\n        await twrLibBuiltIns();\n        const twrConGetIDFromNameImpl = (nameIdx) => {\n            const name = this.wasmMem.getString(nameIdx);\n            const id = this.ioNamesToID[name];\n            if (id)\n                return id;\n            else\n                return -1;\n        };\n        let imports = {};\n        for (let i = 0; i < twrLibraryInstanceRegistry.libInterfaceInstances.length; i++) {\n            const lib = twrLibraryInstanceRegistry.libInterfaceInstances[i];\n            imports = { ...imports, ...lib.getImports(this) };\n        }\n        imports = {\n            ...imports,\n            twrConGetIDFromName: twrConGetIDFromNameImpl,\n        };\n        await super.loadWasm(pathToLoad, imports);\n        if (!(this.wasmMem.memory.buffer instanceof ArrayBuffer))\n            console.log(\"twrWasmModule does not require shared Memory. Okay to remove wasm-ld --shared-memory --no-check-features\");\n        // backwards compatible\n        this.memory = this.wasmMem.memory;\n        this.mem8 = this.wasmMem.mem8;\n        this.mem32 = this.wasmMem.mem32;\n        this.memD = this.wasmMem.memD;\n        this.malloc = this.wasmMem.malloc;\n        this.free = this.wasmMem.free;\n        this.stringToU8 = this.wasmMem.stringToU8;\n        this.copyString = this.wasmMem.copyString;\n        this.getLong = this.wasmMem.getLong;\n        this.setLong = this.wasmMem.setLong;\n        this.getDouble = this.wasmMem.getDouble;\n        this.setDouble = this.wasmMem.setDouble;\n        this.getShort = this.wasmMem.getShort;\n        this.getString = this.wasmMem.getString;\n        this.getU8Arr = this.wasmMem.getU8Arr;\n        this.getU32Arr = this.wasmMem.getU32Arr;\n        this.putString = this.wasmMem.putString;\n        this.putU8 = this.wasmMem.putU8;\n        this.putArrayBuffer = this.wasmMem.putArrayBuffer;\n        // init C runtime\n        const init = this.exports.twr_wasm_init;\n        init(this.ioNamesToID.stdio, this.ioNamesToID.stderr, this.ioNamesToID.std2d == undefined ? -1 : this.ioNamesToID.std2d, this.wasmMem.mem8.length);\n    }\n    /*********************************************************************/\n    // given a url, load its contents, and stuff into Wasm memory similar to Unint8Array\n    // TODO!! Doc that this is no longer a CallC option, and must be called here manually\n    async fetchAndPutURL(fnin) {\n        if (!(typeof fnin === 'object' && fnin instanceof URL))\n            throw new Error(\"fetchAndPutURL param must be URL\");\n        try {\n            let response = await fetch(fnin);\n            let buffer = await response.arrayBuffer();\n            let src = new Uint8Array(buffer);\n            let dest = this.wasmMem.putU8(src);\n            return [dest, src.length];\n        }\n        catch (err) {\n            console.log('fetchAndPutURL Error. URL: ' + fnin + '\\n' + err + (err.stack ? \"\\n\" + err.stack : ''));\n            throw err;\n        }\n    }\n    postEvent(eventID, ...params) {\n        //TODO!! PostEvent into eventQueueSend, then processEvents -- to enable non callback events when i add them\n        if (!(eventID in twrEventQueueReceive.onEventCallbacks))\n            throw new Error(\"twrWasmModule.postEvent called with invalid eventID: \" + eventID + \", params: \" + params);\n        const onEventCallback = twrEventQueueReceive.onEventCallbacks[eventID];\n        if (onEventCallback)\n            onEventCallback(eventID, ...params);\n        else\n            throw new Error(\"twrWasmModule.postEvent called with undefined callback.  eventID: \" + eventID + \", params: \" + params);\n    }\n    peekEvent(eventName) {\n        // get earliest inserted entry in event Map\n        //const ev=this.events.get(eventName)\n    }\n}\n//# sourceMappingURL=twrmod.js.map","import {parseModOptions, IModOpts} from \"./twrmodutil.js\"\nimport {IConsole, logToCon} from \"./twrcon.js\"\nimport {twrLibraryInstanceRegistry} from \"./twrlibrary.js\";\nimport {IWasmMemory} from './twrwasmmem.js'\nimport {twrWasmCall} from \"./twrwasmcall.js\"\nimport {twrWasmBase, TOnEventCallback} from \"./twrwasmbase.js\"\nimport {twrEventQueueReceive} from \"./twreventqueue.js\"\nimport {twrLibBuiltIns} from \"./twrlibbuiltin.js\"\n\n/*********************************************************************/\n\n// Partial<IWasmMemory> defines the deprecated, backwards compatible \n// memory access APIs that are at the module level.  \n// New code should use wasmMem.\nexport interface IWasmModule extends Partial<IWasmMemory> {\n   wasmMem: IWasmMemory;\n   wasmCall: twrWasmCall;\n   callC:twrWasmCall[\"callC\"];\n   isTwrWasmModuleAsync:false;   // to avoid circular references -- check if twrWasmModule without importing twrWasmModule\n   //TODO!! put these into IWasmModuleBase (some could be implemented in twrWasmModuleBase, but many have different implementations)\n   loadWasm: (pathToLoad:string)=>Promise<void>;\n   postEvent: TOnEventCallback;\n   fetchAndPutURL: (fnin:URL)=>Promise<[number, number]>;\n   divLog:(...params: string[])=>void;\n   log:(...params: string[])=>void;\n}\n\n\n/*********************************************************************/\n\nexport class twrWasmModule extends twrWasmBase implements IWasmModule {\n   io:{[key:string]: IConsole};\n   ioNamesToID: {[key: string]: number};\n   isTwrWasmModuleAsync:false=false;\n\n   // divLog is deprecated.  Use IConsole.putStr or log\n   divLog:(...params: string[])=>void;\n   log:(...params: string[])=>void;\n\n   // IWasmMemory\n   // These are deprecated, use wasmMem instead.\n   memory!:WebAssembly.Memory;\n   mem8!:Uint8Array;\n   mem32!:Uint32Array;\n   memD!:Float64Array;\n   stringToU8!:(sin:string, codePage?:number)=>Uint8Array;\n   copyString!:(buffer:number, buffer_size:number, sin:string, codePage?:number)=>void;\n   getLong!:(idx:number)=>number;\n   setLong!:(idx:number, value:number)=>void;\n   getDouble!:(idx:number)=>number;\n   setDouble!:(idx:number, value:number)=>void;\n   getShort!:(idx:number)=>number;\n   getString!:(strIndex:number, len?:number, codePage?:number)=>string;\n   getU8Arr!:(idx:number)=>Uint8Array;\n   getU32Arr!:(idx:number)=>Uint32Array;\n\n   malloc!:(size:number)=>number;\n   free!:(size:number)=>void;\n   putString!:(sin:string, codePage?:number)=>number;\n   putU8!:(u8a:Uint8Array)=>number;\n   putArrayBuffer!:(ab:ArrayBuffer)=>number;\n\n   /*********************************************************************/\n\n   constructor(opts:IModOpts={}) {\n      super();\n      [this.io, this.ioNamesToID] = parseModOptions(opts);\n      this.log=logToCon.bind(undefined, this.io.stdio);\n      this.divLog=this.log;\n   }\n\n   /*********************************************************************/\n\n   async loadWasm(pathToLoad:string) {\n\n      // load builtin libraries\n      await twrLibBuiltIns();\n\n      const twrConGetIDFromNameImpl = (nameIdx:number):number => {\n         const name=this.wasmMem!.getString(nameIdx);\n         const id=this.ioNamesToID[name];\n         if (id)\n            return id;\n         else\n            return -1;\n      }\n\n      let imports:WebAssembly.ModuleImports={};\n      for (let i=0; i<twrLibraryInstanceRegistry.libInterfaceInstances.length; i++) {\n         const lib=twrLibraryInstanceRegistry.libInterfaceInstances[i];\n         imports={...imports, ...lib.getImports(this)};\n      }\n\n      imports={\n         ...imports,\n         twrConGetIDFromName: twrConGetIDFromNameImpl,\n      }\n\n      await super.loadWasm(pathToLoad, imports);\n\n      if (!(this.wasmMem.memory.buffer instanceof ArrayBuffer))\n         console.log(\"twrWasmModule does not require shared Memory. Okay to remove wasm-ld --shared-memory --no-check-features\");\n\n      // backwards compatible\n      this.memory = this.wasmMem.memory;\n      this.mem8 = this.wasmMem.mem8;\n      this.mem32 = this.wasmMem.mem32;\n      this.memD = this.wasmMem.memD;\n      this.malloc = this.wasmMem.malloc;\n      this.free = this.wasmMem.free;\n      this.stringToU8=this.wasmMem.stringToU8;\n      this.copyString=this.wasmMem.copyString;\n      this.getLong=this.wasmMem.getLong;\n      this.setLong=this.wasmMem.setLong;\n      this.getDouble=this.wasmMem.getDouble;\n      this.setDouble=this.wasmMem.setDouble;\n      this.getShort=this.wasmMem.getShort;\n      this.getString=this.wasmMem.getString;\n      this.getU8Arr=this.wasmMem.getU8Arr;\n      this.getU32Arr=this.wasmMem.getU32Arr;\n   \n      this.putString=this.wasmMem.putString;\n      this.putU8=this.wasmMem.putU8;\n      this.putArrayBuffer=this.wasmMem.putArrayBuffer;\n\n      // init C runtime\n      const init=this.exports.twr_wasm_init as Function;\n      init(this.ioNamesToID.stdio, this.ioNamesToID.stderr, this.ioNamesToID.std2d==undefined?-1:this.ioNamesToID.std2d, this.wasmMem.mem8.length);\n   }\n   \n   /*********************************************************************/\n\n   // given a url, load its contents, and stuff into Wasm memory similar to Unint8Array\n   // TODO!! Doc that this is no longer a CallC option, and must be called here manually\n   async fetchAndPutURL(fnin:URL):Promise<[number, number]> {\n\n      if (!(typeof fnin === 'object' && fnin instanceof URL))\n         throw new Error(\"fetchAndPutURL param must be URL\");\n\n      try {\n         let response=await fetch(fnin);\n         let buffer = await response.arrayBuffer();\n         let src = new Uint8Array(buffer);\n         let dest=this.wasmMem.putU8(src);\n         return [dest, src.length];\n         \n      } catch(err:any) {\n         console.log('fetchAndPutURL Error. URL: '+fnin+'\\n' + err + (err.stack ? \"\\n\" + err.stack : ''));\n         throw err;\n      }\n   }\n\n   postEvent(eventID:number, ...params:number[]) {\n      //TODO!! PostEvent into eventQueueSend, then processEvents -- to enable non callback events when i add them\n      if (!(eventID in twrEventQueueReceive.onEventCallbacks))\n         throw new Error(\"twrWasmModule.postEvent called with invalid eventID: \"+eventID+\", params: \"+params);\n\n      const onEventCallback=twrEventQueueReceive.onEventCallbacks[eventID];\n      if (onEventCallback) \n         onEventCallback(eventID, ...params);\n      else\n         throw new Error(\"twrWasmModule.postEvent called with undefined callback.  eventID: \"+eventID+\", params: \"+params);\n   }\n\n   peekEvent(eventName:string) {\n      // get earliest inserted entry in event Map\n      //const ev=this.events.get(eventName)\n   }\n  // called (RPC) by twrLibraryProxy\n  // waitEvent(eventName:string) {\n  //    const evIdx=peekTwrEvent(eventName);\n  //    if (evIdx) {\n  //       this.returnValue!.write(evIdx);\n  //    }\n  //    else {\n  //       this.addEventListner(eventName, (evIdx:number)=> {\n  //          this.returnValue!.write(evIdx);\n  //       });\n  //    }\n}\n\n\n\n\n","// This class extends base to handle options when called in the main Java Script thread\nimport { twrConsoleDiv } from \"./twrcondiv.js\";\nimport { twrConsoleCanvas } from \"./twrconcanvas.js\";\nimport { twrConsoleTerminal } from \"./twrconterm.js\";\nimport { twrConsoleDebug } from \"./twrcondebug.js\";\nexport function parseModOptions(opts = {}) {\n    let io;\n    let ioNamesToID;\n    if (typeof document === 'undefined')\n        throw new Error(\"twrWasmModuleJSMain should only be created in JavaScript Main.\");\n    // io contains a mapping of names to IConsole\n    // stdio, stderr are required (but if they are not passed in, we will find defaults here)\n    // there can be an arbitrary number of IConsoles passed to a module for use by the module\n    if (opts.io) {\n        io = opts.io;\n    }\n    else {\n        io = {};\n    }\n    if (!io.stdio) {\n        const eiodiv = document.getElementById(\"twr_iodiv\");\n        const eiocanvas = document.getElementById(\"twr_iocanvas\");\n        if (opts.stdio) {\n            io.stdio = opts.stdio;\n        }\n        else if (eiodiv) {\n            io.stdio = new twrConsoleDiv(eiodiv, { foreColor: opts.forecolor, backColor: opts.backcolor, fontSize: opts.fontsize });\n        }\n        else if (eiocanvas) {\n            io.stdio = new twrConsoleTerminal(eiocanvas, {\n                foreColor: opts.forecolor,\n                backColor: opts.backcolor,\n                fontSize: opts.fontsize,\n                widthInChars: opts.windim?.[0],\n                heightInChars: opts.windim?.[1],\n            });\n        }\n        else {\n            io.stdio = new twrConsoleDebug();\n            console.log(\"Stdio console is not specified.  Using twrConsoleDebug.\");\n        }\n    }\n    if (!io.stderr) {\n        io.stderr = new twrConsoleDebug();\n    }\n    if (!io.std2d) {\n        if (opts.d2dcanvas) {\n            io.std2d = opts.d2dcanvas;\n        }\n        else {\n            const ed2dcanvas = document.getElementById(\"twr_d2dcanvas\");\n            if (ed2dcanvas)\n                io.std2d = new twrConsoleCanvas(ed2dcanvas);\n        }\n    }\n    // each module has a mapping of names to console.id\n    ioNamesToID = {};\n    Object.keys(io).forEach(key => {\n        ioNamesToID[key] = io[key].id;\n    });\n    return [io, ioNamesToID];\n}\n//# sourceMappingURL=twrmodutil.js.map","// This class extends base to handle options when called in the main Java Script thread\n\nimport {IConsole, IConsoleBase, IConsoleStreamOut, IConsoleCanvas} from \"./twrcon.js\"\nimport {twrConsoleDiv} from \"./twrcondiv.js\"\nimport {twrConsoleCanvas} from \"./twrconcanvas.js\"\nimport {twrConsoleTerminal} from \"./twrconterm.js\"\nimport {twrConsoleDebug} from \"./twrcondebug.js\"\nimport {codePageUTF8} from \"./twrliblocale.js\"\n\n\nexport interface IModOpts {\n\tstdio?: IConsoleStreamOut&IConsoleBase,\n   d2dcanvas?: IConsoleCanvas&IConsoleBase,\n\tio?: {[key:string]: IConsole},\n\twindim?:[number, number],\n\tforecolor?:string,\n\tbackcolor?:string,\n\tfontsize?:number,\n\timports?:{},\n}\n\nexport type IParseModOptsResult = [{[key:string]: IConsole}, {[key: string]: number}];\n\nexport function parseModOptions(opts:IModOpts={}):IParseModOptsResult {\n   let io:{[key:string]: IConsole};\n   let ioNamesToID: {[key: string]: number};\n\n   if (typeof document === 'undefined')\n      throw new Error (\"twrWasmModuleJSMain should only be created in JavaScript Main.\");\n\n   // io contains a mapping of names to IConsole\n   // stdio, stderr are required (but if they are not passed in, we will find defaults here)\n   // there can be an arbitrary number of IConsoles passed to a module for use by the module\n   if (opts.io) {\n      io=opts.io;\n   }\n   else {\n      io={};\n   }\n   \n   if (!io.stdio) {\n      const eiodiv=document.getElementById(\"twr_iodiv\") as HTMLDivElement; \n      const eiocanvas=document.getElementById(\"twr_iocanvas\") as HTMLCanvasElement;\n      if (opts.stdio) {\n         io.stdio=opts.stdio;\n      } \n      else if (eiodiv) {\n         io.stdio=new twrConsoleDiv(eiodiv, {foreColor: opts.forecolor, backColor: opts.backcolor, fontSize: opts.fontsize}); \n      }\n      else if (eiocanvas) {\n         io.stdio=new twrConsoleTerminal(eiocanvas, {\n            foreColor: opts.forecolor, \n            backColor: opts.backcolor, \n            fontSize: opts.fontsize, \n            widthInChars: opts.windim?.[0],\n            heightInChars: opts.windim?.[1],\n         }); \n      }\n      else {\n         io.stdio=new twrConsoleDebug();\n         console.log(\"Stdio console is not specified.  Using twrConsoleDebug.\")\n      }\n   }\n\n   if (!io.stderr) {\n      io.stderr=new twrConsoleDebug();\n   }\n\n   if (!io.std2d) {\n      if (opts.d2dcanvas) {\n         io.std2d=opts.d2dcanvas;\n      }  \n      else {\n         const ed2dcanvas=document.getElementById(\"twr_d2dcanvas\") as HTMLCanvasElement;\n         if (ed2dcanvas) io.std2d=new twrConsoleCanvas(ed2dcanvas);\n      }\n   }\n\n   // each module has a mapping of names to console.id\n   ioNamesToID={};\n   Object.keys(io).forEach(key => {\n      ioNamesToID[key]=io[key].id;\n   });\n\n   return [io, ioNamesToID];\n\n}\n\n","import { codePageUTF32, twrCodePageToUnicodeCodePoint } from \"./twrliblocale.js\";\nimport { IOTypes, keyEventToCodePoint } from \"./twrcon.js\";\nimport { twrLibrary, twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\nexport class twrConsoleDiv extends twrLibrary {\n    id;\n    element;\n    CURSOR = String.fromCharCode(9611); // ▋ see https://daniel-hug.github.io/characters/#k_70\n    cursorOn = false;\n    lastChar = 0;\n    extraBR = false;\n    cpTranslate;\n    keyBuffer = [];\n    keyWaiting;\n    imports = {\n        twrConCharOut: { noBlock: true },\n        twrConGetProp: {},\n        twrConPutStr: { noBlock: true },\n        twrConCharIn: { isAsyncFunction: true, isModuleAsyncOnly: true },\n        twrConSetFocus: { noBlock: true },\n    };\n    libSourcePath = new URL(import.meta.url).pathname;\n    interfaceName = \"twrConsole\";\n    constructor(element, params) {\n        // all library constructors should start with these two lines\n        super();\n        this.id = twrLibraryInstanceRegistry.register(this);\n        // twrLibraryProxy will construct with no element or params.\n        // this is triggered by defining a function as isCommonCode.  \n        // Such functions should work with undefined constructor args\n        // TODO!! Doc this issue\n        if (element !== undefined) {\n            this.element = element;\n            if (!(element && element instanceof HTMLDivElement))\n                throw new Error(\"Invalid HTMLDivElement parameter in twrConsoleDiv constructor \");\n            if (params) {\n                if (params.backColor)\n                    this.element.style.backgroundColor = params.backColor;\n                if (params.foreColor)\n                    this.element.style.color = params.foreColor;\n                if (params.fontSize)\n                    this.element.style.font = params.fontSize.toString() + \"px arial\";\n            }\n            this.cpTranslate = new twrCodePageToUnicodeCodePoint();\n        }\n    }\n    isHtmlEntityAtEnd(str) {\n        const entityPattern = /&[^;]+;$/;\n        return entityPattern.test(str);\n    }\n    removeHtmlEntityAtEnd(str) {\n        const entityPattern = /&[^;]+;$/;\n        return str.replace(entityPattern, '');\n    }\n    twrConSetFocus() {\n        if (this.element === undefined)\n            throw new Error(\"undefined HTMLDivElement\");\n        this.element.focus();\n    }\n    charOut(str) {\n        if (str.length > 1)\n            throw new Error(\"charOut takes an empty or single char string\");\n        this.twrConCharOut(undefined, str.codePointAt(0) || 0, codePageUTF32);\n    }\n    /*\n     * add utf-8 or windows-1252 character to div.  Supports the following control codes:\n     * any of CRLF, CR (/r), or LF(/n)  will cause a new line\n     * 0x8 backspace\n     * 0xE cursor on\n     * 0xF cursor off\n    */\n    twrConCharOut(callingMod, ch, codePage) {\n        if (!this.element)\n            throw new Error(\"undefined HTMLDivElement\");\n        if (!this.cpTranslate)\n            throw new Error(\"internal error\");\n        //console.log(\"div::charout: \", ch, codePage);\n        if (this.extraBR) {\n            this.extraBR = false;\n            if (this.cursorOn)\n                this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n            this.element.innerHTML = this.element.innerHTML.slice(0, -4);\n            if (this.cursorOn)\n                this.element.innerHTML += this.CURSOR;\n        }\n        const chnum = this.cpTranslate.convert(ch, codePage);\n        if (chnum != 0) {\n            switch (chnum) {\n                case 10: // newline\n                case 13: // return\n                    if (ch == 10 && this.lastChar == 13)\n                        break; // detect CR LF and treat as single new line\n                    if (this.cursorOn)\n                        this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    this.element.innerHTML += \"<br><br>\"; //2nd break is a place holder for next line (fixes scroll issue at bottom)\n                    this.extraBR = true;\n                    if (this.cursorOn)\n                        this.element.innerHTML += this.CURSOR;\n                    //element.scrollIntoView();\n                    //element.scrollTop = element.scrollHeight;\n                    let p = this.element.getBoundingClientRect();\n                    window.scrollTo(0, p.height + 100);\n                    break;\n                case 8: // backspace\n                    if (this.cursorOn)\n                        this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    if (this.isHtmlEntityAtEnd(this.element.innerHTML))\n                        this.element.innerHTML = this.removeHtmlEntityAtEnd(this.element.innerHTML);\n                    else\n                        this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    if (this.cursorOn)\n                        this.element.innerHTML += this.CURSOR;\n                    break;\n                case 0xE: // cursor on\n                    if (!this.cursorOn) {\n                        this.cursorOn = true;\n                        this.element.innerHTML += this.CURSOR;\n                        this.element.focus();\n                    }\n                    break;\n                case 0xF: // cursor off\n                    if (this.cursorOn) {\n                        this.cursorOn = false;\n                        this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    }\n                    break;\n                default:\n                    if (this.cursorOn)\n                        this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    let newchr = String.fromCodePoint(chnum);\n                    // in html, multiple spaces will be collapsed into one space.  This prevents that behavior.\n                    if (newchr == ' ')\n                        newchr = \"&nbsp;\";\n                    this.element.innerHTML += newchr;\n                    if (this.cursorOn)\n                        this.element.innerHTML += this.CURSOR;\n                    break;\n            }\n            this.lastChar = chnum;\n        }\n    }\n    twrConGetProp(callingMod, pn) {\n        const propName = callingMod.wasmMem.getString(pn);\n        return this.getProp(propName);\n    }\n    getProp(propName) {\n        if (propName === \"type\")\n            return IOTypes.CHARWRITE | IOTypes.CHARREAD;\n        console.log(\"twrConsoleDiv.getProp passed unknown property name: \", propName);\n        return 0;\n    }\n    keyDown(ev) {\n        if (this.keyWaiting) {\n            const r = keyEventToCodePoint(ev);\n            if (r) {\n                this.keyWaiting(r);\n                this.keyWaiting = undefined;\n            }\n        }\n        else {\n            this.keyBuffer.push(ev);\n        }\n    }\n    // TODO!! Should keyBuffer be flushed?  Is keyBuffer needed?\n    async twrConCharIn_async(callingMod) {\n        let ev;\n        return new Promise((resolve) => {\n            if (this.keyWaiting)\n                throw new Error(\"internal error\");\n            while (ev = this.keyBuffer.shift()) {\n                const r = keyEventToCodePoint(ev);\n                if (r) {\n                    resolve(r);\n                    return;\n                }\n            }\n            this.keyWaiting = resolve;\n        });\n    }\n    putStr(str) {\n        for (let i = 0; i < str.length; i++)\n            this.twrConCharOut(undefined, str.codePointAt(i), codePageUTF32);\n    }\n    twrConPutStr(callingMod, chars, codePage) {\n        this.putStr(callingMod.wasmMem.getString(chars, undefined, codePage));\n    }\n}\nexport default twrConsoleDiv;\n//# sourceMappingURL=twrcondiv.js.map","import {codePageUTF32, twrCodePageToUnicodeCodePoint} from \"./twrliblocale.js\"\nimport {IConsoleDiv, IConsoleDivParams, IOTypes,  keyEventToCodePoint} from \"./twrcon.js\"\nimport {IWasmModuleAsync} from \"./twrmodasync.js\";\nimport {IWasmModule} from \"./twrmod.js\"\nimport {twrLibrary, TLibImports, twrLibraryInstanceRegistry} from \"./twrlibrary.js\";\n\nexport class twrConsoleDiv extends twrLibrary implements IConsoleDiv {\n   id:number;\n   element?:HTMLDivElement;\n   CURSOR=String.fromCharCode(9611);  // ▋ see https://daniel-hug.github.io/characters/#k_70\n   cursorOn:boolean=false;\n   lastChar:number=0;\n   extraBR:boolean=false;\n   cpTranslate?:twrCodePageToUnicodeCodePoint;\n   keyBuffer:KeyboardEvent[]=[];\n   keyWaiting?:(key:number)=>void;\n\n   imports:TLibImports = {\n      twrConCharOut:{noBlock:true},\n      twrConGetProp:{},\n      twrConPutStr:{noBlock:true},\n      twrConCharIn:{isAsyncFunction: true, isModuleAsyncOnly: true},\n      twrConSetFocus:{noBlock:true},\n   };\n\n   libSourcePath = new URL(import.meta.url).pathname;\n   interfaceName = \"twrConsole\";\n\n   constructor(element?:HTMLDivElement,  params?:IConsoleDivParams) {\n      // all library constructors should start with these two lines\n      super();\n      this.id=twrLibraryInstanceRegistry.register(this);\n\n      // twrLibraryProxy will construct with no element or params.\n      // this is triggered by defining a function as isCommonCode.  \n      // Such functions should work with undefined constructor args\n      // TODO!! Doc this issue\n      if (element!==undefined) {\n\n         this.element=element;\n\n         if (!(element && element instanceof HTMLDivElement)) \n            throw new Error(\"Invalid HTMLDivElement parameter in twrConsoleDiv constructor \");\n\n         if (params) {\n            if (params.backColor) this.element.style.backgroundColor = params.backColor;\n            if (params.foreColor) this.element.style.color = params.foreColor;\n            if (params.fontSize) this.element.style.font=params.fontSize.toString()+\"px arial\";\n         }\n\n         this.cpTranslate=new twrCodePageToUnicodeCodePoint();\n      }\n   }\n\n   private isHtmlEntityAtEnd(str:string) {\n      const entityPattern = /&[^;]+;$/;\n      return entityPattern.test(str);\n   }\n\n   private removeHtmlEntityAtEnd(str:string) {\n      const entityPattern = /&[^;]+;$/;\n      return str.replace(entityPattern, '');\n   }\n\n   twrConSetFocus() {\n      if (this.element===undefined) throw new Error(\"undefined HTMLDivElement\");\n      this.element.focus();\n   }\n\n   charOut(str:string) {\n      if (str.length>1) \n         throw new Error(\"charOut takes an empty or single char string\");\n\n      this.twrConCharOut(undefined, str.codePointAt(0)||0, codePageUTF32);\n   }\n\n/* \n * add utf-8 or windows-1252 character to div.  Supports the following control codes:\n * any of CRLF, CR (/r), or LF(/n)  will cause a new line\n * 0x8 backspace\n * 0xE cursor on \n * 0xF cursor off \n*/\n   twrConCharOut(callingMod:IWasmModule|IWasmModuleAsync|undefined, ch:number, codePage:number) {\n\n      if (!this.element) throw new Error(\"undefined HTMLDivElement\");\n      if (!this.cpTranslate) throw new Error(\"internal error\");\n\n      //console.log(\"div::charout: \", ch, codePage);\n\n      if (this.extraBR) {\n         this.extraBR=false;\n         if (this.cursorOn) this.element.innerHTML=this.element.innerHTML.slice(0, -1);\n         this.element.innerHTML=this.element.innerHTML.slice(0, -4);\n         if (this.cursorOn) this.element.innerHTML +=  this.CURSOR;\n      }\n\n      const chnum=this.cpTranslate.convert(ch, codePage);\n      if (chnum!=0) {\n         switch (chnum) {\n            case 10:  // newline\n            case 13:  // return\n               if (ch==10 && this.lastChar==13) break;  // detect CR LF and treat as single new line\n               if (this.cursorOn) this.element.innerHTML=this.element.innerHTML.slice(0, -1);\n               this.element.innerHTML +=  \"<br><br>\";   //2nd break is a place holder for next line (fixes scroll issue at bottom)\n               this.extraBR=true;\n               if (this.cursorOn) this.element.innerHTML +=  this.CURSOR;\n               //element.scrollIntoView();\n               //element.scrollTop = element.scrollHeight;\n               let p = this.element.getBoundingClientRect();\n               window.scrollTo(0, p.height+100);\n               break;\n\n            case 8:  // backspace\n               if (this.cursorOn) this.element.innerHTML=this.element.innerHTML.slice(0, -1);\n               if (this.isHtmlEntityAtEnd(this.element.innerHTML)) \n                  this.element.innerHTML=this.removeHtmlEntityAtEnd(this.element.innerHTML);\n               else\n                  this.element.innerHTML=this.element.innerHTML.slice(0, -1);\n               if (this.cursorOn) this.element.innerHTML +=  this.CURSOR;\n               break;\n\n            case 0xE:   // cursor on\n               if (!this.cursorOn) {\n                  this.cursorOn=true;\n                  this.element.innerHTML +=  this.CURSOR;\n                  this.element.focus();\n               }\n               break;\n\n            case 0xF:   // cursor off\n               if (this.cursorOn) {\n                  this.cursorOn=false;\n                  this.element.innerHTML=this.element.innerHTML.slice(0, -1);\n               }\n               break;\n            default:\n               if (this.cursorOn) this.element.innerHTML=this.element.innerHTML.slice(0, -1);\n               let newchr=String.fromCodePoint(chnum);\n               // in html, multiple spaces will be collapsed into one space.  This prevents that behavior.\n               if (newchr==' ') newchr=\"&nbsp;\";\n               this.element.innerHTML += newchr;\n               if (this.cursorOn) this.element.innerHTML +=  this.CURSOR;\n               break;\n            }\n\n         this.lastChar=chnum;\n      }\n   }\n\n   twrConGetProp(callingMod:IWasmModule|IWasmModuleAsync, pn:number):number {\n      const propName=callingMod.wasmMem.getString(pn);\n      return this.getProp(propName);\n   }\n\n   getProp(propName: string):number {\n      if (propName===\"type\") return IOTypes.CHARWRITE|IOTypes.CHARREAD;\n      console.log(\"twrConsoleDiv.getProp passed unknown property name: \", propName)\n      return 0;\n   }\n\n   keyDown(ev:KeyboardEvent)  {\n      if (this.keyWaiting) {\n         const r=keyEventToCodePoint(ev);\n         if (r) {\n            this.keyWaiting(r);\n            this.keyWaiting=undefined;\n         }\n      }\n      else {\n         this.keyBuffer.push(ev);\n      }\n   }\n\n   // TODO!! Should keyBuffer be flushed?  Is keyBuffer needed?\n   async twrConCharIn_async(callingMod: IWasmModuleAsync):Promise<number> {\n      let ev:KeyboardEvent|undefined;\n\n      return new Promise( (resolve) => {\n         if (this.keyWaiting)\n            throw new Error(\"internal error\");\n         while (ev=this.keyBuffer.shift()) {\n            const r=keyEventToCodePoint(ev);\n            if (r) {\n               resolve(r);\n               return;\n            }\n         }\n\n         this.keyWaiting=resolve;\n\n      });\n   }\n\n   putStr(str:string) {\n      for (let i=0; i < str.length; i++)\n         this.twrConCharOut(undefined, str.codePointAt(i)!, codePageUTF32);\n   }\n\n   twrConPutStr(callingMod:IWasmModule|IWasmModuleAsync,  chars:number, codePage:number) {\n      this.putStr(callingMod.wasmMem.getString(chars, undefined, codePage));\n   }\n\n}\n\nexport default twrConsoleDiv;\n","//TODO:\n// add io_get_type?\n// i can't figure out how to have this param be a keyof instead of string, with separate params for Stream and Terminal:  getProp: (propName: string)=>number;\n// change printf, and other optimizations if they exist, to call io_putstr\n// implement or deprecate io_begin_draw \n// remove from IModParams: imports:{[index:string]:Function},\n// implement \t//\tIModOpts.imports in twrWasmModuleInJSMain\n// add ability to determine if a console has the input focus\n// remove support for io:{[key:string]: IConsole};\n// add codepage as arg to charout.io_putc to make it more flexible and to align with how setc32 works in io_functions\n// add ability to set a max size for a div con, or to trim it.\n// add helloworld-b to index.html?\n// finish inkey\n// add io_setrange example/test case\n// get rid of this.io and just use ioIDtoNames?\n// add ability to use string colors in io_functions and terminal?\n// add io_get/set_colors support for div console\n// must match IO_TYPEs in twr_io.h\nexport class IOTypes {\n    static CHARREAD = (1 << 0); // Stream In\n    static CHARWRITE = (1 << 1); // Stream Out\n    static ADDRESSABLE_DISPLAY = (1 << 2); // IoDisplay is enabled\n    static CANVAS2D = (1 << 3); // unimplemented yet\n    static EVENTS = (1 << 4); // unimplemented yet\n    // Private constructor to prevent instantiation\n    constructor() { }\n}\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\nexport function keyEventToCodePoint(ev) {\n    if (!ev.isComposing && !ev.metaKey && ev.key != \"Control\" && ev.key != \"Alt\") {\n        //console.log(\"keyDownDiv: \",ev.key, ev.code, ev.key.codePointAt(0), ev);\n        if (ev.key.length == 1)\n            return ev.key.codePointAt(0);\n        else {\n            switch (ev.key) {\n                case 'Backspace': return 8;\n                case 'Enter': return 10;\n                case 'Escape': return 0x1B;\n                case 'Delete': return 0x7F;\n                case 'ArrowLeft': return 0x2190;\n                case 'ArrowUp': return 0x2191;\n                case 'ArrowRight': return 0x2192;\n                case 'ArrowDown': return 0x2193;\n            }\n            console.log(\"keyEventProcess SKIPPED: \", ev.key, ev.code, ev.key.codePointAt(0), ev);\n        }\n    }\n    else {\n        console.log(\"keyEventProcess SKIPPED-2: \", ev.key, ev.code, ev.key.codePointAt(0), ev);\n    }\n    return undefined;\n}\nexport function logToCon(con, ...params) {\n    for (var i = 0; i < params.length; i++) {\n        con.putStr(params[i].toString());\n        con.charOut(' '); // space\n    }\n    con.charOut('\\n');\n}\n//# sourceMappingURL=twrcon.js.map","//TODO:\n// add io_get_type?\n// i can't figure out how to have this param be a keyof instead of string, with separate params for Stream and Terminal:  getProp: (propName: string)=>number;\n// change printf, and other optimizations if they exist, to call io_putstr\n// implement or deprecate io_begin_draw \n// remove from IModParams: imports:{[index:string]:Function},\n// implement \t//\tIModOpts.imports in twrWasmModuleInJSMain\n// add ability to determine if a console has the input focus\n// remove support for io:{[key:string]: IConsole};\n// add codepage as arg to charout.io_putc to make it more flexible and to align with how setc32 works in io_functions\n// add ability to set a max size for a div con, or to trim it.\n// add helloworld-b to index.html?\n// finish inkey\n// add io_setrange example/test case\n// get rid of this.io and just use ioIDtoNames?\n// add ability to use string colors in io_functions and terminal?\n// add io_get/set_colors support for div console\n\nimport {IWasmModuleAsync} from \"./twrmodasync.js\";\nimport {IWasmModule} from \"./twrmod.js\";\n\n// Params are passed to the console constructor\nexport interface IConsoleDivParams {\n   foreColor?: string,\n   backColor?: string,\n   fontSize?: number,\n}\n\nexport interface IConsoleTerminalParams extends IConsoleDivParams {\n   widthInChars?: number,\n   heightInChars?: number,\n}\n\n// Props of a console can be queried with getProp\nexport interface IConsoleBaseProps {\n   type: number,   // a constant from class IOTypes\n   [key: string]: number;  // required because I access with a string. \n}\n\nexport interface IConsoleTerminalProps extends IConsoleBaseProps {\n   cursorPos:number,\n   charWidth: number,\n   charHeight: number,\n   foreColorAsRGB: number,\n   backColorAsRGB: number,\n   widthInChars: number,\n   heightInChars: number,\n   fontSize: number,\n   canvasWidth:number,\n   canvasHeight:number\n}\n\nexport interface ICanvasProps extends IConsoleBaseProps{\n   canvasWidth:number,\n   canvasHeight:number\n}\n\n// Interface for Consoles\nexport interface IConsoleBase {\n   getProp: (propName: string)=>number;\n   twrConGetProp: (callingMod:IWasmModule|IWasmModuleAsync, pn:number)=>number;\n\n\tid:number;  \n   element?:HTMLElement;   // debug console does not have an element\n}\n\nexport interface IConsoleStreamOut {\n   twrConCharOut: (callingMod:IWasmModule|IWasmModuleAsync, c:number, codePage:number)=>void;\n   twrConPutStr: (callingMod:IWasmModule|IWasmModuleAsync,  chars:number, codePage:number)=>void;\n   charOut: (ch:string)=>void;\n   putStr: (str:string)=>void;\n}\n\nexport interface IConsoleStreamIn {\n   twrConCharIn_async: (callingMod:IWasmModuleAsync)=>Promise<number>;\n\ttwrConSetFocus: (callingMod:IWasmModuleAsync)=>void;\n\n   //this should be called by JSMain thread to inject key events\n\tkeyDown: (ev:KeyboardEvent)=>void;\n}\n\nexport interface IConsoleAddressable {\n   twrConCls: (callingMod:IWasmModule|IWasmModuleAsync)=>void;\n   setRangeJS: (start:number, values:[])=>void;\n   twrConSetRange: (callingMod:IWasmModule|IWasmModuleAsync, chars:number, start:number, len:number)=>void;\n   twrConSetC32: (callingMod:IWasmModule|IWasmModuleAsync, location:number, char:number)=>void;\n   twrConSetReset: (callingMod:IWasmModule|IWasmModuleAsync,x:number, y:number, isset:boolean)=>void;\n   twrConPoint: (callingMod:IWasmModule|IWasmModuleAsync, x:number, y:number)=>boolean;\n   twrConSetCursor: (callingMod:IWasmModule|IWasmModuleAsync, pos:number)=>void;\n   twrConSetCursorXY: (callingMod:IWasmModule|IWasmModuleAsync, x:number, y:number)=>void;\n   twrConSetColors: (callingMod:IWasmModule|IWasmModuleAsync, foreground:number, background:number)=>void;\n}\n\nexport interface IConsoleDrawable {\n    twrConDrawSeq: (mod:IWasmModuleAsync|IWasmModule, ds:number)=>void,\n    twrConLoadImage_async: (mod:IWasmModuleAsync, urlPtr: number, id: number)=>Promise<number>,\n   }\n\nexport interface IConsoleTerminal extends IConsoleBase, IConsoleStreamOut, IConsoleStreamIn, IConsoleAddressable {}\nexport interface IConsoleDiv extends IConsoleBase, IConsoleStreamOut, IConsoleStreamIn {}\nexport interface IConsoleDebug extends IConsoleBase, IConsoleStreamOut {}\nexport interface IConsoleCanvas extends IConsoleBase, IConsoleDrawable {}\n\nexport interface IConsole extends IConsoleBase, Partial<IConsoleStreamOut>, Partial<IConsoleStreamIn>, Partial<IConsoleAddressable>, Partial<IConsoleDrawable> {}\n\n\n// must match IO_TYPEs in twr_io.h\nexport class IOTypes {\n   static readonly  CHARREAD = (1<<0);  // Stream In\n   static readonly  CHARWRITE = (1<<1);  // Stream Out\n   static readonly  ADDRESSABLE_DISPLAY = (1<<2);  \t// IoDisplay is enabled\n   static readonly  CANVAS2D = (1<<3);   // unimplemented yet\n   static readonly  EVENTS = (1<<4);  // unimplemented yet\n\n  // Private constructor to prevent instantiation\n  private constructor() {}\n}\n\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n\nexport function keyEventToCodePoint(ev:KeyboardEvent) {\n\tif ( !ev.isComposing  && !ev.metaKey && ev.key!=\"Control\" && ev.key!=\"Alt\" ) {\n\t\t//console.log(\"keyDownDiv: \",ev.key, ev.code, ev.key.codePointAt(0), ev);\n\t\tif (ev.key.length==1)\n\t\t\treturn ev.key.codePointAt(0);\n\t\telse {\n\t\t\tswitch(ev.key) {\n\t\t\t\tcase 'Backspace': return 8;\n\t\t\t\tcase 'Enter': \t\treturn 10;\n\t\t\t\tcase 'Escape': \treturn 0x1B;\n\t\t\t\tcase 'Delete': \treturn 0x7F;\n\t\t\t\tcase 'ArrowLeft':\treturn 0x2190;\n\t\t\t\tcase 'ArrowUp':\treturn 0x2191;\n\t\t\t\tcase 'ArrowRight':return 0x2192;\n\t\t\t\tcase 'ArrowDown':\treturn 0x2193;\n\t\t\t}\n\t\t\tconsole.log(\"keyEventProcess SKIPPED: \",ev.key, ev.code, ev.key.codePointAt(0), ev);\n\t\t}\n\t}\n\telse {\n\t\tconsole.log(\"keyEventProcess SKIPPED-2: \",ev.key, ev.code, ev.key.codePointAt(0), ev);\n\t}\n\n\treturn undefined;\n}\n\nexport function logToCon(con:IConsole, ...params: string[]) {\n   for (var i = 0; i < params.length; i++) {\n      con.putStr!(params[i].toString());\n      con.charOut!(' '); // space\n   }\n   con.charOut!('\\n');\n}\n\n","import { IOTypes } from \"./twrcon.js\";\nimport { twrLibrary, twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\nvar D2DType;\n(function (D2DType) {\n    D2DType[D2DType[\"D2D_FILLRECT\"] = 1] = \"D2D_FILLRECT\";\n    D2DType[D2DType[\"D2D_FILLCODEPOINT\"] = 5] = \"D2D_FILLCODEPOINT\";\n    D2DType[D2DType[\"D2D_SETLINEWIDTH\"] = 10] = \"D2D_SETLINEWIDTH\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLERGBA\"] = 11] = \"D2D_SETFILLSTYLERGBA\";\n    D2DType[D2DType[\"D2D_SETFONT\"] = 12] = \"D2D_SETFONT\";\n    D2DType[D2DType[\"D2D_BEGINPATH\"] = 13] = \"D2D_BEGINPATH\";\n    D2DType[D2DType[\"D2D_MOVETO\"] = 14] = \"D2D_MOVETO\";\n    D2DType[D2DType[\"D2D_LINETO\"] = 15] = \"D2D_LINETO\";\n    D2DType[D2DType[\"D2D_FILL\"] = 16] = \"D2D_FILL\";\n    D2DType[D2DType[\"D2D_STROKE\"] = 17] = \"D2D_STROKE\";\n    D2DType[D2DType[\"D2D_SETSTROKESTYLERGBA\"] = 18] = \"D2D_SETSTROKESTYLERGBA\";\n    D2DType[D2DType[\"D2D_ARC\"] = 19] = \"D2D_ARC\";\n    D2DType[D2DType[\"D2D_STROKERECT\"] = 20] = \"D2D_STROKERECT\";\n    D2DType[D2DType[\"D2D_FILLTEXT\"] = 21] = \"D2D_FILLTEXT\";\n    D2DType[D2DType[\"D2D_IMAGEDATA\"] = 22] = \"D2D_IMAGEDATA\";\n    D2DType[D2DType[\"D2D_PUTIMAGEDATA\"] = 23] = \"D2D_PUTIMAGEDATA\";\n    D2DType[D2DType[\"D2D_BEZIERTO\"] = 24] = \"D2D_BEZIERTO\";\n    D2DType[D2DType[\"D2D_MEASURETEXT\"] = 25] = \"D2D_MEASURETEXT\";\n    D2DType[D2DType[\"D2D_SAVE\"] = 26] = \"D2D_SAVE\";\n    D2DType[D2DType[\"D2D_RESTORE\"] = 27] = \"D2D_RESTORE\";\n    D2DType[D2DType[\"D2D_CREATERADIALGRADIENT\"] = 28] = \"D2D_CREATERADIALGRADIENT\";\n    D2DType[D2DType[\"D2D_SETCOLORSTOP\"] = 29] = \"D2D_SETCOLORSTOP\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLEGRADIENT\"] = 30] = \"D2D_SETFILLSTYLEGRADIENT\";\n    D2DType[D2DType[\"D2D_RELEASEID\"] = 31] = \"D2D_RELEASEID\";\n    D2DType[D2DType[\"D2D_CREATELINEARGRADIENT\"] = 32] = \"D2D_CREATELINEARGRADIENT\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLE\"] = 33] = \"D2D_SETFILLSTYLE\";\n    D2DType[D2DType[\"D2D_SETSTROKESTYLE\"] = 34] = \"D2D_SETSTROKESTYLE\";\n    D2DType[D2DType[\"D2D_CLOSEPATH\"] = 35] = \"D2D_CLOSEPATH\";\n    D2DType[D2DType[\"D2D_RESET\"] = 36] = \"D2D_RESET\";\n    D2DType[D2DType[\"D2D_CLEARRECT\"] = 37] = \"D2D_CLEARRECT\";\n    D2DType[D2DType[\"D2D_SCALE\"] = 38] = \"D2D_SCALE\";\n    D2DType[D2DType[\"D2D_TRANSLATE\"] = 39] = \"D2D_TRANSLATE\";\n    D2DType[D2DType[\"D2D_ROTATE\"] = 40] = \"D2D_ROTATE\";\n    D2DType[D2DType[\"D2D_GETTRANSFORM\"] = 41] = \"D2D_GETTRANSFORM\";\n    D2DType[D2DType[\"D2D_SETTRANSFORM\"] = 42] = \"D2D_SETTRANSFORM\";\n    D2DType[D2DType[\"D2D_RESETTRANSFORM\"] = 43] = \"D2D_RESETTRANSFORM\";\n    D2DType[D2DType[\"D2D_STROKETEXT\"] = 44] = \"D2D_STROKETEXT\";\n    D2DType[D2DType[\"D2D_ROUNDRECT\"] = 45] = \"D2D_ROUNDRECT\";\n    D2DType[D2DType[\"D2D_ELLIPSE\"] = 46] = \"D2D_ELLIPSE\";\n    D2DType[D2DType[\"D2D_QUADRATICCURVETO\"] = 47] = \"D2D_QUADRATICCURVETO\";\n    D2DType[D2DType[\"D2D_SETLINEDASH\"] = 48] = \"D2D_SETLINEDASH\";\n    D2DType[D2DType[\"D2D_GETLINEDASH\"] = 49] = \"D2D_GETLINEDASH\";\n    D2DType[D2DType[\"D2D_ARCTO\"] = 50] = \"D2D_ARCTO\";\n    D2DType[D2DType[\"D2D_GETLINEDASHLENGTH\"] = 51] = \"D2D_GETLINEDASHLENGTH\";\n    D2DType[D2DType[\"D2D_DRAWIMAGE\"] = 52] = \"D2D_DRAWIMAGE\";\n    D2DType[D2DType[\"D2D_RECT\"] = 53] = \"D2D_RECT\";\n    D2DType[D2DType[\"D2D_TRANSFORM\"] = 54] = \"D2D_TRANSFORM\";\n    D2DType[D2DType[\"D2D_SETLINECAP\"] = 55] = \"D2D_SETLINECAP\";\n    D2DType[D2DType[\"D2D_SETLINEJOIN\"] = 56] = \"D2D_SETLINEJOIN\";\n    D2DType[D2DType[\"D2D_SETLINEDASHOFFSET\"] = 57] = \"D2D_SETLINEDASHOFFSET\";\n    D2DType[D2DType[\"D2D_GETIMAGEDATA\"] = 58] = \"D2D_GETIMAGEDATA\";\n    D2DType[D2DType[\"D2D_IMAGEDATATOC\"] = 59] = \"D2D_IMAGEDATATOC\";\n    D2DType[D2DType[\"D2D_GETCANVASPROPDOUBLE\"] = 60] = \"D2D_GETCANVASPROPDOUBLE\";\n    D2DType[D2DType[\"D2D_GETCANVASPROPSTRING\"] = 61] = \"D2D_GETCANVASPROPSTRING\";\n    D2DType[D2DType[\"D2D_SETCANVASPROPDOUBLE\"] = 62] = \"D2D_SETCANVASPROPDOUBLE\";\n    D2DType[D2DType[\"D2D_SETCANVASPROPSTRING\"] = 63] = \"D2D_SETCANVASPROPSTRING\";\n})(D2DType || (D2DType = {}));\nexport class twrConsoleCanvas extends twrLibrary {\n    id;\n    ctx;\n    element;\n    props;\n    //TODO!! BUG - precomputed objects should be unique for each module that using this twrConsoleCanvas\n    precomputedObjects;\n    imports = {\n        twrConGetProp: {},\n        twrConDrawSeq: {},\n        twrConLoadImage: { isModuleAsyncOnly: true, isAsyncFunction: true },\n    };\n    libSourcePath = new URL(import.meta.url).pathname;\n    interfaceName = \"twrConsole\";\n    constructor(element) {\n        // all library constructors should start with these two lines\n        super();\n        this.id = twrLibraryInstanceRegistry.register(this);\n        this.precomputedObjects = {};\n        if (!(element && element instanceof HTMLCanvasElement && element.getContext))\n            throw new Error(\"Invalid HTMLCanvasElement parameter in twrConsoleCanvas constructor \");\n        this.element = element;\n        const c = element.getContext(\"2d\");\n        if (!c)\n            throw new Error(\"Canvas 2D context not found.\");\n        this.ctx = c;\n        // these two lines are for backwards compatibility with prior version of twr-wasm\n        c.font = \"16 px Courier New\";\n        c.textBaseline = \"top\";\n        this.props = { canvasHeight: element.height, canvasWidth: element.width, type: IOTypes.CANVAS2D };\n    }\n    getProp(name) {\n        return this.props[name];\n    }\n    twrConGetProp(callingMod, pn) {\n        const propName = callingMod.wasmMem.getString(pn);\n        return this.getProp(propName);\n    }\n    twrConLoadImage_async(mod, urlPtr, id) {\n        return new Promise((resolve) => {\n            const url = mod.wasmMem.getString(urlPtr);\n            if (id in this.precomputedObjects)\n                console.log(\"warning: D2D_LOADIMAGE ID already exists.\");\n            const img = new Image();\n            img.onload = () => {\n                resolve(1);\n            };\n            img.onerror = () => {\n                console.log(\"Warning: D2D_LOADIMAGE: failed to load image \" + url);\n                resolve(1);\n            };\n            img.src = url;\n            this.precomputedObjects[id] = img;\n        });\n    }\n    /* see draw2d.h for structs that match */\n    twrConDrawSeq(mod, ds) {\n        //console.log(\"twr::Canvas enter drawSeq\");\n        if (!this.ctx)\n            return;\n        const wasmMem = mod.wasmMem;\n        const insHdrSize = 16;\n        let currentInsHdr = wasmMem.getLong(ds); /* ds->start */\n        const lastInsHdr = wasmMem.getLong(ds + 4); /* ds->last */\n        let currentInsParams = currentInsHdr + insHdrSize;\n        //console.log(\"instruction start, last \",ins.toString(16), lastins.toString(16));\n        let nextInsHdr;\n        //let insCount=0;\n        while (1) {\n            //insCount++;\n            const type = wasmMem.getLong(currentInsHdr + 4); /* hdr->type */\n            if (0 /*type!=D2DType.D2D_FILLRECT*/) {\n                console.log(\"ins\", currentInsHdr);\n                console.log(\"hdr.next\", wasmMem.mem8[currentInsHdr], wasmMem.mem8[currentInsHdr + 1], wasmMem.mem8[currentInsHdr + 2], wasmMem.mem8[currentInsHdr + 3]);\n                console.log(\"hdr.type\", wasmMem.mem8[currentInsHdr + 4], wasmMem.mem8[currentInsHdr + 5]);\n                console.log(\"next 4 bytes\", wasmMem.mem8[currentInsHdr + 6], wasmMem.mem8[currentInsHdr + 7], wasmMem.mem8[currentInsHdr + 8], wasmMem.mem8[currentInsHdr + 9]);\n                console.log(\"and 4 more \", wasmMem.mem8[currentInsHdr + 10], wasmMem.mem8[currentInsHdr + 11], wasmMem.mem8[currentInsHdr + 12], wasmMem.mem8[currentInsHdr + 13]);\n                //console.log(\"ins, type, next is \", ins.toString(16), type.toString(16), next.toString(16));\n            }\n            switch (type) {\n                case D2DType.D2D_FILLRECT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const w = wasmMem.getDouble(currentInsParams + 16);\n                        const h = wasmMem.getDouble(currentInsParams + 24);\n                        this.ctx.fillRect(x, y, w, h);\n                    }\n                    break;\n                case D2DType.D2D_STROKERECT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const w = wasmMem.getDouble(currentInsParams + 16);\n                        const h = wasmMem.getDouble(currentInsParams + 24);\n                        this.ctx.strokeRect(x, y, w, h);\n                    }\n                    break;\n                case D2DType.D2D_FILLCODEPOINT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const c = wasmMem.getLong(currentInsParams + 16);\n                        let txt = String.fromCodePoint(c);\n                        this.ctx.fillText(txt, x, y);\n                    }\n                    break;\n                case D2DType.D2D_FILLTEXT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const codePage = wasmMem.getLong(currentInsParams + 20);\n                        const strPointer = wasmMem.getLong(currentInsParams + 16);\n                        const str = wasmMem.getString(strPointer, undefined, codePage);\n                        //console.log(\"filltext \",x,y,str)\n                        this.ctx.fillText(str, x, y);\n                    }\n                    break;\n                case D2DType.D2D_MEASURETEXT:\n                    {\n                        const codePage = wasmMem.getLong(currentInsParams + 8);\n                        const str = wasmMem.getString(wasmMem.getLong(currentInsParams), undefined, codePage);\n                        const tmidx = wasmMem.getLong(currentInsParams + 4);\n                        const tm = this.ctx.measureText(str);\n                        wasmMem.setDouble(tmidx + 0, tm.actualBoundingBoxAscent);\n                        wasmMem.setDouble(tmidx + 8, tm.actualBoundingBoxDescent);\n                        wasmMem.setDouble(tmidx + 16, tm.actualBoundingBoxLeft);\n                        wasmMem.setDouble(tmidx + 24, tm.actualBoundingBoxRight);\n                        wasmMem.setDouble(tmidx + 32, tm.fontBoundingBoxAscent);\n                        wasmMem.setDouble(tmidx + 40, tm.fontBoundingBoxDescent);\n                        wasmMem.setDouble(tmidx + 48, tm.width);\n                    }\n                    break;\n                case D2DType.D2D_SETFONT:\n                    {\n                        const fontPointer = wasmMem.getLong(currentInsParams);\n                        const str = wasmMem.getString(fontPointer);\n                        this.ctx.font = str;\n                    }\n                    break;\n                case D2DType.D2D_SETFILLSTYLERGBA:\n                    {\n                        const color = wasmMem.getLong(currentInsParams);\n                        const cssColor = \"#\" + (\"00000000\" + color.toString(16)).slice(-8);\n                        this.ctx.fillStyle = cssColor;\n                        //console.log(\"fillstyle: \", this.ctx.fillStyle, \":\", cssColor,\":\", color)\n                    }\n                    break;\n                case D2DType.D2D_SETSTROKESTYLERGBA:\n                    {\n                        const color = wasmMem.getLong(currentInsParams);\n                        const cssColor = \"#\" + (\"00000000\" + color.toString(16)).slice(-8);\n                        this.ctx.strokeStyle = cssColor;\n                    }\n                    break;\n                case D2DType.D2D_SETFILLSTYLE:\n                    {\n                        const cssColorPointer = wasmMem.getLong(currentInsParams);\n                        const cssColor = wasmMem.getString(cssColorPointer);\n                        this.ctx.fillStyle = cssColor;\n                    }\n                    break;\n                case D2DType.D2D_SETSTROKESTYLE:\n                    {\n                        const cssColorPointer = wasmMem.getLong(currentInsParams);\n                        const cssColor = wasmMem.getString(cssColorPointer);\n                        this.ctx.strokeStyle = cssColor;\n                    }\n                    break;\n                case D2DType.D2D_SETLINEWIDTH:\n                    {\n                        const width = wasmMem.getDouble(currentInsParams);\n                        this.ctx.lineWidth = width;\n                        //console.log(\"twrCanvas D2D_SETLINEWIDTH: \", this.ctx.lineWidth);\n                    }\n                    break;\n                case D2DType.D2D_MOVETO:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        this.ctx.moveTo(x, y);\n                    }\n                    break;\n                case D2DType.D2D_LINETO:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        this.ctx.lineTo(x, y);\n                    }\n                    break;\n                case D2DType.D2D_BEZIERTO:\n                    {\n                        const cp1x = wasmMem.getDouble(currentInsParams);\n                        const cp1y = wasmMem.getDouble(currentInsParams + 8);\n                        const cp2x = wasmMem.getDouble(currentInsParams + 16);\n                        const cp2y = wasmMem.getDouble(currentInsParams + 24);\n                        const x = wasmMem.getDouble(currentInsParams + 32);\n                        const y = wasmMem.getDouble(currentInsParams + 40);\n                        this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n                    }\n                    break;\n                case D2DType.D2D_BEGINPATH:\n                    {\n                        this.ctx.beginPath();\n                    }\n                    break;\n                case D2DType.D2D_FILL:\n                    {\n                        this.ctx.fill();\n                    }\n                    break;\n                case D2DType.D2D_SAVE:\n                    {\n                        this.ctx.save();\n                    }\n                    break;\n                case D2DType.D2D_RESTORE:\n                    {\n                        this.ctx.restore();\n                    }\n                    break;\n                case D2DType.D2D_STROKE:\n                    {\n                        this.ctx.stroke();\n                    }\n                    break;\n                case D2DType.D2D_ARC:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const radius = wasmMem.getDouble(currentInsParams + 16);\n                        const startAngle = wasmMem.getDouble(currentInsParams + 24);\n                        const endAngle = wasmMem.getDouble(currentInsParams + 32);\n                        const counterClockwise = (wasmMem.getLong(currentInsParams + 40) != 0);\n                        this.ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise);\n                    }\n                    break;\n                case D2DType.D2D_IMAGEDATA:\n                    {\n                        const start = wasmMem.getLong(currentInsParams);\n                        const length = wasmMem.getLong(currentInsParams + 4);\n                        const width = wasmMem.getLong(currentInsParams + 8);\n                        const height = wasmMem.getLong(currentInsParams + 12);\n                        const id = wasmMem.getLong(currentInsParams + 16);\n                        if (id in this.precomputedObjects)\n                            console.log(\"warning: D2D_IMAGEDATA ID already exists.\");\n                        if (mod.isTwrWasmModuleAsync) { // Uint8ClampedArray doesn't support shared memory\n                            this.precomputedObjects[id] = { mem8: new Uint8Array(wasmMem.memory.buffer, start, length), width: width, height: height };\n                        }\n                        else {\n                            const z = new Uint8ClampedArray(wasmMem.memory.buffer, start, length);\n                            this.precomputedObjects[id] = new ImageData(z, width, height);\n                        }\n                    }\n                    break;\n                case D2DType.D2D_CREATERADIALGRADIENT:\n                    {\n                        const x0 = wasmMem.getDouble(currentInsParams);\n                        const y0 = wasmMem.getDouble(currentInsParams + 8);\n                        const radius0 = wasmMem.getDouble(currentInsParams + 16);\n                        const x1 = wasmMem.getDouble(currentInsParams + 24);\n                        const y1 = wasmMem.getDouble(currentInsParams + 32);\n                        const radius1 = wasmMem.getDouble(currentInsParams + 40);\n                        const id = wasmMem.getLong(currentInsParams + 48);\n                        let gradient = this.ctx.createRadialGradient(x0, y0, radius0, x1, y1, radius1);\n                        if (id in this.precomputedObjects)\n                            console.log(\"warning: D2D_CREATERADIALGRADIENT ID already exists.\");\n                        this.precomputedObjects[id] = gradient;\n                    }\n                    break;\n                case D2DType.D2D_CREATELINEARGRADIENT:\n                    {\n                        const x0 = wasmMem.getDouble(currentInsParams);\n                        const y0 = wasmMem.getDouble(currentInsParams + 8);\n                        const x1 = wasmMem.getDouble(currentInsParams + 16);\n                        const y1 = wasmMem.getDouble(currentInsParams + 24);\n                        const id = wasmMem.getLong(currentInsParams + 32);\n                        let gradient = this.ctx.createLinearGradient(x0, y0, x1, y1);\n                        if (id in this.precomputedObjects)\n                            console.log(\"warning: D2D_CREATELINEARGRADIENT ID already exists.\");\n                        this.precomputedObjects[id] = gradient;\n                    }\n                    break;\n                case D2DType.D2D_SETCOLORSTOP:\n                    {\n                        const id = wasmMem.getLong(currentInsParams);\n                        const pos = wasmMem.getLong(currentInsParams + 4);\n                        const cssColorPointer = wasmMem.getLong(currentInsParams + 8);\n                        const cssColor = wasmMem.getString(cssColorPointer);\n                        if (!(id in this.precomputedObjects))\n                            throw new Error(\"D2D_SETCOLORSTOP with invalid ID: \" + id);\n                        const gradient = this.precomputedObjects[id];\n                        gradient.addColorStop(pos, cssColor);\n                    }\n                    break;\n                case D2DType.D2D_SETFILLSTYLEGRADIENT:\n                    {\n                        const id = wasmMem.getLong(currentInsParams);\n                        if (!(id in this.precomputedObjects))\n                            throw new Error(\"D2D_SETFILLSTYLEGRADIENT with invalid ID: \" + id);\n                        const gradient = this.precomputedObjects[id];\n                        this.ctx.fillStyle = gradient;\n                    }\n                    break;\n                case D2DType.D2D_RELEASEID:\n                    {\n                        const id = wasmMem.getLong(currentInsParams);\n                        if (this.precomputedObjects[id])\n                            delete this.precomputedObjects[id];\n                        else\n                            console.log(\"warning: D2D_RELEASEID with undefined ID \", id);\n                    }\n                    break;\n                case D2DType.D2D_PUTIMAGEDATA:\n                    {\n                        const id = wasmMem.getLong(currentInsParams);\n                        const dx = wasmMem.getLong(currentInsParams + 4);\n                        const dy = wasmMem.getLong(currentInsParams + 8);\n                        const dirtyX = wasmMem.getLong(currentInsParams + 12);\n                        const dirtyY = wasmMem.getLong(currentInsParams + 16);\n                        const dirtyWidth = wasmMem.getLong(currentInsParams + 20);\n                        const dirtyHeight = wasmMem.getLong(currentInsParams + 24);\n                        if (!(id in this.precomputedObjects))\n                            throw new Error(\"D2D_PUTIMAGEDATA with invalid ID: \" + id);\n                        //console.log(\"D2D_PUTIMAGEDATA\",start, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight, this.imageData[start]);\n                        let imgData;\n                        if (mod.isTwrWasmModuleAsync) { // Uint8ClampedArray doesn't support shared memory, so copy the memory\n                            //console.log(\"D2D_PUTIMAGEDATA wasmModuleAsync\");\n                            const z = this.precomputedObjects[id]; // Uint8Array\n                            const ca = Uint8ClampedArray.from(z.mem8); // shallow copy\n                            imgData = new ImageData(ca, z.width, z.height);\n                        }\n                        else {\n                            imgData = this.precomputedObjects[id];\n                        }\n                        if (dirtyWidth == 0 && dirtyHeight == 0) {\n                            this.ctx.putImageData(imgData, dx, dy);\n                        }\n                        else {\n                            this.ctx.putImageData(imgData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n                        }\n                    }\n                    break;\n                case D2DType.D2D_CLOSEPATH:\n                    {\n                        this.ctx.closePath();\n                    }\n                    break;\n                case D2DType.D2D_RESET:\n                    {\n                        this.ctx.reset();\n                    }\n                    break;\n                case D2DType.D2D_CLEARRECT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const w = wasmMem.getDouble(currentInsParams + 16);\n                        const h = wasmMem.getDouble(currentInsParams + 24);\n                        this.ctx.clearRect(x, y, w, h);\n                    }\n                    break;\n                case D2DType.D2D_SCALE:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        this.ctx.scale(x, y);\n                    }\n                    break;\n                case D2DType.D2D_TRANSLATE:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        this.ctx.translate(x, y);\n                    }\n                    break;\n                case D2DType.D2D_ROTATE:\n                    {\n                        const angle = wasmMem.getDouble(currentInsParams);\n                        this.ctx.rotate(angle);\n                    }\n                    break;\n                case D2DType.D2D_GETTRANSFORM:\n                    {\n                        const matrix_ptr = wasmMem.getLong(currentInsParams);\n                        const transform = this.ctx.getTransform();\n                        wasmMem.setDouble(matrix_ptr + 0, transform.a);\n                        wasmMem.setDouble(matrix_ptr + 8, transform.b);\n                        wasmMem.setDouble(matrix_ptr + 16, transform.c);\n                        wasmMem.setDouble(matrix_ptr + 24, transform.d);\n                        wasmMem.setDouble(matrix_ptr + 32, transform.e);\n                        wasmMem.setDouble(matrix_ptr + 40, transform.f);\n                    }\n                    break;\n                case D2DType.D2D_SETTRANSFORM:\n                    {\n                        const a = wasmMem.getDouble(currentInsParams);\n                        const b = wasmMem.getDouble(currentInsParams + 8);\n                        const c = wasmMem.getDouble(currentInsParams + 16);\n                        const d = wasmMem.getDouble(currentInsParams + 24);\n                        const e = wasmMem.getDouble(currentInsParams + 32);\n                        const f = wasmMem.getDouble(currentInsParams + 40);\n                        this.ctx.setTransform(a, b, c, d, e, f);\n                    }\n                    break;\n                case D2DType.D2D_RESETTRANSFORM:\n                    {\n                        this.ctx.resetTransform();\n                    }\n                    break;\n                case D2DType.D2D_STROKETEXT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const codePage = wasmMem.getLong(currentInsParams + 20);\n                        const strPointer = wasmMem.getLong(currentInsParams + 16);\n                        const str = wasmMem.getString(strPointer, undefined, codePage);\n                        this.ctx.strokeText(str, x, y);\n                    }\n                    break;\n                case D2DType.D2D_ROUNDRECT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const width = wasmMem.getDouble(currentInsParams + 16);\n                        const height = wasmMem.getDouble(currentInsParams + 24);\n                        const radii = wasmMem.getDouble(currentInsParams + 32);\n                        this.ctx.roundRect(x, y, width, height, radii);\n                    }\n                    break;\n                case D2DType.D2D_ELLIPSE:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const radiusX = wasmMem.getDouble(currentInsParams + 16);\n                        const radiusY = wasmMem.getDouble(currentInsParams + 24);\n                        const rotation = wasmMem.getDouble(currentInsParams + 32);\n                        const startAngle = wasmMem.getDouble(currentInsParams + 40);\n                        const endAngle = wasmMem.getDouble(currentInsParams + 48);\n                        const counterClockwise = (wasmMem.getLong(currentInsParams + 56) != 0);\n                        this.ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterClockwise);\n                    }\n                    break;\n                case D2DType.D2D_QUADRATICCURVETO:\n                    {\n                        const cpx = wasmMem.getDouble(currentInsParams);\n                        const cpy = wasmMem.getDouble(currentInsParams + 8);\n                        const x = wasmMem.getDouble(currentInsParams + 16);\n                        const y = wasmMem.getDouble(currentInsParams + 24);\n                        this.ctx.quadraticCurveTo(cpx, cpy, x, y);\n                    }\n                    break;\n                case D2DType.D2D_SETLINEDASH:\n                    {\n                        const segment_len = wasmMem.getLong(currentInsParams);\n                        const seg_ptr = wasmMem.getLong(currentInsParams + 4);\n                        let segments = [];\n                        for (let i = 0; i < segment_len; i++) {\n                            segments[i] = wasmMem.getDouble(seg_ptr + i * 8);\n                        }\n                        this.ctx.setLineDash(segments);\n                    }\n                    break;\n                case D2DType.D2D_GETLINEDASH:\n                    {\n                        const segments = this.ctx.getLineDash();\n                        const buffer_length = wasmMem.getLong(currentInsParams);\n                        const buffer_ptr = wasmMem.getLong(currentInsParams + 4);\n                        const segment_length_ptr = currentInsParams + 8;\n                        wasmMem.setLong(segment_length_ptr, segments.length);\n                        if (segments.length > 0) {\n                            for (let i = 0; i < Math.min(segments.length, buffer_length); i++) {\n                                wasmMem.setDouble(buffer_ptr + i * 8, segments[i]);\n                            }\n                            if (segments.length > buffer_length) {\n                                console.log(\"warning: D2D_GETLINEDASH exceeded given max_length, truncating excess\");\n                            }\n                        }\n                    }\n                    break;\n                case D2DType.D2D_ARCTO:\n                    {\n                        const x1 = wasmMem.getDouble(currentInsParams);\n                        const y1 = wasmMem.getDouble(currentInsParams + 8);\n                        const x2 = wasmMem.getDouble(currentInsParams + 16);\n                        const y2 = wasmMem.getDouble(currentInsParams + 24);\n                        const radius = wasmMem.getDouble(currentInsParams + 32);\n                        this.ctx.arcTo(x1, y1, x2, y2, radius);\n                    }\n                    break;\n                case D2DType.D2D_GETLINEDASHLENGTH:\n                    {\n                        wasmMem.setLong(currentInsParams, this.ctx.getLineDash().length);\n                    }\n                    break;\n                case D2DType.D2D_DRAWIMAGE:\n                    {\n                        const sx = wasmMem.getDouble(currentInsParams);\n                        const sy = wasmMem.getDouble(currentInsParams + 8);\n                        const sWidth = wasmMem.getDouble(currentInsParams + 16);\n                        const sHeight = wasmMem.getDouble(currentInsParams + 24);\n                        const dx = wasmMem.getDouble(currentInsParams + 32);\n                        const dy = wasmMem.getDouble(currentInsParams + 40);\n                        const dWidth = wasmMem.getDouble(currentInsParams + 48);\n                        const dHeight = wasmMem.getDouble(currentInsParams + 56);\n                        const id = wasmMem.getLong(currentInsParams + 64);\n                        if (!(id in this.precomputedObjects))\n                            throw new Error(\"D2D_DRAWIMAGE with invalid ID: \" + id);\n                        let img = this.precomputedObjects[id];\n                        if (sWidth == 0 && sHeight == 0 && dWidth == 0 && dHeight == 0) {\n                            this.ctx.drawImage(img, dx, dy);\n                        }\n                        else if (dWidth == 0 && dHeight == 0) {\n                            this.ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, sWidth, sHeight);\n                        }\n                        else if (sWidth == 0 && sHeight == 0) {\n                            this.ctx.drawImage(img, sx, sy, img.width, img.height, dx, dy, dWidth, dHeight);\n                        }\n                        else {\n                            this.ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n                        }\n                    }\n                    break;\n                case D2DType.D2D_RECT:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const width = wasmMem.getDouble(currentInsParams + 16);\n                        const height = wasmMem.getDouble(currentInsParams + 24);\n                        this.ctx.rect(x, y, width, height);\n                    }\n                    break;\n                case D2DType.D2D_TRANSFORM:\n                    {\n                        const a = wasmMem.getDouble(currentInsParams);\n                        const b = wasmMem.getDouble(currentInsParams + 8);\n                        const c = wasmMem.getDouble(currentInsParams + 16);\n                        const d = wasmMem.getDouble(currentInsParams + 24);\n                        const e = wasmMem.getDouble(currentInsParams + 32);\n                        const f = wasmMem.getDouble(currentInsParams + 40);\n                        this.ctx.transform(a, b, c, d, e, f);\n                    }\n                    break;\n                case D2DType.D2D_SETLINECAP:\n                    {\n                        const lineCapPtr = wasmMem.getLong(currentInsParams);\n                        const lineCap = wasmMem.getString(lineCapPtr);\n                        this.ctx.lineCap = lineCap;\n                    }\n                    break;\n                case D2DType.D2D_SETLINEJOIN:\n                    {\n                        const lineJoinPtr = wasmMem.getLong(currentInsParams);\n                        const lineJoin = wasmMem.getString(lineJoinPtr);\n                        this.ctx.lineJoin = lineJoin;\n                    }\n                    break;\n                case D2DType.D2D_SETLINEDASHOFFSET:\n                    {\n                        const lineDashOffset = wasmMem.getDouble(currentInsParams);\n                        this.ctx.lineDashOffset = lineDashOffset;\n                    }\n                    break;\n                case D2DType.D2D_GETIMAGEDATA:\n                    {\n                        const x = wasmMem.getDouble(currentInsParams);\n                        const y = wasmMem.getDouble(currentInsParams + 8);\n                        const width = wasmMem.getDouble(currentInsParams + 16);\n                        const height = wasmMem.getDouble(currentInsParams + 24);\n                        const id = wasmMem.getLong(currentInsParams + 32);\n                        const imgData = this.ctx.getImageData(x, y, width, height);\n                        if (id in this.precomputedObjects)\n                            console.log(\"warning: D2D_GETIMAGEDATA ID already exists.\");\n                        this.precomputedObjects[id] = imgData;\n                        // const memPtr = wasmMem.getLong(currentInsParams+32);\n                        // const memLen = wasmMem.getLong(currentInsParams+36);\n                        // let imgData = this.ctx.getImageData(x, y, width, height);\n                        // const imgLen = imgData.data.byteLength;\n                        // if (imgLen > memLen) console.log(\"Warning: D2D_GETIMAGEDATA was given a buffer smaller than the image size! Extra data is being truncated\");\n                        // owner.mem8.set(imgData.data.slice(0, Math.min(memLen, imgLen)), memPtr);\n                    }\n                    break;\n                case D2DType.D2D_IMAGEDATATOC:\n                    {\n                        const bufferPtr = wasmMem.getLong(currentInsParams);\n                        const bufferLen = wasmMem.getLong(currentInsParams + 4);\n                        const id = wasmMem.getLong(currentInsParams + 8);\n                        if (!(id in this.precomputedObjects))\n                            throw new Error(\"D2D_IMAGEDATATOC with invalid ID: \" + id);\n                        const img = this.precomputedObjects[id];\n                        const imgLen = img.data.byteLength;\n                        if (imgLen > bufferLen)\n                            console.log(\"Warning: D2D_IMAGEDATATOC was given a buffer smaller than the image size! Extra data is being truncated\");\n                        wasmMem.mem8.set(img.data.slice(0, Math.min(bufferLen, imgLen)), bufferPtr);\n                    }\n                    break;\n                case D2DType.D2D_GETCANVASPROPDOUBLE:\n                    {\n                        const valPtr = wasmMem.getLong(currentInsParams);\n                        const namePtr = wasmMem.getLong(currentInsParams + 4);\n                        const propName = wasmMem.getString(namePtr);\n                        const val = this.ctx[propName];\n                        if (typeof val != \"number\")\n                            throw new Error(\"D2D_GETCANVASPROPDOUBLE with property \" + propName + \" expected a number, got \" + (typeof val) + \"!\");\n                        wasmMem.setDouble(valPtr, val);\n                    }\n                    break;\n                case D2DType.D2D_GETCANVASPROPSTRING:\n                    {\n                        const valPtr = wasmMem.getLong(currentInsParams);\n                        const valMaxLen = wasmMem.getLong(currentInsParams + 4);\n                        const namePtr = wasmMem.getLong(currentInsParams + 8);\n                        const propName = wasmMem.getString(namePtr);\n                        const val = this.ctx[propName];\n                        if (typeof val != \"string\")\n                            throw new Error(\"D2D_GETCANVASPROPSTRING with property \" + propName + \" expected a string, got \" + (typeof val) + \"!\");\n                        const encodedVal = wasmMem.stringToU8(val);\n                        if (encodedVal.byteLength >= valMaxLen)\n                            console.log(\"Warning: D2D_GETCANVASPROPSTRING was given a buffer smaller than the return value! The extra data is being truncated!\");\n                        const strLen = Math.min(encodedVal.byteLength, valMaxLen - 1); //-1 from valMaxLen for null character\n                        wasmMem.mem8.set(encodedVal.slice(0, strLen), valPtr);\n                        wasmMem.mem8[strLen + valPtr] = 0; //ensure the null character gets set\n                    }\n                    break;\n                case D2DType.D2D_SETCANVASPROPDOUBLE:\n                    {\n                        const val = wasmMem.getDouble(currentInsParams);\n                        const namePtr = wasmMem.getLong(currentInsParams + 8);\n                        const propName = wasmMem.getString(namePtr);\n                        const prevVal = this.ctx[propName];\n                        if (typeof prevVal != \"number\")\n                            throw new Error(\"D2D_SETCANVASPROPDOUBLE with property \" + propName + \" expected a number, got \" + (typeof prevVal) + \"!\");\n                        this.ctx[propName] = val;\n                    }\n                    break;\n                case D2DType.D2D_SETCANVASPROPSTRING:\n                    {\n                        const valPtr = wasmMem.getLong(currentInsParams);\n                        const namePtr = wasmMem.getLong(currentInsParams + 4);\n                        const val = wasmMem.getString(valPtr);\n                        const propName = wasmMem.getString(namePtr);\n                        const prevVal = this.ctx[propName];\n                        if (typeof prevVal != \"string\")\n                            throw new Error(\"D2D_SETCANVASPROPSTRING with property \" + propName + \" expected a string, got \" + (typeof prevVal) + \"!\");\n                        this.ctx[propName] = val;\n                    }\n                    break;\n                default:\n                    throw new Error(\"unimplemented or unknown Sequence Type in drawSeq: \" + type);\n            }\n            nextInsHdr = wasmMem.getLong(currentInsHdr); /* hdr->next */\n            if (nextInsHdr == 0) {\n                if (currentInsHdr != lastInsHdr)\n                    throw new Error(\"assert type error in twrcanvas, ins!=lastins\");\n                break;\n            }\n            currentInsHdr = nextInsHdr;\n            currentInsParams = currentInsHdr + insHdrSize;\n        }\n    }\n}\nexport default twrConsoleCanvas;\n//# sourceMappingURL=twrconcanvas.js.map","import {IConsoleCanvas, ICanvasProps, IOTypes} from \"./twrcon.js\";\nimport {IWasmModuleAsync} from \"./twrmodasync.js\"\nimport {IWasmModule} from \"./twrmod.js\";\nimport {twrLibrary, TLibImports, twrLibraryInstanceRegistry} from \"./twrlibrary.js\";\n\nenum D2DType {\n    D2D_FILLRECT=1,\n    D2D_FILLCODEPOINT=5,\n    D2D_SETLINEWIDTH=10,\n    D2D_SETFILLSTYLERGBA=11,\n    D2D_SETFONT=12,\n    D2D_BEGINPATH=13,\n    D2D_MOVETO=14,\n    D2D_LINETO=15,\n    D2D_FILL=16,\n    D2D_STROKE=17,\n    D2D_SETSTROKESTYLERGBA=18,\n    D2D_ARC=19,\n    D2D_STROKERECT=20,\n    D2D_FILLTEXT=21,\n    D2D_IMAGEDATA=22,\n    D2D_PUTIMAGEDATA=23,\n    D2D_BEZIERTO=24,\n    D2D_MEASURETEXT=25,\n    D2D_SAVE=26,\n    D2D_RESTORE=27,\n    D2D_CREATERADIALGRADIENT=28,\n    D2D_SETCOLORSTOP=29,\n    D2D_SETFILLSTYLEGRADIENT=30,\n    D2D_RELEASEID=31,\n    D2D_CREATELINEARGRADIENT=32,\n    D2D_SETFILLSTYLE=33,\n    D2D_SETSTROKESTYLE=34,\n    D2D_CLOSEPATH=35,\n    D2D_RESET=36,\n    D2D_CLEARRECT=37,\n    D2D_SCALE=38,\n    D2D_TRANSLATE=39,\n    D2D_ROTATE=40,\n    D2D_GETTRANSFORM = 41,\n    D2D_SETTRANSFORM = 42,\n    D2D_RESETTRANSFORM = 43,\n    D2D_STROKETEXT = 44,\n    D2D_ROUNDRECT = 45,\n    D2D_ELLIPSE = 46,\n    D2D_QUADRATICCURVETO = 47,\n    D2D_SETLINEDASH = 48,\n    D2D_GETLINEDASH = 49,\n    D2D_ARCTO = 50,\n    D2D_GETLINEDASHLENGTH = 51,\n    D2D_DRAWIMAGE = 52,\n    D2D_RECT = 53,\n    D2D_TRANSFORM = 54,\n    D2D_SETLINECAP = 55,\n    D2D_SETLINEJOIN = 56,\n    D2D_SETLINEDASHOFFSET = 57,\n    D2D_GETIMAGEDATA = 58,\n    D2D_IMAGEDATATOC = 59,\n    D2D_GETCANVASPROPDOUBLE = 60,\n    D2D_GETCANVASPROPSTRING = 61,\n    D2D_SETCANVASPROPDOUBLE = 62,\n    D2D_SETCANVASPROPSTRING = 63,\n}\n\nexport class twrConsoleCanvas extends twrLibrary implements IConsoleCanvas {\n   id:number;\n   ctx:CanvasRenderingContext2D;\n   element:HTMLCanvasElement\n   props:ICanvasProps;\n   //TODO!! BUG - precomputed objects should be unique for each module that using this twrConsoleCanvas\n   precomputedObjects: {  [index: number]: \n      (ImageData | \n      {mem8:Uint8Array, width:number, height:number})  |\n      CanvasGradient |\n      HTMLImageElement\n   };\n\n   imports:TLibImports = {\n      twrConGetProp:{},\n      twrConDrawSeq:{},\n      twrConLoadImage:{isModuleAsyncOnly:true, isAsyncFunction:true},\n   };\n\n   libSourcePath = new URL(import.meta.url).pathname;\n   interfaceName = \"twrConsole\";\n\n   constructor(element:HTMLCanvasElement) {\n      // all library constructors should start with these two lines\n      super();\n      this.id=twrLibraryInstanceRegistry.register(this);\n\n      this.precomputedObjects={};\n\n      if (!(element && element instanceof HTMLCanvasElement && element.getContext)) \n         throw new Error(\"Invalid HTMLCanvasElement parameter in twrConsoleCanvas constructor \");\n\n      this.element=element;\n\n      const c=element.getContext(\"2d\");\n      if (!c) throw new Error(\"Canvas 2D context not found.\");\n      this.ctx=c;\n\n      // these two lines are for backwards compatibility with prior version of twr-wasm\n      c.font = \"16 px Courier New\";\n      c.textBaseline=\"top\";\n\n      this.props = {canvasHeight: element.height, canvasWidth: element.width, type: IOTypes.CANVAS2D}; \n   }\n\n\n   getProp(name:keyof ICanvasProps): number {\n      return this.props[name];\n   }\n\n   twrConGetProp(callingMod:IWasmModule|IWasmModuleAsync, pn:number):number {\n      const propName=callingMod.wasmMem.getString(pn);\n      return this.getProp(propName);\n   }\n\n   twrConLoadImage_async(mod: IWasmModuleAsync, urlPtr: number, id: number) : Promise<number> {\n      return new Promise( (resolve)=>{\n         const url = mod.wasmMem.getString(urlPtr);\n         if ( id in this.precomputedObjects ) console.log(\"warning: D2D_LOADIMAGE ID already exists.\");\n         \n         const img = new Image();\n         img.onload = () => {\n            resolve(1);\n         };\n         img.onerror = () => {\n            console.log(\"Warning: D2D_LOADIMAGE: failed to load image \" + url);\n            resolve(1);\n         }\n\n         img.src = url;\n\n         this.precomputedObjects[id] = img;\n      });\n   }\n\n   /* see draw2d.h for structs that match */\n   twrConDrawSeq(mod:IWasmModuleAsync|IWasmModule, ds:number) {\n      //console.log(\"twr::Canvas enter drawSeq\");\n      if (!this.ctx) return;\n\n      const wasmMem=mod.wasmMem;\n      const insHdrSize = 16;\n      let currentInsHdr=wasmMem.getLong(ds);  /* ds->start */\n      const lastInsHdr=wasmMem.getLong(ds+4);  /* ds->last */\n      let currentInsParams = currentInsHdr + insHdrSize;\n      //console.log(\"instruction start, last \",ins.toString(16), lastins.toString(16));\n\n      let nextInsHdr:number;\n      //let insCount=0;\n      \n      while (1) {\n\n      //insCount++;\n\n         const type:D2DType=wasmMem.getLong(currentInsHdr+4);    /* hdr->type */\n         if (0/*type!=D2DType.D2D_FILLRECT*/) {\n               console.log(\"ins\",currentInsHdr)\n               console.log(\"hdr.next\",wasmMem.mem8[currentInsHdr],wasmMem.mem8[currentInsHdr+1],wasmMem.mem8[currentInsHdr+2],wasmMem.mem8[currentInsHdr+3]);\n               console.log(\"hdr.type\",wasmMem.mem8[currentInsHdr+4],wasmMem.mem8[currentInsHdr+5]);\n               console.log(\"next 4 bytes\", wasmMem.mem8[currentInsHdr+6],wasmMem.mem8[currentInsHdr+7],wasmMem.mem8[currentInsHdr+8],wasmMem.mem8[currentInsHdr+9]);\n               console.log(\"and 4 more \", wasmMem.mem8[currentInsHdr+10],wasmMem.mem8[currentInsHdr+11],wasmMem.mem8[currentInsHdr+12],wasmMem.mem8[currentInsHdr+13]);\n               //console.log(\"ins, type, next is \", ins.toString(16), type.toString(16), next.toString(16));\n            }\n         switch (type) {\n            case D2DType.D2D_FILLRECT:\n            {\n               const x=wasmMem.getDouble(currentInsParams);\n               const y=wasmMem.getDouble(currentInsParams+8);\n               const w=wasmMem.getDouble(currentInsParams+16);\n               const h=wasmMem.getDouble(currentInsParams+24);\n               this.ctx.fillRect(x, y, w, h);\n            }\n               break;\n\n            case D2DType.D2D_STROKERECT:\n            {\n               const x=wasmMem.getDouble(currentInsParams);\n               const y=wasmMem.getDouble(currentInsParams+8);\n               const w=wasmMem.getDouble(currentInsParams+16);\n               const h=wasmMem.getDouble(currentInsParams+24);\n               this.ctx.strokeRect(x, y, w, h);\n            }\n               break;\n\n            case D2DType.D2D_FILLCODEPOINT:\n            {\n               const x=wasmMem.getDouble(currentInsParams);\n               const y=wasmMem.getDouble(currentInsParams+8);\n               const c=wasmMem.getLong(currentInsParams+16);\n               let txt=String.fromCodePoint(c);\n               this.ctx.fillText(txt, x, y);\n            }\n               break;\n\n            \n            case D2DType.D2D_FILLTEXT:\n            {\n               const x=wasmMem.getDouble(currentInsParams);\n               const y=wasmMem.getDouble(currentInsParams+8);\n               const codePage=wasmMem.getLong(currentInsParams+20);\n               const strPointer = wasmMem.getLong(currentInsParams+16);\n               const str=wasmMem.getString(strPointer, undefined, codePage);\n\n               //console.log(\"filltext \",x,y,str)\n\n               this.ctx.fillText(str, x, y);\n            }\n               break;\n\n            case D2DType.D2D_MEASURETEXT:\n            {\n               const codePage=wasmMem.getLong(currentInsParams+8);\n               const str=wasmMem.getString(wasmMem.getLong(currentInsParams), undefined, codePage);\n               const tmidx=wasmMem.getLong(currentInsParams+4);\n\n               const tm=this.ctx.measureText(str);\n               wasmMem.setDouble(tmidx+0, tm.actualBoundingBoxAscent);\n               wasmMem.setDouble(tmidx+8, tm.actualBoundingBoxDescent);\n               wasmMem.setDouble(tmidx+16, tm.actualBoundingBoxLeft);\n               wasmMem.setDouble(tmidx+24, tm.actualBoundingBoxRight);\n               wasmMem.setDouble(tmidx+32, tm.fontBoundingBoxAscent);\n               wasmMem.setDouble(tmidx+40, tm.fontBoundingBoxDescent);\n               wasmMem.setDouble(tmidx+48, tm.width);\n            }\n               break;\n\n            case D2DType.D2D_SETFONT:\n            {\n               const fontPointer = wasmMem.getLong(currentInsParams);\n               const str=wasmMem.getString(fontPointer);\n               this.ctx.font=str;\n            }\n               break;\n\n            case D2DType.D2D_SETFILLSTYLERGBA:\n            {\n               const color=wasmMem.getLong(currentInsParams); \n               const cssColor= \"#\"+(\"00000000\" + color.toString(16)).slice(-8);\n               this.ctx.fillStyle = cssColor;\n               //console.log(\"fillstyle: \", this.ctx.fillStyle, \":\", cssColor,\":\", color)\n            }\n               break;\n\n            case D2DType.D2D_SETSTROKESTYLERGBA:\n            {\n               const color=wasmMem.getLong(currentInsParams); \n               const cssColor= \"#\"+(\"00000000\" + color.toString(16)).slice(-8);\n               this.ctx.strokeStyle = cssColor;\n            }\n               break;\n\n            case D2DType.D2D_SETFILLSTYLE:\n            {\n               const cssColorPointer = wasmMem.getLong(currentInsParams);\n               const cssColor= wasmMem.getString(cssColorPointer);\n               this.ctx.fillStyle = cssColor;\n            }\n               break\n\n            case D2DType.D2D_SETSTROKESTYLE:\n            {\n               const cssColorPointer = wasmMem.getLong(currentInsParams);\n               const cssColor= wasmMem.getString(cssColorPointer);\n               this.ctx.strokeStyle = cssColor;\n            }\n               break\n\n            case D2DType.D2D_SETLINEWIDTH:\n            {\n               const width=wasmMem.getDouble(currentInsParams);  \n               this.ctx.lineWidth=width;\n               //console.log(\"twrCanvas D2D_SETLINEWIDTH: \", this.ctx.lineWidth);\n            }\n               break;\n\n            case D2DType.D2D_MOVETO:\n            {\n               const x=wasmMem.getDouble(currentInsParams);\n               const y=wasmMem.getDouble(currentInsParams+8);\n               this.ctx.moveTo(x, y);\n            }\n               break;\n\n            case D2DType.D2D_LINETO:\n            {\n               const x=wasmMem.getDouble(currentInsParams);\n               const y=wasmMem.getDouble(currentInsParams+8);\n               this.ctx.lineTo(x, y);\n            }\n               break;\n\n            case D2DType.D2D_BEZIERTO:\n            {\n               const cp1x=wasmMem.getDouble(currentInsParams);\n               const cp1y=wasmMem.getDouble(currentInsParams+8);\n               const cp2x=wasmMem.getDouble(currentInsParams+16);\n               const cp2y=wasmMem.getDouble(currentInsParams+24);\n               const x=wasmMem.getDouble(currentInsParams+32);\n               const y=wasmMem.getDouble(currentInsParams+40);\n               this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n            }\n               break;\n\n            case D2DType.D2D_BEGINPATH:\n            {\n               this.ctx.beginPath();\n            }\n               break;\n\n            case D2DType.D2D_FILL:\n            {\n               this.ctx.fill();\n            }\n               break;\n\n            case D2DType.D2D_SAVE:\n            {\n               this.ctx.save();\n            }\n               break;\n\n            case D2DType.D2D_RESTORE:\n            {\n               this.ctx.restore();\n            }\n               break;\n\n            case D2DType.D2D_STROKE:\n            {\n               this.ctx.stroke();\n            }\n               break;\n\n            case D2DType.D2D_ARC:\n            {\n               const x=wasmMem.getDouble(currentInsParams);\n               const y=wasmMem.getDouble(currentInsParams+8);\n               const radius=wasmMem.getDouble(currentInsParams+16);\n               const startAngle=wasmMem.getDouble(currentInsParams+24);\n               const endAngle=wasmMem.getDouble(currentInsParams+32);\n               const counterClockwise= (wasmMem.getLong(currentInsParams+40)!=0);\n\n               this.ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise)\n            }\n               break;\n\n            case D2DType.D2D_IMAGEDATA:\n            {\n               const start=wasmMem.getLong(currentInsParams);\n               const length=wasmMem.getLong(currentInsParams+4);\n               const width=wasmMem.getLong(currentInsParams+8);\n               const height=wasmMem.getLong(currentInsParams+12);\n               const id=wasmMem.getLong(currentInsParams+16);\n\n               if ( id in this.precomputedObjects ) console.log(\"warning: D2D_IMAGEDATA ID already exists.\");\n\n               if (mod.isTwrWasmModuleAsync) {  // Uint8ClampedArray doesn't support shared memory\n                  this.precomputedObjects[id]={mem8: new Uint8Array(wasmMem.memory!.buffer, start, length), width:width, height:height};\n               }\n               else {\n                  const z = new Uint8ClampedArray(wasmMem.memory!.buffer, start, length);\n                  this.precomputedObjects[id]=new ImageData(z, width, height);\n               }\n            }\n               break;\n\n            case D2DType.D2D_CREATERADIALGRADIENT:\n            {\n               const x0=wasmMem.getDouble(currentInsParams);\n               const y0=wasmMem.getDouble(currentInsParams+8);\n               const radius0=wasmMem.getDouble(currentInsParams+16);\n               const x1=wasmMem.getDouble(currentInsParams+24);\n               const y1=wasmMem.getDouble(currentInsParams+32);\n               const radius1=wasmMem.getDouble(currentInsParams+40);\n               const id= wasmMem.getLong(currentInsParams+48);\n\n            let gradient=this.ctx.createRadialGradient(x0, y0, radius0, x1, y1, radius1);\n            if ( id in this.precomputedObjects ) console.log(\"warning: D2D_CREATERADIALGRADIENT ID already exists.\");\n            this.precomputedObjects[id] = gradient;\n            }\n               break\n\n            case D2DType.D2D_CREATELINEARGRADIENT:\n            {\n               const x0=wasmMem.getDouble(currentInsParams);\n               const y0=wasmMem.getDouble(currentInsParams+8);\n               const x1=wasmMem.getDouble(currentInsParams+16);\n               const y1=wasmMem.getDouble(currentInsParams+24);\n               const id= wasmMem.getLong(currentInsParams+32);\n\n               let gradient=this.ctx.createLinearGradient(x0, y0, x1, y1);\n               if ( id in this.precomputedObjects ) console.log(\"warning: D2D_CREATELINEARGRADIENT ID already exists.\");\n               this.precomputedObjects[id] = gradient;\n            }\n                  break\n\n            case D2DType.D2D_SETCOLORSTOP:\n            {\n               const id = wasmMem.getLong(currentInsParams);\n               const pos=wasmMem.getLong(currentInsParams+4);\n               const cssColorPointer = wasmMem.getLong(currentInsParams+8);\n               const cssColor= wasmMem.getString(cssColorPointer);\n\n               if (!(id in this.precomputedObjects)) throw new Error(\"D2D_SETCOLORSTOP with invalid ID: \"+id);\n               const gradient=this.precomputedObjects[id] as CanvasGradient;\n               gradient.addColorStop(pos, cssColor);\n\n            }\n               break\n\n            case D2DType.D2D_SETFILLSTYLEGRADIENT:\n            {\n               const id=wasmMem.getLong(currentInsParams);\n               if (!(id in this.precomputedObjects)) throw new Error(\"D2D_SETFILLSTYLEGRADIENT with invalid ID: \"+id);\n               const gradient=this.precomputedObjects[id] as CanvasGradient;\n               this.ctx.fillStyle=gradient;\n            }\n               break\n\n            case D2DType.D2D_RELEASEID:\n            {\n               const id=wasmMem.getLong(currentInsParams);\n               if (this.precomputedObjects[id])\n                  delete this.precomputedObjects[id];\n               else\n                  console.log(\"warning: D2D_RELEASEID with undefined ID \",id);\n            }\n               break\n\n            \n\n            case D2DType.D2D_PUTIMAGEDATA:\n            {\n               const id=wasmMem.getLong(currentInsParams);\n               const dx=wasmMem.getLong(currentInsParams+4);\n               const dy=wasmMem.getLong(currentInsParams+8);\n               const dirtyX=wasmMem.getLong(currentInsParams+12);\n               const dirtyY=wasmMem.getLong(currentInsParams+16);\n               const dirtyWidth=wasmMem.getLong(currentInsParams+20);\n               const dirtyHeight=wasmMem.getLong(currentInsParams+24);\n\n               if (!(id in this.precomputedObjects)) throw new Error(\"D2D_PUTIMAGEDATA with invalid ID: \"+id);\n\n               //console.log(\"D2D_PUTIMAGEDATA\",start, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight, this.imageData[start]);\n\n               let imgData:ImageData;\n   \n               if (mod.isTwrWasmModuleAsync) {  // Uint8ClampedArray doesn't support shared memory, so copy the memory\n                  //console.log(\"D2D_PUTIMAGEDATA wasmModuleAsync\");\n                  const z = this.precomputedObjects[id] as {mem8:Uint8Array, width:number, height:number}; // Uint8Array\n                  const ca=Uint8ClampedArray.from(z.mem8);  // shallow copy\n                  imgData=new ImageData(ca, z.width, z.height);\n               }\n               else  {\n                  imgData=this.precomputedObjects[id] as ImageData;\n               }\n               \n               if (dirtyWidth==0 && dirtyHeight==0) {\n                  this.ctx.putImageData(imgData, dx, dy);\n               }\n               else {\n                  this.ctx.putImageData(imgData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n               }\n            }\n               break;\n\n            case D2DType.D2D_CLOSEPATH:\n            {\n               this.ctx.closePath();\n            }\n               break;\n            \n            case D2DType.D2D_RESET:\n            {\n               this.ctx.reset();\n            }\n               break;\n\n            case D2DType.D2D_CLEARRECT:\n            {\n               const x=wasmMem.getDouble(currentInsParams);\n               const y=wasmMem.getDouble(currentInsParams+8);\n               const w=wasmMem.getDouble(currentInsParams+16);\n               const h=wasmMem.getDouble(currentInsParams+24);\n               this.ctx.clearRect(x, y, w, h);\n            }\n               break;\n            \n            case D2DType.D2D_SCALE:\n            {\n               const x=wasmMem.getDouble(currentInsParams);\n               const y=wasmMem.getDouble(currentInsParams+8);\n               this.ctx.scale(x, y);\n            }\n               break;\n            \n            case D2DType.D2D_TRANSLATE:\n            {\n               const x=wasmMem.getDouble(currentInsParams);\n               const y=wasmMem.getDouble(currentInsParams+8);\n               this.ctx.translate(x, y);\n            }\n               break;\n               \n            case D2DType.D2D_ROTATE:\n            {\n               const angle=wasmMem.getDouble(currentInsParams);\n               this.ctx.rotate(angle);\n            }\n               break;\n\n            case D2DType.D2D_GETTRANSFORM:\n            {\n               const matrix_ptr=wasmMem.getLong(currentInsParams);\n               const transform=this.ctx.getTransform();\n               wasmMem.setDouble(matrix_ptr+0, transform.a);\n               wasmMem.setDouble(matrix_ptr+8, transform.b);\n               wasmMem.setDouble(matrix_ptr+16, transform.c);\n               wasmMem.setDouble(matrix_ptr+24, transform.d);\n               wasmMem.setDouble(matrix_ptr+32, transform.e);\n               wasmMem.setDouble(matrix_ptr+40, transform.f);\n            }\n               break;\n            \n            case D2DType.D2D_SETTRANSFORM:\n            {\n               const a = wasmMem.getDouble(currentInsParams);\n               const b = wasmMem.getDouble(currentInsParams+8);\n               const c = wasmMem.getDouble(currentInsParams+16);\n               const d = wasmMem.getDouble(currentInsParams+24);\n               const e = wasmMem.getDouble(currentInsParams+32);\n               const f = wasmMem.getDouble(currentInsParams+40);\n\n               this.ctx.setTransform(a, b, c, d, e, f);\n            }\n               break;\n            \n            case D2DType.D2D_RESETTRANSFORM:\n            {\n               this.ctx.resetTransform();\n            }\n               break;\n            \n            case D2DType.D2D_STROKETEXT:\n            {\n               const x=wasmMem.getDouble(currentInsParams);\n               const y=wasmMem.getDouble(currentInsParams+8);\n               const codePage=wasmMem.getLong(currentInsParams+20);\n               const strPointer = wasmMem.getLong(currentInsParams+16);\n               const str=wasmMem.getString(strPointer, undefined, codePage);\n\n               this.ctx.strokeText(str, x, y);\n            }\n               break;\n            \n            case D2DType.D2D_ROUNDRECT:\n            {\n               const x = wasmMem.getDouble(currentInsParams);\n               const y = wasmMem.getDouble(currentInsParams+8);\n               const width = wasmMem.getDouble(currentInsParams+16);\n               const height = wasmMem.getDouble(currentInsParams+24);\n               const radii = wasmMem.getDouble(currentInsParams+32);\n\n               this.ctx.roundRect(x, y, width, height, radii);\n            }\n               break;\n            \n            case D2DType.D2D_ELLIPSE:\n            {\n               const x=wasmMem.getDouble(currentInsParams);\n               const y=wasmMem.getDouble(currentInsParams+8);\n               const radiusX=wasmMem.getDouble(currentInsParams+16);\n               const radiusY=wasmMem.getDouble(currentInsParams+24);\n               const rotation=wasmMem.getDouble(currentInsParams+32);\n               const startAngle=wasmMem.getDouble(currentInsParams+40);\n               const endAngle=wasmMem.getDouble(currentInsParams+48);\n               const counterClockwise= (wasmMem.getLong(currentInsParams+56)!=0);\n\n               this.ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterClockwise)\n            }\n               break;\n            \n            case D2DType.D2D_QUADRATICCURVETO:\n            {\n               const cpx = wasmMem.getDouble(currentInsParams);\n               const cpy = wasmMem.getDouble(currentInsParams+8);\n               const x = wasmMem.getDouble(currentInsParams+16);\n               const y = wasmMem.getDouble(currentInsParams+24);\n\n               this.ctx.quadraticCurveTo(cpx, cpy, x, y);\n            }\n               break;\n            \n            case D2DType.D2D_SETLINEDASH:\n            {\n               const segment_len = wasmMem.getLong(currentInsParams);\n               const seg_ptr = wasmMem.getLong(currentInsParams+4);\n               let segments = [];\n               for (let i = 0; i < segment_len; i++) {\n                  segments[i] = wasmMem.getDouble(seg_ptr + i*8);\n               }\n               this.ctx.setLineDash(segments);\n            }\n               break;\n\n            case D2DType.D2D_GETLINEDASH:\n            {\n               const segments = this.ctx.getLineDash();\n\n               const buffer_length = wasmMem.getLong(currentInsParams);\n               const buffer_ptr = wasmMem.getLong(currentInsParams+4);\n               const segment_length_ptr = currentInsParams+8;\n\n               wasmMem.setLong(segment_length_ptr, segments.length);\n               if (segments.length > 0) {\n                  for (let i = 0; i < Math.min(segments.length, buffer_length); i++) {\n                        wasmMem.setDouble(buffer_ptr + i*8, segments[i]);\n                  }\n                  if (segments.length > buffer_length) {\n                        console.log(\"warning: D2D_GETLINEDASH exceeded given max_length, truncating excess\");\n                  }\n               }\n            }\n               break;\n            \n            case D2DType.D2D_ARCTO:\n            {\n               const x1 = wasmMem.getDouble(currentInsParams);\n               const y1 = wasmMem.getDouble(currentInsParams+8);\n               const x2 = wasmMem.getDouble(currentInsParams+16);\n               const y2 = wasmMem.getDouble(currentInsParams+24);\n               const radius = wasmMem.getDouble(currentInsParams+32);\n\n               this.ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n               break;\n            \n            case D2DType.D2D_GETLINEDASHLENGTH:\n            {\n               wasmMem.setLong(currentInsParams, this.ctx.getLineDash().length);\n            }\n               break;\n            \n            case D2DType.D2D_DRAWIMAGE:\n            {\n               const sx = wasmMem.getDouble(currentInsParams);\n               const sy = wasmMem.getDouble(currentInsParams+8);\n\n               const sWidth = wasmMem.getDouble(currentInsParams+16);\n               const sHeight = wasmMem.getDouble(currentInsParams+24);\n\n               const dx = wasmMem.getDouble(currentInsParams+32);\n               const dy = wasmMem.getDouble(currentInsParams+40);\n\n               const dWidth = wasmMem.getDouble(currentInsParams+48);\n               const dHeight = wasmMem.getDouble(currentInsParams+56);\n\n               const id = wasmMem.getLong(currentInsParams+64);\n\n               if (!(id in this.precomputedObjects)) throw new Error(\"D2D_DRAWIMAGE with invalid ID: \"+id);\n\n               let img = this.precomputedObjects[id] as HTMLImageElement;\n\n               if (sWidth == 0 && sHeight == 0 && dWidth == 0 && dHeight == 0) {\n                  this.ctx.drawImage(img, dx, dy);\n               } else if (dWidth == 0 && dHeight == 0) {\n                  this.ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, sWidth, sHeight);\n               } else if (sWidth == 0 && sHeight == 0) {\n                  this.ctx.drawImage(img, sx, sy, img.width, img.height, dx, dy, dWidth, dHeight);\n               }else {\n                  this.ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n               }\n            }\n               break;\n            \n            case D2DType.D2D_RECT:\n            {\n               const x = wasmMem.getDouble(currentInsParams);\n               const y = wasmMem.getDouble(currentInsParams+8);\n               const width = wasmMem.getDouble(currentInsParams+16);\n               const height = wasmMem.getDouble(currentInsParams+24);\n\n               this.ctx.rect(x, y, width, height);\n            }\n               break;\n            \n            case D2DType.D2D_TRANSFORM:\n            {\n               const a = wasmMem.getDouble(currentInsParams);\n               const b = wasmMem.getDouble(currentInsParams+8);\n               const c = wasmMem.getDouble(currentInsParams+16);\n               const d = wasmMem.getDouble(currentInsParams+24);\n               const e = wasmMem.getDouble(currentInsParams+32);\n               const f = wasmMem.getDouble(currentInsParams+40);\n\n               this.ctx.transform(a, b, c, d, e, f);\n            }\n               break;\n            \n            case D2DType.D2D_SETLINECAP:\n            {\n               const lineCapPtr = wasmMem.getLong(currentInsParams);\n               const lineCap = wasmMem.getString(lineCapPtr);\n\n               this.ctx.lineCap = lineCap as CanvasLineCap;\n            }\n               break;\n\n            case D2DType.D2D_SETLINEJOIN:\n            {\n               const lineJoinPtr = wasmMem.getLong(currentInsParams);\n               const lineJoin = wasmMem.getString(lineJoinPtr);\n\n               this.ctx.lineJoin = lineJoin as CanvasLineJoin;\n            }\n               break;\n            \n            case D2DType.D2D_SETLINEDASHOFFSET:\n            {\n               const lineDashOffset = wasmMem.getDouble(currentInsParams);\n\n               this.ctx.lineDashOffset = lineDashOffset;\n            }\n               break;\n            \n            case D2DType.D2D_GETIMAGEDATA:\n            {\n               const x = wasmMem.getDouble(currentInsParams);\n               const y = wasmMem.getDouble(currentInsParams+8);\n               const width = wasmMem.getDouble(currentInsParams+16);\n               const height = wasmMem.getDouble(currentInsParams+24);\n               const id = wasmMem.getLong(currentInsParams+32);\n               \n               const imgData = this.ctx.getImageData(x, y, width, height);\n\n               if ( id in this.precomputedObjects ) console.log(\"warning: D2D_GETIMAGEDATA ID already exists.\");\n               this.precomputedObjects[id] = imgData;\n\n               // const memPtr = wasmMem.getLong(currentInsParams+32);\n               // const memLen = wasmMem.getLong(currentInsParams+36);\n\n               // let imgData = this.ctx.getImageData(x, y, width, height);\n               // const imgLen = imgData.data.byteLength;\n               // if (imgLen > memLen) console.log(\"Warning: D2D_GETIMAGEDATA was given a buffer smaller than the image size! Extra data is being truncated\");\n               // owner.mem8.set(imgData.data.slice(0, Math.min(memLen, imgLen)), memPtr);\n            }\n               break;\n\n            case D2DType.D2D_IMAGEDATATOC:\n            {\n               const bufferPtr = wasmMem.getLong(currentInsParams);\n               const bufferLen = wasmMem.getLong(currentInsParams+4);\n               const id = wasmMem.getLong(currentInsParams+8);\n\n               if (!(id in this.precomputedObjects)) throw new Error(\"D2D_IMAGEDATATOC with invalid ID: \"+id);\n\n               const img = this.precomputedObjects[id] as ImageData;\n               const imgLen = img.data.byteLength;\n               if (imgLen > bufferLen) console.log(\"Warning: D2D_IMAGEDATATOC was given a buffer smaller than the image size! Extra data is being truncated\");\n               wasmMem.mem8.set(img.data.slice(0, Math.min(bufferLen, imgLen)), bufferPtr);\n            }\n               break;\n            \n            case D2DType.D2D_GETCANVASPROPDOUBLE:\n            {\n               const valPtr = wasmMem.getLong(currentInsParams);\n               const namePtr = wasmMem.getLong(currentInsParams+4);\n\n               const propName = wasmMem.getString(namePtr);\n               \n               const val = (this.ctx as {[key: string]: any})[propName];\n               if (typeof val != \"number\") throw new Error(\"D2D_GETCANVASPROPDOUBLE with property \" + propName + \" expected a number, got \" + (typeof val) + \"!\");\n               wasmMem.setDouble(valPtr, val);\n            }\n               break;\n            \n            case D2DType.D2D_GETCANVASPROPSTRING:\n            {\n               const valPtr = wasmMem.getLong(currentInsParams);\n               const valMaxLen = wasmMem.getLong(currentInsParams+4);\n               const namePtr = wasmMem.getLong(currentInsParams+8);\n\n               const propName = wasmMem.getString(namePtr);\n\n               const val = (this.ctx as {[key: string]: any})[propName];\n               if (typeof val != \"string\") throw new Error(\"D2D_GETCANVASPROPSTRING with property \" + propName + \" expected a string, got \" + (typeof val) + \"!\");\n               \n               const encodedVal = wasmMem.stringToU8(val as string);\n               if (encodedVal.byteLength >= valMaxLen) console.log(\"Warning: D2D_GETCANVASPROPSTRING was given a buffer smaller than the return value! The extra data is being truncated!\");\n               \n               const strLen = Math.min(encodedVal.byteLength, valMaxLen-1); //-1 from valMaxLen for null character\n               wasmMem.mem8.set(encodedVal.slice(0, strLen), valPtr);\n               wasmMem.mem8[strLen + valPtr] = 0; //ensure the null character gets set\n            }\n               break;\n            \n            case D2DType.D2D_SETCANVASPROPDOUBLE:\n            {\n               const val = wasmMem.getDouble(currentInsParams);\n               const namePtr = wasmMem.getLong(currentInsParams+8);\n\n               const propName = wasmMem.getString(namePtr);\n\n               const prevVal = (this.ctx as {[key: string]: any})[propName];\n               if (typeof prevVal != \"number\") throw new Error(\"D2D_SETCANVASPROPDOUBLE with property \" + propName + \" expected a number, got \" + (typeof prevVal) + \"!\");\n               \n               (this.ctx as {[key: string]: any})[propName] = val;\n            }\n            break;\n\n            case D2DType.D2D_SETCANVASPROPSTRING:\n            {\n               const valPtr = wasmMem.getLong(currentInsParams);\n               const namePtr = wasmMem.getLong(currentInsParams+4);\n\n               const val = wasmMem.getString(valPtr);\n               const propName = wasmMem.getString(namePtr);\n\n               const prevVal = (this.ctx as {[key: string]: any})[propName];\n               if (typeof prevVal != \"string\") throw new Error(\"D2D_SETCANVASPROPSTRING with property \" + propName + \" expected a string, got \" + (typeof prevVal) + \"!\");\n\n               (this.ctx as {[key: string]: any})[propName] = val;\n            }\n            break;\n            \n            default:\n               throw new Error (\"unimplemented or unknown Sequence Type in drawSeq: \"+type);\n         }\n         nextInsHdr=wasmMem.getLong(currentInsHdr);  /* hdr->next */\n         if (nextInsHdr==0) {\n               if (currentInsHdr!=lastInsHdr) throw new Error(\"assert type error in twrcanvas, ins!=lastins\");\n               break;\n         }\n         currentInsHdr=nextInsHdr;\n         currentInsParams = currentInsHdr + insHdrSize;\n      }\n   }\n\n}\n\nexport default twrConsoleCanvas;\n\n\n\n\n\n","import { twrCodePageToUnicodeCodePoint, codePageUTF32 } from \"./twrliblocale.js\";\nimport { keyEventToCodePoint } from \"./twrcon.js\";\nimport { IOTypes } from \"./twrcon.js\";\nimport { twrLibrary, twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\nconst TRS80_GRAPHIC_MARKER = 0xE000;\nconst TRS80_GRAPHIC_MARKER_MASK = 0xFF00;\nconst TRS80_GRAPHIC_CHAR_MASK = 0x003F; // would be 0xC0 if we included the graphics marker bit 0x80\n// Term Canvas have a size that will be set based on the character width x height.\n// The display size for a canvas is set in the HTML/JS like this:\n//    canvas.style.width = \"700px\";\n//    canvas.style.height = \"500px\";\nexport class twrConsoleTerminal extends twrLibrary {\n    id;\n    element;\n    ctx;\n    props;\n    size;\n    cellWidth;\n    cellHeight;\n    cellW1;\n    cellW2;\n    cellH1;\n    cellH2;\n    cellH3;\n    isCursorVisible;\n    videoMem;\n    foreColorMem;\n    backColorMem;\n    cpTranslate;\n    keyBuffer = [];\n    keyWaiting;\n    imports = {\n        twrConCharOut: { noBlock: true },\n        twrConGetProp: {},\n        twrConPutStr: { noBlock: true },\n        twrConCharIn: { isAsyncFunction: true, isModuleAsyncOnly: true },\n        twrConSetFocus: { noBlock: true },\n        twrConSetC32: { noBlock: true },\n        twrConCls: { noBlock: true },\n        twrConSetRange: { noBlock: true },\n        twrConSetReset: { noBlock: true },\n        twrConPoint: {},\n        twrConSetCursor: { noBlock: true },\n        twrConSetCursorXY: { noBlock: true },\n        twrConSetColors: { noBlock: true },\n    };\n    libSourcePath = new URL(import.meta.url).pathname;\n    interfaceName = \"twrConsole\";\n    constructor(canvasElement, params = {}) {\n        // all library constructors should start with these two lines\n        super();\n        this.id = twrLibraryInstanceRegistry.register(this);\n        const { foreColor = \"white\", backColor = \"black\", fontSize = 16, widthInChars = 80, heightInChars = 25 } = params;\n        // canvasElement is where we will draw the terminal\n        this.element = canvasElement;\n        if (!(canvasElement && canvasElement instanceof HTMLCanvasElement && canvasElement.getContext))\n            throw new Error(\"Invalid HTMLCanvasElement parameter in twrConsoleTerminal constructor \");\n        let c = canvasElement.getContext(\"2d\");\n        if (!c)\n            throw new Error(\"canvasElement.getContext('2d') failed\");\n        c.font = fontSize.toString() + \"px Courier New\";\n        c.textBaseline = \"top\";\n        const sampleText = \"          \";\n        //const sampleText=String.fromCharCode(2593).repeat(6);   // this shaded block is typically full width in a font\n        const tm = c.measureText(sampleText);\n        const charWidth = Math.ceil(tm.width / sampleText.length); // ceil rounds up (eg .9 -> 1)\n        let fM = c.measureText(\"X\");\n        const charHeight = Math.ceil(fM.fontBoundingBoxAscent + fM.fontBoundingBoxDescent);\n        canvasElement.width = charWidth * widthInChars;\n        canvasElement.height = charHeight * heightInChars;\n        const canvasHeight = canvasElement.height;\n        const canvasWidth = canvasElement.width;\n        //console.log(\"this.props.canvasHeight, this.props.canvasWidth\",this.props.canvasHeight,this.props.canvasWidth);\n        // reset after dims changed.  Not sure if ctx is needed to reset, but others do\n        let c2 = canvasElement.getContext(\"2d\");\n        if (!c2)\n            throw new Error(\"canvas 2D context not found in twrCanvas.constructor (2nd time)\");\n        this.ctx = c2;\n        this.ctx.font = fontSize.toString() + \"px Courier New\";\n        this.ctx.textBaseline = \"top\";\n        c2.fillStyle = backColor;\n        const backColorAsRGB = Number(\"0x\" + c2.fillStyle.slice(1));\n        c2.fillStyle = foreColor;\n        const foreColorAsRGB = Number(\"0x\" + c2.fillStyle.slice(1));\n        const cursorPos = 0;\n        const type = IOTypes.CHARWRITE | IOTypes.CHARREAD | IOTypes.ADDRESSABLE_DISPLAY;\n        this.props = { type, cursorPos, foreColorAsRGB, backColorAsRGB, fontSize, widthInChars, heightInChars, canvasHeight, canvasWidth, charWidth, charHeight };\n        this.isCursorVisible = false;\n        this.size = this.props.widthInChars * this.props.heightInChars;\n        this.videoMem = new Array(this.size);\n        this.foreColorMem = new Array(this.size);\n        this.backColorMem = new Array(this.size);\n        this.cellWidth = this.props.charWidth;\n        this.cellHeight = this.props.charHeight;\n        if (this.cellWidth <= 0)\n            throw new Error(\"invalid cellWidth\");\n        if (this.cellHeight <= 0)\n            throw new Error(\"invalid cellHeight\");\n        // Calc each cell separately to avoid rounding errors\n        this.cellW1 = Math.floor(this.cellWidth / 2);\n        this.cellW2 = this.cellWidth - this.cellW1;\n        this.cellH1 = Math.floor(this.cellHeight / 3);\n        this.cellH2 = this.cellH1;\n        this.cellH3 = this.cellHeight - this.cellH1 - this.cellH2;\n        this.twrConCls();\n        this.cpTranslate = new twrCodePageToUnicodeCodePoint();\n    }\n    getProp(propName) {\n        return this.props[propName];\n    }\n    twrConGetProp(callingMod, pn) {\n        const propName = callingMod.wasmMem.getString(pn);\n        return this.getProp(propName);\n    }\n    keyDown(ev) {\n        if (this.keyWaiting) {\n            const r = keyEventToCodePoint(ev);\n            if (r) {\n                this.keyWaiting(r);\n                this.keyWaiting = undefined;\n            }\n        }\n        else {\n            this.keyBuffer.push(ev);\n        }\n    }\n    RGB_TO_RGBA(x) {\n        return ((x) << 8) | 0xFF; // JavaScript uses 32-bit signed integers for bitwise operations, which means the leftmost bit is the sign bit. \n    }\n    eraseLine() {\n        for (let i = this.props.cursorPos; i < Math.floor(this.props.cursorPos / this.props.widthInChars) * this.props.widthInChars + this.props.widthInChars; i++)\n            this.setC32(i, \" \");\n    }\n    twrConCharOut(callingMod, c, codePage) {\n        const c32 = this.cpTranslate.convert(c, codePage);\n        if (c32 === 0)\n            return;\n        this.charOut(String.fromCodePoint(c32));\n    }\n    charOut(c32) {\n        if (c32.length > 1)\n            throw new Error(\"charOut takes an empty or single char string\");\n        if (c32 === \"\\n\") // newline\n         {\n            if (this.isCursorVisible)\n                this.setC32(this.props.cursorPos, \" \");\n            this.props.cursorPos = Math.floor(this.props.cursorPos / this.props.widthInChars);\n            this.props.cursorPos = this.props.cursorPos * this.props.widthInChars;\n            this.props.cursorPos = this.props.cursorPos + this.props.widthInChars;\n            /* if return put us on a new line that isn't a scroll, erase the line */\n            if (this.props.cursorPos < this.size)\n                this.eraseLine();\n        }\n        else if (c32 === \"\\x08\") // backspace\n         {\n            if (this.props.cursorPos > 0) {\n                if (this.isCursorVisible)\n                    this.setC32(this.props.cursorPos, \" \");\n                this.props.cursorPos--;\n                this.setC32(this.props.cursorPos, \" \");\n            }\n        }\n        else if (c32 === \"\\x0E\") // Turn on cursor, TRS-80 CODE, should probably update to ANSI\n         {\n            this.isCursorVisible = true;\n        }\n        else if (c32 === \"\\x0F\") // Turn off cursor, TRS-80 code\n         {\n            this.setC32(this.props.cursorPos, \" \");\n            this.isCursorVisible = false;\n        }\n        else if (c32 === String.fromCharCode(24)) /* backspace cursor*/ {\n            if (this.props.cursorPos > 0)\n                this.props.cursorPos--;\n        }\n        else if (c32 === String.fromCharCode(25)) /* advance cursor*/ {\n            if (this.props.cursorPos < (this.size - 1))\n                this.props.cursorPos++;\n        }\n        else if (c32 === String.fromCharCode(26)) /* cursor down one line */ {\n            if (this.props.cursorPos < this.props.widthInChars * (this.props.heightInChars - 1))\n                this.props.cursorPos += this.props.widthInChars;\n        }\n        else if (c32 === String.fromCharCode(27)) /* cursor up one line */ {\n            if (this.props.cursorPos >= this.props.widthInChars)\n                this.props.cursorPos -= this.props.widthInChars;\n        }\n        else if (c32 === String.fromCharCode(28)) /* home */ {\n            this.props.cursorPos = 0;\n        }\n        else if (c32 === String.fromCharCode(29)) /* beginning of line */ {\n            this.props.cursorPos = (this.props.cursorPos / this.props.widthInChars) * this.props.widthInChars;\n        }\n        else if (c32 === String.fromCharCode(30)) /* erase to end of line */ {\n            this.eraseLine();\n        }\n        else if (c32 === String.fromCharCode(31)) /* erase to end of frame */ {\n            for (let i = this.props.cursorPos; i < this.size; i++)\n                this.setC32(i, \" \");\n        }\n        else {\n            this.setC32(this.props.cursorPos, c32);\n            this.props.cursorPos++;\n        }\n        // Do we need to scroll?\n        if (this.props.cursorPos == this.size) {\n            this.props.cursorPos = this.props.widthInChars * (this.props.heightInChars - 1);\n            for (let i = 0; i < (this.props.widthInChars * (this.props.heightInChars - 1)); i++) {\n                this.videoMem[i] = this.videoMem[i + this.props.widthInChars];\n                this.backColorMem[i] = this.backColorMem[i + this.props.widthInChars];\n                this.foreColorMem[i] = this.foreColorMem[i + this.props.widthInChars];\n            }\n            for (let i = 0; i < this.props.widthInChars; i++) {\n                this.videoMem[this.size - i - 1] = 32;\n                this.backColorMem[this.size - i - 1] = this.props.backColorAsRGB;\n                this.foreColorMem[this.size - i - 1] = this.props.foreColorAsRGB;\n            }\n            this.drawRange(0, this.size - 1);\n        }\n        if (this.isCursorVisible)\n            this.setC32(this.props.cursorPos, String.fromCodePoint(9611)); // 9611 is graphic block -- same cursor i use in class twrDiv\n        if (this.props.cursorPos >= this.size) {\n            throw new Error(\"internal error: this.props.cursorPos >= this.size\");\n        }\n    }\n    //*************************************************\n    putStr(str) {\n        for (let i = 0; i < str.length; i++)\n            this.twrConCharOut(undefined, str.codePointAt(i) || 0, codePageUTF32);\n    }\n    twrConPutStr(callingMod, chars, codePage) {\n        const str = callingMod.wasmMem.getString(chars, undefined, codePage);\n        for (let i = 0; i < str.length; i++)\n            this.twrConCharOut(callingMod, str.codePointAt(i) || 0, codePageUTF32);\n    }\n    //*************************************************\n    setC32(location, str) {\n        if (str.length > 1)\n            throw new Error(\"setC32 takes an empty or single char string\");\n        this.twrConSetC32(undefined, location, str.codePointAt(0) || 0);\n    }\n    twrConSetC32(callingMod, location, c32) {\n        if (!(location >= 0 && location < this.size))\n            throw new Error(\"Invalid location passed to setC32\");\n        this.videoMem[location] = c32;\n        this.backColorMem[location] = this.props.backColorAsRGB;\n        this.foreColorMem[location] = this.props.foreColorAsRGB;\n        // draw one before and one after to fix any character rendering overlap.  \n        // Can happen with anti-aliasing on graphic chars that fill the cell\n        let start = location - 1;\n        if (start < 0)\n            start = 0;\n        let end = location + 1;\n        if (end >= this.size)\n            end = this.size - 1;\n        this.drawRange(start, end);\n        // draw one line above and below as well to fix any character rendering overlap.  \n        // the block cursor typically can cause an issue\n        const startSave = start;\n        const endSave = end;\n        start = start - this.props.widthInChars;\n        end = end - this.props.widthInChars;\n        if (start < 0)\n            start = 0;\n        if (end < 0)\n            end = 0;\n        this.drawRange(start, end);\n        start = startSave + this.props.widthInChars;\n        end = endSave + this.props.widthInChars;\n        if (start >= this.size)\n            start = this.size - 1;\n        if (end >= this.size)\n            end = this.size - 1;\n        this.drawRange(start, end);\n    }\n    //*************************************************\n    twrConCls() {\n        for (let i = 0; i < this.size; i++) {\n            this.videoMem[i] = 32;\n            this.backColorMem[i] = this.props.backColorAsRGB;\n            this.foreColorMem[i] = this.props.foreColorAsRGB;\n        }\n        this.props.cursorPos = 0;\n        this.isCursorVisible = false;\n        this.drawRange(0, this.size - 1);\n    }\n    setFillStyleRGB(color) {\n        // const cssColor= \"#\"+(\"00000000\" + color.toString(16)).slice(-8);  RGBA\n        const cssColor = `#${color.toString(16).padStart(6, '0')}`;\n        this.ctx.fillStyle = cssColor;\n    }\n    drawTrs80Graphic(offset, val, fgc, bgc) {\n        let x, y;\n        x = (offset % this.props.widthInChars) * this.cellWidth;\n        y = Math.floor(offset / this.props.widthInChars) * this.cellHeight;\n        this.setFillStyleRGB(bgc);\n        this.ctx.fillRect(x, y, this.cellWidth, this.cellHeight);\n        if (val == 32)\n            return;\n        this.setFillStyleRGB(fgc);\n        if (val & 1)\n            this.ctx.fillRect(x, y, this.cellW1, this.cellH1);\n        y = y + this.cellH1;\n        if (val & 4)\n            this.ctx.fillRect(x, y, this.cellW1, this.cellH2);\n        y = y + this.cellH2;\n        if (val & 16)\n            this.ctx.fillRect(x, y, this.cellW1, this.cellH3);\n        x = x + this.cellW1;\n        if (val & 32)\n            this.ctx.fillRect(x, y, this.cellW2, this.cellH3);\n        y = y - this.cellH2;\n        if (val & 8)\n            this.ctx.fillRect(x, y, this.cellW2, this.cellH2);\n        y = y - this.cellH1;\n        if (val & 2)\n            this.ctx.fillRect(x, y, this.cellW2, this.cellH1);\n    }\n    //**************************************************\n    drawCell(offset, value, fgc, bgc) {\n        if ((value & TRS80_GRAPHIC_MARKER_MASK) == TRS80_GRAPHIC_MARKER || value == 32) {\n            this.drawTrs80Graphic(offset, value & TRS80_GRAPHIC_CHAR_MASK, fgc, bgc);\n        }\n        else {\n            let x, y;\n            x = (offset % this.props.widthInChars) * this.cellWidth;\n            y = Math.floor(offset / this.props.widthInChars) * this.cellHeight;\n            this.setFillStyleRGB(bgc);\n            this.ctx.fillRect(x, y, this.cellWidth, this.cellHeight);\n            if (value != 32) {\n                this.setFillStyleRGB(fgc);\n                const txt = String.fromCodePoint(value);\n                this.ctx.fillText(txt, x, y);\n            }\n        }\n    }\n    //*************************************************\n    // !!TODO add ability to setRange colors\n    // !! should this take a bytearray?\n    // !! need to add \"getRange\" to match\n    setRangeJS(start, values) {\n        let k = 0;\n        for (let i = start; i < start + values.length; i++) {\n            this.videoMem[i] = values[k++];\n        }\n        this.drawRange(start, start + values.length - 1);\n    }\n    twrConSetRange(callingMod, chars, start, len) {\n        let values = [];\n        for (let i = start; i < start + len; i++) {\n            values.push(callingMod.wasmMem.getLong(i));\n        }\n        this.setRangeJS(start, values);\n    }\n    drawRange(start, end) {\n        for (let i = start; i <= end; i++) {\n            this.drawCell(i, this.videoMem[i], this.foreColorMem[i], this.backColorMem[i]);\n        }\n    }\n    /*************************************************/\n    twrConSetReset(callingMod, x, y, isset) {\n        const loc = Math.floor(x / 2) + this.props.widthInChars * Math.floor(y / 3);\n        const cellx = x % 2;\n        const celly = y % 3;\n        if (x < 0 || x > this.props.widthInChars * 2)\n            throw new Error(\"setReset: invalid x value\");\n        if (y < 0 || y > this.props.heightInChars * 3)\n            throw new Error(\"setReset: invalid y value\");\n        if (!((this.videoMem[loc] & TRS80_GRAPHIC_MARKER_MASK) == TRS80_GRAPHIC_MARKER)) {\n            this.videoMem[loc] = TRS80_GRAPHIC_MARKER; /* set to a cleared graphics value */\n            this.backColorMem[loc] = this.props.backColorAsRGB;\n            this.foreColorMem[loc] = this.props.foreColorAsRGB;\n        }\n        if (isset)\n            this.videoMem[loc] |= (1 << (celly * 2 + cellx));\n        else\n            this.videoMem[loc] &= ~(1 << (celly * 2 + cellx));\n        this.drawRange(loc, loc);\n    }\n    //*************************************************\n    twrConPoint(callingMod, x, y) {\n        const loc = Math.floor(x / 2) + this.props.widthInChars * Math.floor(y / 3);\n        const cellx = x % 2;\n        const celly = y % 3;\n        if (x < 0 || x > this.props.widthInChars * 2)\n            throw new Error(\"Point: invalid x value\");\n        if (y < 0 || y > this.props.heightInChars * 3)\n            throw new Error(\"Point: invalid y value\");\n        if (!((this.videoMem[loc] & TRS80_GRAPHIC_MARKER_MASK) == TRS80_GRAPHIC_MARKER))\n            return false; /* not a graphic cell, so false */\n        if (this.videoMem[loc] & (1 << (celly * 2 + cellx)))\n            return true;\n        else\n            return false;\n    }\n    //*************************************************\n    twrConSetCursor(callingMod, location) {\n        if (location < 0 || location >= this.size)\n            throw new Error(\"setCursor: invalid location: \" + location);\n        this.props.cursorPos = location;\n    }\n    //*************************************************\n    twrConSetCursorXY(callingMod, x, y) {\n        if (x < 0 || y < 0 || this.props.widthInChars * y + x >= this.size)\n            throw new Error(\"setCursorXY: invalid parameter(s)\");\n        this.twrConSetCursor(callingMod, this.props.widthInChars * y + x);\n    }\n    //*************************************************\n    twrConSetColors(callingMod, foreground, background) {\n        this.props.foreColorAsRGB = foreground;\n        this.props.backColorAsRGB = background;\n    }\n    // TODO!! Should keyBuffer be flushed?  Is keyBuffer needed?\n    async twrConCharIn_async(callingMod) {\n        let ev;\n        return new Promise((resolve) => {\n            if (this.keyWaiting)\n                throw new Error(\"internal error\");\n            while (ev = this.keyBuffer.shift()) {\n                const r = keyEventToCodePoint(ev);\n                if (r) {\n                    resolve(r);\n                    return;\n                }\n            }\n            this.keyWaiting = resolve;\n        });\n    }\n    twrConSetFocus() {\n        this.element.focus();\n    }\n}\nexport default twrConsoleTerminal;\n//TODO!!  Most of these member functions could benefit from a FireAndForget option\n//# sourceMappingURL=twrconterm.js.map","import {twrCodePageToUnicodeCodePoint, codePageUTF32} from \"./twrliblocale.js\"\nimport {IConsoleTerminal, IConsoleTerminalProps, IConsoleTerminalParams, keyEventToCodePoint} from \"./twrcon.js\"\nimport {IOTypes} from \"./twrcon.js\"\nimport {IWasmModuleAsync} from \"./twrmodasync.js\";\nimport {IWasmModule} from \"./twrmod.js\"\nimport {twrLibrary, TLibImports, twrLibraryInstanceRegistry} from \"./twrlibrary.js\";\n\nconst TRS80_GRAPHIC_MARKER=0xE000;\nconst TRS80_GRAPHIC_MARKER_MASK=0xFF00;\nconst TRS80_GRAPHIC_CHAR_MASK=0x003F;    // would be 0xC0 if we included the graphics marker bit 0x80\n\n// Term Canvas have a size that will be set based on the character width x height.\n// The display size for a canvas is set in the HTML/JS like this:\n//    canvas.style.width = \"700px\";\n//    canvas.style.height = \"500px\";\n\n\nexport class twrConsoleTerminal extends twrLibrary implements IConsoleTerminal  {\n   id:number;\n   element:HTMLElement;\n   ctx:CanvasRenderingContext2D;\n   props:IConsoleTerminalProps;\n   size:number;\n   cellWidth:number;\n   cellHeight:number;\n   cellW1:number;\n   cellW2:number; \n   cellH1:number;\n   cellH2:number;\n   cellH3:number;\n   isCursorVisible:boolean;\n   videoMem: number[];\n   foreColorMem: number[];\n   backColorMem: number[];\n\tcpTranslate:twrCodePageToUnicodeCodePoint;\n   keyBuffer:KeyboardEvent[]=[];\n   keyWaiting?:(key:number)=>void;\n\n   imports:TLibImports = {\n      twrConCharOut:{noBlock:true},\n      twrConGetProp:{},\n      twrConPutStr:{noBlock:true},\n      twrConCharIn:{isAsyncFunction: true, isModuleAsyncOnly: true},\n      twrConSetFocus:{noBlock:true},\n      twrConSetC32:{noBlock:true},\n      twrConCls:{noBlock:true},\n      twrConSetRange:{noBlock:true},\n      twrConSetReset:{noBlock:true},\n      twrConPoint:{},\n      twrConSetCursor:{noBlock:true},\n      twrConSetCursorXY:{noBlock:true},\n      twrConSetColors:{noBlock:true},\n   };\n\n   libSourcePath = new URL(import.meta.url).pathname;\n   interfaceName = \"twrConsole\";\n\n    constructor (canvasElement:HTMLCanvasElement, params:IConsoleTerminalParams={}) {\n      // all library constructors should start with these two lines\n      super();\n      this.id=twrLibraryInstanceRegistry.register(this);\n  \n      const {foreColor=\"white\", backColor=\"black\", fontSize=16, widthInChars=80, heightInChars=25} = params; \n\n      // canvasElement is where we will draw the terminal\n      this.element=canvasElement;\n\n      if (!(canvasElement && canvasElement instanceof HTMLCanvasElement && canvasElement.getContext)) \n         throw new Error(\"Invalid HTMLCanvasElement parameter in twrConsoleTerminal constructor \");\n\n      let c=canvasElement.getContext(\"2d\");\n      if (!c) throw new Error(\"canvasElement.getContext('2d') failed\");\n\n      c.font = fontSize.toString()+\"px Courier New\";\n      c.textBaseline=\"top\";\n      const sampleText=\"          \";\n      //const sampleText=String.fromCharCode(2593).repeat(6);   // this shaded block is typically full width in a font\n      const tm=c.measureText(sampleText);\n      const charWidth=Math.ceil(tm.width / sampleText.length);   // ceil rounds up (eg .9 -> 1)\n      let fM = c.measureText(\"X\"); \n      const charHeight = Math.ceil(fM.fontBoundingBoxAscent + fM.fontBoundingBoxDescent);\n\n      canvasElement.width=charWidth*widthInChars;\n      canvasElement.height=charHeight*heightInChars;\n\n      const canvasHeight=canvasElement.height;\n      const canvasWidth=canvasElement.width;\n      //console.log(\"this.props.canvasHeight, this.props.canvasWidth\",this.props.canvasHeight,this.props.canvasWidth);\n\n      // reset after dims changed.  Not sure if ctx is needed to reset, but others do\n      let c2=canvasElement.getContext(\"2d\");\n      if (!c2) throw new Error(\"canvas 2D context not found in twrCanvas.constructor (2nd time)\");\n      this.ctx=c2;\n      this.ctx.font = fontSize.toString()+\"px Courier New\";\n      this.ctx.textBaseline=\"top\";\n\n      c2.fillStyle=backColor;\n      const backColorAsRGB=Number(\"0x\"+c2.fillStyle.slice(1));\n\n      c2.fillStyle=foreColor;\n      const foreColorAsRGB=Number(\"0x\"+c2.fillStyle.slice(1));\n\n      const cursorPos=0;\n      const type=IOTypes.CHARWRITE|IOTypes.CHARREAD|IOTypes.ADDRESSABLE_DISPLAY;\n\n      this.props={type, cursorPos, foreColorAsRGB, backColorAsRGB, fontSize, widthInChars, heightInChars, canvasHeight, canvasWidth, charWidth, charHeight};\n\n      this.isCursorVisible=false;\n      this.size=this.props.widthInChars*this.props.heightInChars;\n      this.videoMem=new Array(this.size);\n      this.foreColorMem=new Array(this.size);\n      this.backColorMem=new Array(this.size);\n\n      this.cellWidth = this.props.charWidth;\n      this.cellHeight = this.props.charHeight;\n      if (this.cellWidth<=0) throw new Error(\"invalid cellWidth\");\n      if (this.cellHeight<=0) throw new Error(\"invalid cellHeight\");\n   \n      // Calc each cell separately to avoid rounding errors\n      this.cellW1 = Math.floor(this.cellWidth / 2);  \n      this.cellW2 = this.cellWidth - this.cellW1;  \n      this.cellH1 = Math.floor(this.cellHeight / 3);\n      this.cellH2 = this.cellH1;\n      this.cellH3 = this.cellHeight - this.cellH1 - this.cellH2;\n\n\t\tthis.twrConCls();\n\n\t\tthis.cpTranslate=new twrCodePageToUnicodeCodePoint();\n   }\n\n   getProp(propName: string): number {\n      return this.props[propName];\n   }\n   \n   twrConGetProp(callingMod:IWasmModule|IWasmModuleAsync, pn:number):number {\n      const propName=callingMod.wasmMem.getString(pn);\n      return this.getProp(propName);\n   }\n\n   keyDown(ev:KeyboardEvent)  {\n      if (this.keyWaiting) {\n         const r=keyEventToCodePoint(ev);\n         if (r) {\n            this.keyWaiting(r);\n            this.keyWaiting=undefined;\n         }\n      }\n      else {\n         this.keyBuffer.push(ev);\n      }\n   }\n\n   private RGB_TO_RGBA(x:number) {\n      return  ((x)<<8) | 0xFF;  // JavaScript uses 32-bit signed integers for bitwise operations, which means the leftmost bit is the sign bit. \n   }\n\n   private eraseLine()\n   {\n      for (let i=this.props.cursorPos; i < Math.floor(this.props.cursorPos/this.props.widthInChars)*this.props.widthInChars+this.props.widthInChars; i++)\n         this.setC32(i, \" \");\n   }\n      \n   twrConCharOut(callingMod:any, c:number, codePage:number)\n   {\n\n      const c32=this.cpTranslate.convert(c, codePage);\n      if (c32===0) return;\n\n      this.charOut(String.fromCodePoint(c32));\n   }\n\n   charOut(c32:string) {\n\n      if (c32.length>1) \n         throw new Error(\"charOut takes an empty or single char string\");\n      \n      if (c32===\"\\n\")\t// newline\n      {\n         if (this.isCursorVisible)\n            this.setC32(this.props.cursorPos, \" \");\n         \n         this.props.cursorPos = Math.floor(this.props.cursorPos/this.props.widthInChars);\n         this.props.cursorPos = this.props.cursorPos*this.props.widthInChars;\n         this.props.cursorPos = this.props.cursorPos + this.props.widthInChars;\n         \n         /* if return put us on a new line that isn't a scroll, erase the line */\n         if (this.props.cursorPos < this.size)\t\n            this.eraseLine();\n      }\n      else if (c32===\"\\x08\")\t// backspace\n      {\n         if (this.props.cursorPos > 0)\n         {\n            if (this.isCursorVisible)\n               this.setC32(this.props.cursorPos, \" \");\n            this.props.cursorPos--;\n            this.setC32(this.props.cursorPos, \" \");\n         }\n      }\n      else if (c32===\"\\x0E\")\t// Turn on cursor, TRS-80 CODE, should probably update to ANSI\n      {\n         this.isCursorVisible = true;\n      }\n      else if (c32===\"\\x0F\")\t// Turn off cursor, TRS-80 code\n      {\n         this.setC32(this.props.cursorPos, \" \");\n         this.isCursorVisible = false;\n      }\n      else if (c32===String.fromCharCode(24))\t/* backspace cursor*/\n      {\n         if (this.props.cursorPos > 0)\n            this.props.cursorPos--;\n      }\n      else if (c32===String.fromCharCode(25))\t/* advance cursor*/\n      {\n         if (this.props.cursorPos < (this.size-1))\n            this.props.cursorPos++;\n      }\n      else if (c32===String.fromCharCode(26))\t/* cursor down one line */\n      {\n         if (this.props.cursorPos < this.props.widthInChars*(this.props.heightInChars-1))\n            this.props.cursorPos+=this.props.widthInChars;\n      }\n      else if (c32===String.fromCharCode(27))\t/* cursor up one line */\n      {\n         if (this.props.cursorPos >= this.props.widthInChars)\n            this.props.cursorPos-=this.props.widthInChars;\n      }\n      else if (c32===String.fromCharCode(28))\t/* home */\n      {\n         this.props.cursorPos=0;\n      }\n      else if (c32===String.fromCharCode(29))\t/* beginning of line */\n      {\n         this.props.cursorPos=(this.props.cursorPos/this.props.widthInChars)*this.props.widthInChars;\n      }\n      else if (c32===String.fromCharCode(30))\t/* erase to end of line */\n      {\n         this.eraseLine();\n      }\n      else if (c32===String.fromCharCode(31))\t/* erase to end of frame */\n      {\n         for (let i=this.props.cursorPos; i < this.size; i++)\n            this.setC32(i, \" \");\n      }\n      else\n      {\n         this.setC32(this.props.cursorPos, c32);\n         this.props.cursorPos++;\n      }\n\n      // Do we need to scroll?\n      if (this.props.cursorPos == this.size)\t\n      {\n         this.props.cursorPos = this.props.widthInChars*(this.props.heightInChars-1);\n         for (let i=0; i < (this.props.widthInChars*(this.props.heightInChars-1)); i++) {\n            this.videoMem[i] = this.videoMem[i+this.props.widthInChars];\n            this.backColorMem[i] = this.backColorMem[i+this.props.widthInChars];\n            this.foreColorMem[i] = this.foreColorMem[i+this.props.widthInChars];\n         }\n\n         for (let i=0; i < this.props.widthInChars; i++) {\n            this.videoMem[this.size-i-1] = 32;\n            this.backColorMem[this.size-i-1] = this.props.backColorAsRGB;\n            this.foreColorMem[this.size-i-1] = this.props.foreColorAsRGB;\n         }\n\n         this.drawRange(0, this.size-1);\n      }\n\n      if (this.isCursorVisible)\n         this.setC32(this.props.cursorPos, String.fromCodePoint(9611));  // 9611 is graphic block -- same cursor i use in class twrDiv\n\n      if (this.props.cursorPos >= this.size)\n      {\n         throw new Error(\"internal error: this.props.cursorPos >= this.size\");\n      }\n   }\n\n   //*************************************************\n\n   putStr(str:string) {\n      for (let i=0; i < str.length; i++)\n         this.twrConCharOut(undefined, str.codePointAt(i)||0, codePageUTF32);\n   }\n\n   twrConPutStr(callingMod:IWasmModule|IWasmModuleAsync, chars:number, codePage:number) {\n      const str=callingMod.wasmMem.getString(chars, undefined, codePage);\n      for (let i=0; i < str.length; i++)\n         this.twrConCharOut(callingMod, str.codePointAt(i)||0, codePageUTF32);\n   }\n\n   //*************************************************\n   setC32(location:number, str:string) : void {\n      if (str.length>1) \n         throw new Error(\"setC32 takes an empty or single char string\");\n\n      this.twrConSetC32(undefined, location, str.codePointAt(0)||0)\n   }\n\n   twrConSetC32(callingMod:any, location:number, c32:number) : void\n   {\n      if (!(location>=0 && location<this.size)) \n         throw new Error(\"Invalid location passed to setC32\")\n\n      this.videoMem[location]=c32;\n      this.backColorMem[location]=this.props.backColorAsRGB;\n      this.foreColorMem[location]=this.props.foreColorAsRGB;\n      \n      // draw one before and one after to fix any character rendering overlap.  \n      // Can happen with anti-aliasing on graphic chars that fill the cell\n      let start=location-1;\n      if (start<0) start=0;\n      let end=location+1;\n      if (end >= this.size) end=this.size-1;\n      this.drawRange(start, end);\n\n      // draw one line above and below as well to fix any character rendering overlap.  \n      // the block cursor typically can cause an issue\n      const startSave=start;\n      const endSave=end;\n      start=start-this.props.widthInChars;\n      end=end-this.props.widthInChars;\n      if (start<0) start=0;\n      if (end<0) end=0;\n      this.drawRange(start, end);  \n\n      start=startSave+this.props.widthInChars;\n      end=endSave+this.props.widthInChars;\n      if (start >= this.size) start=this.size-1;\n      if (end >= this.size) end=this.size-1;\n      this.drawRange(start, end);    \n   }\n\n   //*************************************************\n\n   twrConCls()\n   {\n      for (let i=0; i < this.size; i++) {\n         this.videoMem[i]=32;\n         this.backColorMem[i]=this.props.backColorAsRGB;\n         this.foreColorMem[i]=this.props.foreColorAsRGB;\n      }\n\n      this.props.cursorPos = 0;\n      this.isCursorVisible = false;\n\n      this.drawRange(0, this.size-1);\n   }\n\n   private setFillStyleRGB(color:number) {\n      // const cssColor= \"#\"+(\"00000000\" + color.toString(16)).slice(-8);  RGBA\n\t\tconst cssColor = `#${color.toString(16).padStart(6, '0')}`;\n      this.ctx.fillStyle = cssColor;\n   }\n\n   private drawTrs80Graphic(offset:number, val:number, fgc:number, bgc:number)\n   {\n      let x, y;\n   \n      x = (offset%this.props.widthInChars)*this.cellWidth;\n      y = Math.floor(offset/this.props.widthInChars)*this.cellHeight;\n   \n      this.setFillStyleRGB(bgc);\n      this.ctx.fillRect(x, y, this.cellWidth, this.cellHeight);\n   \n      if (val == 32)\n         return;\n   \n      this.setFillStyleRGB(fgc);\n   \n      if (val&1)\n         this.ctx.fillRect(x, y, this.cellW1, this.cellH1);\n   \n      y=y+this.cellH1;\n   \n      if (val&4)\n         this.ctx.fillRect(x, y, this.cellW1, this.cellH2);\n   \n      y=y+this.cellH2;\n   \n      if (val&16)\n         this.ctx.fillRect(x, y, this.cellW1, this.cellH3);\n   \n      x=x+this.cellW1;\n   \n      if (val&32)\n         this.ctx.fillRect(x, y, this.cellW2, this.cellH3);\n   \n      y=y-this.cellH2;\n   \n      if (val&8)\n         this.ctx.fillRect(x, y, this.cellW2, this.cellH2);\n   \n      y=y-this.cellH1;\n   \n      if (val&2)\n         this.ctx.fillRect(x, y, this.cellW2, this.cellH1);\n   \n   } \n   \n   //**************************************************\n   \n   private drawCell(offset:number, value:number, fgc:number, bgc:number)\n   {\n      if ( (value&TRS80_GRAPHIC_MARKER_MASK)==TRS80_GRAPHIC_MARKER || value==32)\n      {\n         this.drawTrs80Graphic(offset, value&TRS80_GRAPHIC_CHAR_MASK, fgc, bgc);\n      }\n      else\n      {\n         let x, y;\n   \n         x = (offset%this.props.widthInChars)*this.cellWidth;\n         y = Math.floor(offset/this.props.widthInChars)*this.cellHeight;\n   \n         this.setFillStyleRGB(bgc);\n         this.ctx.fillRect(x, y, this.cellWidth, this.cellHeight);\n         if (value!=32) {\n            this.setFillStyleRGB(fgc);\n            const txt=String.fromCodePoint(value);\n            this.ctx.fillText(txt, x, y);\n         }\n      }\n   }\n   \n   //*************************************************\n   // !!TODO add ability to setRange colors\n   // !! should this take a bytearray?\n   // !! need to add \"getRange\" to match\n   setRangeJS(start:number, values:number[])\n   {\n      let k=0;\n      for (let i=start; i < start+values.length; i++) {\n         this.videoMem[i]=values[k++];\n      }\n      this.drawRange(start, start+values.length-1)\n   }\n\n   twrConSetRange(callingMod:IWasmModule|IWasmModuleAsync, chars:number, start:number, len:number) {\n      let values:number[]=[];\n      for (let i=start; i<start+len; i++) {\n         values.push(callingMod.wasmMem.getLong(i));\n      }\n      this.setRangeJS(start, values);\n   }\n\n   private drawRange(start:number, end:number)\n   {\n      for (let i=start; i <= end; i++) {\n         this.drawCell(i, this.videoMem[i], this.foreColorMem[i], this.backColorMem[i] );\n      }\n   }\n\n   /*************************************************/\n\n   twrConSetReset(callingMod:IWasmModule|IWasmModuleAsync, x:number, y:number, isset:boolean) : void\n   {\n      const loc = Math.floor(x/2)+this.props.widthInChars*Math.floor(y/3);\n      const cellx = x%2;\n      const celly = y%3;\n\n      if (x<0 || x>this.props.widthInChars*2) throw new Error(\"setReset: invalid x value\");\n      if (y<0 || y>this.props.heightInChars*3) throw new Error(\"setReset: invalid y value\");\n\n      if (!((this.videoMem[loc]&TRS80_GRAPHIC_MARKER_MASK)==TRS80_GRAPHIC_MARKER)) {\n         this.videoMem[loc]= TRS80_GRAPHIC_MARKER;\t/* set to a cleared graphics value */\n         this.backColorMem[loc]=this.props.backColorAsRGB;\n         this.foreColorMem[loc]=this.props.foreColorAsRGB;\n      }\n\n      if (isset)\n         this.videoMem[loc]|= (1<<(celly*2+cellx));\n      else\n         this.videoMem[loc]&= ~(1<<(celly*2+cellx));\n\n      this.drawRange(loc, loc);\n   }\n\n   //*************************************************\n\n   twrConPoint(callingMod:IWasmModule|IWasmModuleAsync, x:number, y:number) : boolean\n   {\n      const loc = Math.floor(x/2)+this.props.widthInChars*Math.floor(y/3);\n      const cellx = x%2;\n      const celly = y%3;\n\n      if (x<0 || x>this.props.widthInChars*2) throw new Error(\"Point: invalid x value\");\n      if (y<0 || y>this.props.heightInChars*3) throw new Error(\"Point: invalid y value\");\n\n      if (!((this.videoMem[loc]&TRS80_GRAPHIC_MARKER_MASK)==TRS80_GRAPHIC_MARKER))\n         return false;\t/* not a graphic cell, so false */\n\n      if (this.videoMem[loc]&(1<<(celly*2+cellx)))\n         return true;\n      else \n         return false;\n   }\n\n\n   //*************************************************\n\n   twrConSetCursor(callingMod:IWasmModule|IWasmModuleAsync, location:number) : void\n   {\n      if (location<0 || location>=this.size) throw new Error(\"setCursor: invalid location: \"+location);\n\n      this.props.cursorPos = location;\n   }\n\n   //*************************************************\n\n   twrConSetCursorXY(callingMod:IWasmModule|IWasmModuleAsync, x:number, y:number) {\n      if (x<0 || y<0 || this.props.widthInChars*y+x >= this.size) throw new Error(\"setCursorXY: invalid parameter(s)\");\n      this.twrConSetCursor(callingMod, this.props.widthInChars*y+x); \n   }\n\n   //*************************************************\n\n   twrConSetColors(callingMod:IWasmModule|IWasmModuleAsync, foreground:number, background:number) : void \n   {\n      this.props.foreColorAsRGB=foreground;\n      this.props.backColorAsRGB=background;\n   }\n\n   // TODO!! Should keyBuffer be flushed?  Is keyBuffer needed?\n   async twrConCharIn_async(callingMod: IWasmModuleAsync):Promise<number> {\n      let ev:KeyboardEvent|undefined;\n\n      return new Promise( (resolve) => {\n         if (this.keyWaiting)\n            throw new Error(\"internal error\");\n         while (ev=this.keyBuffer.shift()) {\n            const r=keyEventToCodePoint(ev);\n            if (r) {\n               resolve(r);\n               return;\n            }\n         }\n\n         this.keyWaiting=resolve;\n\n      });\n   }\n\n   twrConSetFocus() {\n      this.element.focus();\n   }\n}\n\nexport default twrConsoleTerminal;\n   \n//TODO!!  Most of these member functions could benefit from a FireAndForget option\n\n\n   ","import { IOTypes } from \"./twrcon.js\";\nimport { twrCodePageToUnicodeCodePoint } from \"./twrliblocale.js\";\nimport { twrLibrary, twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\nexport class twrConsoleDebug extends twrLibrary {\n    id;\n    logline = \"\";\n    element = undefined;\n    cpTranslate;\n    imports = {\n        twrConCharOut: { noBlock: true },\n        twrConGetProp: {},\n        twrConPutStr: { noBlock: true },\n    };\n    libSourcePath = new URL(import.meta.url).pathname;\n    interfaceName = \"twrConsole\";\n    constructor() {\n        // all library constructors should start with these two lines\n        super();\n        this.id = twrLibraryInstanceRegistry.register(this);\n        this.cpTranslate = new twrCodePageToUnicodeCodePoint();\n    }\n    charOut(ch) {\n        if (ch.length > 1)\n            throw new Error(\"charOut takes an empty string or a single char string\");\n        if (ch === '\\n') {\n            console.log(this.logline); // ideally without a linefeed, but there is no way to not have a LF with console.log API.\n            this.logline = \"\";\n        }\n        else {\n            this.logline = this.logline + ch;\n            if (this.logline.length >= 300) {\n                console.log(this.logline);\n                this.logline = \"\";\n            }\n        }\n    }\n    twrConCharOut(callingMod, ch, codePage) {\n        const char = this.cpTranslate.convert(ch, codePage);\n        if (char > 0)\n            this.charOut(String.fromCodePoint(char));\n    }\n    getProp(propName) {\n        if (propName === \"type\")\n            return IOTypes.CHARWRITE;\n        console.log(\"twrConsoleDebug.getProp passed unknown property name: \", propName);\n        return 0;\n    }\n    twrConGetProp(callingMod, pn) {\n        const propName = callingMod.wasmMem.getString(pn);\n        return this.getProp(propName);\n    }\n    putStr(str) {\n        for (let i = 0; i < str.length; i++)\n            this.charOut(str[i]);\n    }\n    twrConPutStr(callingMod, chars, codePage) {\n        this.putStr(callingMod.wasmMem.getString(chars, undefined, codePage));\n    }\n}\nexport default twrConsoleDebug;\n//# sourceMappingURL=twrcondebug.js.map","\n\nimport {IConsoleStreamOut, IOTypes} from \"./twrcon.js\"\nimport {twrCodePageToUnicodeCodePoint} from \"./twrliblocale.js\"\nimport {IWasmModuleAsync} from \"./twrmodasync.js\";\nimport {IWasmModule} from \"./twrmod.js\"\nimport {twrLibrary, TLibImports, twrLibraryInstanceRegistry} from \"./twrlibrary.js\";\n\nexport class twrConsoleDebug extends twrLibrary implements IConsoleStreamOut {\n   id:number;\n   logline=\"\";\n   element=undefined;\n   cpTranslate:twrCodePageToUnicodeCodePoint;\n\n   imports:TLibImports = {\n      twrConCharOut:{noBlock:true},\n      twrConGetProp:{},\n      twrConPutStr:{noBlock:true},\n   };\n\n   libSourcePath = new URL(import.meta.url).pathname;\n   interfaceName = \"twrConsole\";\n\n   constructor() {\n      // all library constructors should start with these two lines\n      super();\n      this.id=twrLibraryInstanceRegistry.register(this);\n      \n      this.cpTranslate=new twrCodePageToUnicodeCodePoint();\n   }\n\n   charOut(ch:string) {\n      if (ch.length>1) \n         throw new Error(\"charOut takes an empty string or a single char string\");\n\n      if (ch==='\\n') {  \n         console.log(this.logline);\t// ideally without a linefeed, but there is no way to not have a LF with console.log API.\n         this.logline=\"\";\n      }\n      else {\n         this.logline=this.logline+ch;\n         if (this.logline.length>=300) {\n            console.log(this.logline);\n            this.logline=\"\";\n         }\n      }\n   }\n\n   twrConCharOut(callingMod:IWasmModule|IWasmModuleAsync, ch:number, codePage:number) {\n      const char=this.cpTranslate.convert(ch, codePage);\n      if (char>0) \n         this.charOut(String.fromCodePoint(char));\n   }\n\n   getProp(propName: string):number {\n      if (propName===\"type\") return IOTypes.CHARWRITE;  \n      console.log(\"twrConsoleDebug.getProp passed unknown property name: \", propName)\n      return 0;\n   }\n\n   twrConGetProp(callingMod:IWasmModule|IWasmModuleAsync, pn:number):number {\n      const propName=callingMod.wasmMem.getString(pn);\n      return this.getProp(propName);\n   }\n   \n   putStr(str:string) {\n      for (let i=0; i < str.length; i++)\n         this.charOut(str[i]);\n   }\n\n   twrConPutStr(callingMod:IWasmModule|IWasmModuleAsync,  chars:number, codePage:number) {\n      this.putStr(callingMod.wasmMem.getString(chars, undefined, codePage));\n   }\n\n}\n\nexport default twrConsoleDebug;\n","// pre-installed libraries go in this file\nimport twrLibMathMod from \"./twrlibmath.js\";\nimport twrLibLocaleMod from \"./twrliblocale.js\";\nimport twrLibTimerMod from \"./twrlibtimer.js\";\nimport twrLibAudio from \"./twrlibaudio.js\";\nimport twrLibDateMod from \"./twrlibdate.js\";\nimport twrConsoleDummy from \"./twrcondummy.js\";\n// currently, libraries can only have one instance\nlet defaultLibsAreRegistered = false;\nexport async function twrLibBuiltIns() {\n    if (!defaultLibsAreRegistered) {\n        // add builtin libraries here:\n        new twrLibMathMod; // will register self in twrLibraryInstanceRegistry\n        new twrLibLocaleMod;\n        new twrLibTimerMod;\n        new twrLibAudio;\n        new twrLibDateMod;\n        new twrConsoleDummy;\n        defaultLibsAreRegistered = true;\n    }\n}\n//# sourceMappingURL=twrlibbuiltin.js.map","// pre-installed libraries go in this file\n\nimport {twrLibraryInstanceRegistry} from \"./twrlibrary\"\n\nimport twrLibMathMod from \"./twrlibmath.js\";\nimport twrLibLocaleMod from \"./twrliblocale.js\"\nimport twrLibTimerMod from \"./twrlibtimer.js\"\n\nimport twrLibAudio from \"./twrlibaudio.js\";\nimport twrLibDateMod from \"./twrlibdate.js\"\nimport twrConsoleDummy from \"./twrcondummy.js\"\n\n// currently, libraries can only have one instance\nlet defaultLibsAreRegistered=false;\n\nexport async function twrLibBuiltIns() {\n   if (!defaultLibsAreRegistered) {\n\n      // add builtin libraries here:\n      new twrLibMathMod;  // will register self in twrLibraryInstanceRegistry\n      new twrLibLocaleMod;\n      new twrLibTimerMod;\n      new twrLibAudio;\n      new twrLibDateMod;\n      new twrConsoleDummy;\n\n      defaultLibsAreRegistered=true;\n   }\n}\n","import { twrLibrary, twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\n// add built-in Libraries (like this one) to twrLibBultins\n// libraries use the default export\nexport default class twrLibMath extends twrLibrary {\n    id;\n    imports = {\n        twrSin: { isCommonCode: true },\n        twrCos: { isCommonCode: true },\n        twrTan: { isCommonCode: true },\n        twrACos: { isCommonCode: true },\n        twrASin: { isCommonCode: true },\n        twrATan: { isCommonCode: true },\n        twrATan2: { isCommonCode: true },\n        twrFAbs: { isCommonCode: true },\n        twrExp: { isCommonCode: true },\n        twrFloor: { isCommonCode: true },\n        twrCeil: { isCommonCode: true },\n        twrLog: { isCommonCode: true },\n        twrSqrt: { isCommonCode: true },\n        twrTrunc: { isCommonCode: true },\n        twrFMod: { isCommonCode: true },\n        twrPow: { isCommonCode: true },\n        twrAtod: { isCommonCode: true },\n        twrDtoa: { isCommonCode: true },\n        twrToFixed: { isCommonCode: true },\n        twrToExponential: { isCommonCode: true },\n        twrFcvtS: { isCommonCode: true },\n    };\n    libSourcePath = new URL(import.meta.url).pathname;\n    constructor() {\n        // all library constructors should start with these two lines\n        super();\n        this.id = twrLibraryInstanceRegistry.register(this);\n    }\n    //////////////////////////////////////////////////////////////////////////////////////\n    // isCommonCode is set -- this means these functions will be used by twrWasmModuleAsync as well as twrWasmModule\n    // This means the functions in twrWasmModuleAsync will not RPC into the JS main thread.\n    // isCommonCode can only be used for functions that runs in a Worker thread, and that don't require the async keyword.\n    twrSin(callingMod, angle) { return Math.sin(angle); }\n    twrCos(callingMod, angle) { return Math.cos(angle); }\n    twrTan(callingMod, angle) { return Math.tan(angle); }\n    twrACos(callingMod, p) { return Math.acos(p); }\n    twrASin(callingMod, p) { return Math.asin(p); }\n    twrATan(callingMod, p) { return Math.atan(p); }\n    twrATan2(callingMod, y, x) { return Math.atan2(y, x); }\n    twrFAbs(callingMod, p) { return Math.abs(p); }\n    twrExp(callingMod, p) { return Math.exp(p); }\n    twrFloor(callingMod, p) { return Math.floor(p); }\n    twrCeil(callingMod, p) { return Math.ceil(p); }\n    twrLog(callingMod, p) { return Math.log(p); }\n    twrSqrt(callingMod, p) { return Math.sqrt(p); }\n    twrTrunc(callingMod, p) { return Math.trunc(p); }\n    twrFMod(callingMod, x, y) { return x % y; }\n    twrPow(callingMod, x, y) { return Math.pow(x, y); }\n    twrAtod(callingMod, ...p) { return this.atod(callingMod.wasmMem, ...p); }\n    twrDtoa(callingMod, ...p) { this.dtoa(callingMod.wasmMem, ...p); }\n    twrToFixed(callingMod, ...p) { this.toFixed(callingMod.wasmMem, ...p); }\n    twrToExponential(callingMod, ...p) { this.toExponential(callingMod.wasmMem, ...p); }\n    twrFcvtS(callingMod, ...p) { return this.fcvtS(callingMod.wasmMem, ...p); }\n    //////////////////////////////////////////////////////////////////////////////////////\n    atod(mem, strptr, len) {\n        const str = mem.getString(strptr, len);\n        const upper = str.trimStart().toUpperCase();\n        if (upper == \"INF\" || upper == \"+INF\" || upper == \"INFINITY\" || upper == \"+INFINITY\")\n            return Number.POSITIVE_INFINITY;\n        else if (upper == \"-INF\" || upper == \"-INFINITY\")\n            return Number.NEGATIVE_INFINITY;\n        else {\n            // allow D for exponent -- old microsoft format they still support in _fctv and I support in my awbasic\n            // parseFloat will handle 'Infinity' and'-Infinity' literal\n            // parseFloat appears to be case sensitive when parsing 'Infinity'\n            // parseFloat ignores leading whitespace\n            // parseFloat() is more lenient than Number() because it ignores trailing invalid characters\n            const r = Number.parseFloat(str.replaceAll('D', 'e').replaceAll('d', 'e'));\n            return r;\n        }\n    }\n    dtoa(mem, buffer, buffer_size, value, max_precision) {\n        if (max_precision == -1) {\n            const r = value.toString();\n            mem.copyString(buffer, buffer_size, r);\n        }\n        else {\n            let r = value.toString();\n            if (r.length > max_precision)\n                r = value.toPrecision(max_precision);\n            mem.copyString(buffer, buffer_size, r);\n        }\n    }\n    toFixed(mem, buffer, buffer_size, value, decdigits) {\n        const r = value.toFixed(decdigits);\n        mem.copyString(buffer, buffer_size, r);\n    }\n    toExponential(mem, buffer, buffer_size, value, decdigits) {\n        const r = value.toExponential(decdigits);\n        mem.copyString(buffer, buffer_size, r);\n    }\n    // emulates the MS C lib function _fcvt_s, but doesn't support all ranges of number.\n    // Number.toFixed() has a max size of 100 fractional digits,  and values must be less than 1e+21\n    // Negative exponents must be now smaller than 1e-99\n    // fully-function C version also int he source, but this is the version enabled by default\n    fcvtS(mem, buffer, // char *\n    sizeInBytes, //size_t\n    value, // double\n    fracpart_numdigits, //int\n    dec, // int *\n    sign // int *\n    ) {\n        if (buffer == 0 || sign == 0 || dec == 0 || sizeInBytes < 1)\n            return 1;\n        let digits;\n        let decpos;\n        let s = 0; // default to positive\n        if (Number.isNaN(value)) { /* nan */\n            digits = \"1#QNAN00000000000000000000000000000\".slice(0, fracpart_numdigits + 1);\n            decpos = 1;\n        }\n        else if (!Number.isFinite(value)) { /* infinity */\n            digits = \"1#INF00000000000000000000000000000\".slice(0, fracpart_numdigits + 1);\n            decpos = 1;\n        }\n        else if (value == 0) {\n            digits = \"000000000000000000000000000000000000\".slice(0, fracpart_numdigits);\n            decpos = 0;\n        }\n        else {\n            if (value < 0) {\n                s = 1; // negative\n                value = Math.abs(value);\n            }\n            if (fracpart_numdigits > 100 || value > 1e+21 || value < 1e-99) {\n                mem.copyString(buffer, sizeInBytes, \"\");\n                mem.mem32[dec] = 0;\n                return 1;\n            }\n            const roundValStr = value.toFixed(fracpart_numdigits);\n            let [intPart = \"\", fracPart = \"\"] = roundValStr.split('.');\n            if (intPart == \"0\")\n                intPart = \"\";\n            if (intPart.length > 0) { // has integer part\n                decpos = intPart.length;\n                digits = intPart + fracPart;\n            }\n            else { // only a fraction\n                digits = fracPart.replace(/^0+/, \"\"); // remove leading zeros\n                decpos = digits.length - fracPart.length;\n            }\n        }\n        if (sizeInBytes - 1 < digits.length)\n            return 1;\n        mem.copyString(buffer, sizeInBytes, digits);\n        mem.setLong(dec, decpos);\n        mem.setLong(sign, s);\n        return 0;\n        /*\n        this version 'works' with larger numbers than using toFixed, but doesn't round correctly\n  \n        let decpos=0;\n        let digits:string;\n        if (value!=0) decpos=Math.floor(Math.log10(value))+1;\n  \n        if (decpos>0) { // has integer part\n           const intlen=Math.max(decpos, 0);\n           console.log(\"intlen=\",intlen, \"decpos=\",decpos);\n           const [nonExponent, exponent=0] = value.toPrecision(intlen+fracpart_numdigits).split('e');\n           digits=nonExponent.replace('.', '');\n           digits=digits.replace(/^0+/,\"\");  // remove leading zeros\n        }\n        else { // only a fraction\n           const intpart=Math.trunc(value);\n           const fracpart=value-intpart;\n           const prec=fracpart_numdigits- (-decpos);\n           console.log(\"prec=\",prec);\n           if (prec<1) {\n                 digits=\"\";\n           }\n           else {\n                 const [nonExponent, exponent=0] = fracpart.toPrecision(prec).split('e');\n                 digits=nonExponent.replace('.', '');\n                 digits=digits.replace(/^0+/,\"\");\n           }\n        }\n  \n        console.log(\"fcvtS value\",value,\"fracpart_numdigits\",fracpart_numdigits);\n        console.log('digits=',digits);\n        console.log('dec=',decpos);\n        console.log(\"sign=\",s);\n     */\n    }\n}\n//# sourceMappingURL=twrlibmath.js.map","import {IWasmModule} from \"./twrmod.js\"\nimport {twrWasmBase} from \"./twrwasmbase.js\"\nimport {IWasmMemoryBase} from \"./twrwasmmem\";\nimport {twrLibrary, TLibImports, twrLibraryInstanceRegistry} from \"./twrlibrary.js\";\n\n// add built-in Libraries (like this one) to twrLibBultins\n// libraries use the default export\nexport default class twrLibMath extends twrLibrary {\n   id:number;\n   imports:TLibImports = {\n      twrSin:{isCommonCode: true},\n      twrCos:{isCommonCode: true},\n      twrTan:{isCommonCode: true},\n      twrACos:{isCommonCode: true},\n      twrASin:{isCommonCode: true},\n      twrATan:{isCommonCode: true},\n      twrATan2: {isCommonCode: true},\n      twrFAbs:{isCommonCode: true},\n      twrExp:{isCommonCode: true},\n      twrFloor:{isCommonCode: true},\n      twrCeil:{isCommonCode: true},\n      twrLog:{isCommonCode: true},\n      twrSqrt:{isCommonCode: true},\n      twrTrunc:{isCommonCode: true},\n      twrFMod:{isCommonCode: true},\n      twrPow:{isCommonCode: true},\n      twrAtod:{isCommonCode: true},\n      twrDtoa:{isCommonCode: true},\n      twrToFixed:{isCommonCode: true},\n      twrToExponential:{isCommonCode: true},\n      twrFcvtS:{isCommonCode: true},\n   };\n\n   libSourcePath = new URL(import.meta.url).pathname;\n\n   constructor() {\n      // all library constructors should start with these two lines\n      super();\n      this.id=twrLibraryInstanceRegistry.register(this);\n   }\n\n   //////////////////////////////////////////////////////////////////////////////////////\n\n   // isCommonCode is set -- this means these functions will be used by twrWasmModuleAsync as well as twrWasmModule\n   // This means the functions in twrWasmModuleAsync will not RPC into the JS main thread.\n   // isCommonCode can only be used for functions that runs in a Worker thread, and that don't require the async keyword.\n   twrSin(callingMod:IWasmModule|twrWasmBase, angle:number ) {return Math.sin(angle);}\n   twrCos(callingMod:IWasmModule|twrWasmBase, angle:number ) {return Math.cos(angle);}\n   twrTan(callingMod:IWasmModule|twrWasmBase, angle:number ) {return Math.tan(angle);}\n   twrACos(callingMod:IWasmModule|twrWasmBase, p:number ) {return Math.acos(p);}\n   twrASin(callingMod:IWasmModule|twrWasmBase, p:number ) {return Math.asin(p);}\n   twrATan(callingMod:IWasmModule|twrWasmBase, p:number ) {return Math.atan(p);}\n   twrATan2(callingMod:IWasmModule|twrWasmBase, y:number, x:number ) {return Math.atan2(y, x)}\n   twrFAbs(callingMod:IWasmModule|twrWasmBase, p:number ) {return Math.abs(p);}\n   twrExp(callingMod:IWasmModule|twrWasmBase, p:number ) {return Math.exp(p);}\n   twrFloor(callingMod:IWasmModule|twrWasmBase, p:number ) {return Math.floor(p);}\n   twrCeil(callingMod:IWasmModule|twrWasmBase, p:number ) {return Math.ceil(p);}\n   twrLog(callingMod:IWasmModule|twrWasmBase, p:number ) {return Math.log(p);}\n   twrSqrt(callingMod:IWasmModule|twrWasmBase, p:number ) {return Math.sqrt(p);}\n   twrTrunc(callingMod:IWasmModule|twrWasmBase, p:number ) {return Math.trunc(p);}\n   twrFMod(callingMod:IWasmModule|twrWasmBase, x:number, y:number) {return x%y}\n   twrPow(callingMod:IWasmModule|twrWasmBase, x:number, y:number ) {return Math.pow(x,y);}\n   \n   twrAtod(callingMod:IWasmModule|twrWasmBase, ...p:[number, number]) {return this.atod(callingMod.wasmMem, ...p)}\n   twrDtoa(callingMod:IWasmModule|twrWasmBase, ...p:[number, number, number, number]) {this.dtoa(callingMod.wasmMem, ...p)}\n   twrToFixed(callingMod:IWasmModule|twrWasmBase, ...p:[number, number, number, number]) {this.toFixed(callingMod.wasmMem, ...p)}\n   twrToExponential(callingMod:IWasmModule|twrWasmBase, ...p:[number, number, number, number]) {this.toExponential(callingMod.wasmMem, ...p)}\n   twrFcvtS(callingMod:IWasmModule|twrWasmBase, ...p:[number, number, number, number, number, number]) {return this.fcvtS(callingMod.wasmMem, ...p)}\n\n   //////////////////////////////////////////////////////////////////////////////////////\n\n   private atod(mem:IWasmMemoryBase, strptr:number, len:number):number {\n      const str=mem.getString(strptr, len);\n\n      const upper=str.trimStart().toUpperCase();\n      if (upper==\"INF\" || upper==\"+INF\" || upper==\"INFINITY\" || upper==\"+INFINITY\")\n         return Number.POSITIVE_INFINITY;\n      else if (upper==\"-INF\" || upper==\"-INFINITY\")\n         return Number.NEGATIVE_INFINITY\n      else {\n         // allow D for exponent -- old microsoft format they still support in _fctv and I support in my awbasic\n         // parseFloat will handle 'Infinity' and'-Infinity' literal\n         // parseFloat appears to be case sensitive when parsing 'Infinity'\n         // parseFloat ignores leading whitespace\n         // parseFloat() is more lenient than Number() because it ignores trailing invalid characters\n         const r=Number.parseFloat(str.replaceAll('D','e').replaceAll('d','e'));\n         return r;\n      }\n   }\n\n   private dtoa(mem:IWasmMemoryBase, buffer:number, buffer_size:number, value:number, max_precision:number):void {\n      if (max_precision==-1) {\n         const r=value.toString();\n         mem.copyString(buffer, buffer_size, r);\n      }\n      else {\n         let r=value.toString();\n         if (r.length>max_precision)\n               r=value.toPrecision(max_precision);\n         mem.copyString(buffer, buffer_size, r);\n      }\n   }\n\n   private toFixed(mem:IWasmMemoryBase, buffer:number, buffer_size:number, value:number, decdigits:number):void {\n      const r=value.toFixed(decdigits);\n      mem.copyString(buffer, buffer_size, r);\n   }\n\n   private toExponential(mem:IWasmMemoryBase, buffer:number, buffer_size:number, value:number, decdigits:number):void {\n      const r=value.toExponential(decdigits);\n      mem.copyString(buffer, buffer_size, r);\n   }\n\n   // emulates the MS C lib function _fcvt_s, but doesn't support all ranges of number.\n   // Number.toFixed() has a max size of 100 fractional digits,  and values must be less than 1e+21\n   // Negative exponents must be now smaller than 1e-99\n   // fully-function C version also int he source, but this is the version enabled by default\n   private fcvtS(mem:IWasmMemoryBase,\n      buffer:number,  // char *\n      sizeInBytes:number, //size_t\n      value:number,  // double\n      fracpart_numdigits:number,  //int\n      dec:number,  // int *\n      sign:number  // int *\n   ):number {\n\n      if (buffer==0 ||sign==0 || dec==0 || sizeInBytes<1) return 1;\n\n      let digits:string;\n      let decpos:number;\n      let s=0; // default to positive\n\n\n      if (Number.isNaN(value))  { /* nan */\n         digits=\"1#QNAN00000000000000000000000000000\".slice(0, fracpart_numdigits+1);\n         decpos=1;\n      }\n      else if (!Number.isFinite(value)) {    /* infinity */\n         digits=\"1#INF00000000000000000000000000000\".slice(0, fracpart_numdigits+1);\n         decpos=1;\n      }\n      else if (value==0) {  \n         digits=\"000000000000000000000000000000000000\".slice(0,fracpart_numdigits);\n         decpos=0;\n      }\n      \n      else {\n\n         if (value<0) {\n            s=1;  // negative\n            value=Math.abs(value);\n         }\n\n         if (fracpart_numdigits>100 || value > 1e+21 || value < 1e-99) {  \n            mem!.copyString(buffer, sizeInBytes, \"\");\n            mem!.mem32[dec]=0;\n            return 1;\n         }\n\n         const roundValStr=value.toFixed(fracpart_numdigits);\n         let [intPart=\"\", fracPart=\"\"] = roundValStr.split('.');\n         if (intPart==\"0\") intPart=\"\";\n\n         if (intPart.length>0) { // has integer part\n            decpos=intPart.length;\n            digits=intPart+fracPart;\n         }\n         else { // only a fraction\n            digits=fracPart.replace(/^0+/,\"\");  // remove leading zeros\n            decpos=digits.length-fracPart.length;\n         }\n      }\n\n      if (sizeInBytes-1 < digits.length) return 1; \n      mem.copyString(buffer, sizeInBytes, digits);\n      mem.setLong(dec, decpos);\n      mem.setLong(sign, s);\n\n      return 0;\n\n      /*\n      this version 'works' with larger numbers than using toFixed, but doesn't round correctly\n\n      let decpos=0;\n      let digits:string;\n      if (value!=0) decpos=Math.floor(Math.log10(value))+1;\n\n      if (decpos>0) { // has integer part\n         const intlen=Math.max(decpos, 0);\n         console.log(\"intlen=\",intlen, \"decpos=\",decpos);\n         const [nonExponent, exponent=0] = value.toPrecision(intlen+fracpart_numdigits).split('e');\n         digits=nonExponent.replace('.', '');\n         digits=digits.replace(/^0+/,\"\");  // remove leading zeros\n      }\n      else { // only a fraction\n         const intpart=Math.trunc(value);\n         const fracpart=value-intpart;\n         const prec=fracpart_numdigits- (-decpos);\n         console.log(\"prec=\",prec);\n         if (prec<1) {\n               digits=\"\";\n         }\n         else {\n               const [nonExponent, exponent=0] = fracpart.toPrecision(prec).split('e');\n               digits=nonExponent.replace('.', '');\n               digits=digits.replace(/^0+/,\"\");\n         }\n      }\n\n      console.log(\"fcvtS value\",value,\"fracpart_numdigits\",fracpart_numdigits);\n      console.log('digits=',digits);\n      console.log('dec=',decpos);\n      console.log(\"sign=\",s);\n   */\n\n   }\n\n}","import { twrLibrary, twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\n// Libraries use default export\nexport default class twrLibTimer extends twrLibrary {\n    id;\n    imports = {\n        twr_timer_single_shot: {},\n        twr_timer_repeat: {},\n        twr_timer_cancel: {},\n        twr_sleep: { isAsyncFunction: true, isModuleAsyncOnly: true },\n    };\n    libSourcePath = new URL(import.meta.url).pathname;\n    constructor() {\n        // all library constructors should start with these two lines\n        super();\n        this.id = twrLibraryInstanceRegistry.register(this);\n    }\n    twr_timer_single_shot(callingMod, milliSeconds, eventID) {\n        return setTimeout(() => {\n            callingMod.postEvent(eventID);\n        }, milliSeconds);\n    }\n    twr_timer_repeat(callingMod, milliSeconds, eventID) {\n        return setInterval(() => {\n            callingMod.postEvent(eventID);\n        }, milliSeconds);\n    }\n    twr_timer_cancel(callingMod, timerID) {\n        clearInterval(timerID);\n    }\n    async twr_sleep_async(callingMod, milliSeconds) {\n        const p = new Promise((resolve) => {\n            setTimeout(() => { resolve(); }, milliSeconds);\n        });\n        return p;\n    }\n}\n//# sourceMappingURL=twrlibtimer.js.map","import {IWasmModule,} from \"./twrmod.js\"\nimport {IWasmModuleAsync} from \"./twrmodasync.js\"\nimport {twrLibrary, TLibImports, twrLibraryInstanceRegistry} from \"./twrlibrary.js\"\n\n// Libraries use default export\nexport default class twrLibTimer extends twrLibrary {\n   id: number;\n   imports:TLibImports = {\n      twr_timer_single_shot:{},\n      twr_timer_repeat:{},\n      twr_timer_cancel:{},\n      twr_sleep:{isAsyncFunction: true, isModuleAsyncOnly: true},\n   };\n\n   libSourcePath = new URL(import.meta.url).pathname;\n\n   constructor() {\n      // all library constructors should start with these two lines\n      super();\n      this.id=twrLibraryInstanceRegistry.register(this);\n   }\n\n   twr_timer_single_shot(callingMod:IWasmModule|IWasmModuleAsync, milliSeconds:number, eventID:number) {\n      return setTimeout(()=>{\n         callingMod.postEvent(eventID)\n      }, milliSeconds);     \n   }\n\n   twr_timer_repeat(callingMod:IWasmModule|IWasmModuleAsync, milliSeconds:number, eventID:number) {\n      return setInterval(()=>{\n         callingMod.postEvent(eventID)\n      }, milliSeconds);  \n   }  \n   \n   twr_timer_cancel(callingMod:IWasmModule|IWasmModuleAsync, timerID:number) {\n      clearInterval(timerID);\n   }\n\n   async twr_sleep_async(callingMod:IWasmModuleAsync, milliSeconds:number) {\n      const p = new Promise<void>( (resolve)=>{\n         setTimeout(()=>{ resolve() }, milliSeconds);  \n      });\n\n      return p;\n   }\n\n}\n\n\n\n","import { twrLibrary, twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\nvar NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"AudioBuffer\"] = 0] = \"AudioBuffer\";\n    NodeType[NodeType[\"HTMLAudioElement\"] = 1] = \"HTMLAudioElement\";\n})(NodeType || (NodeType = {}));\n// enum AudioFileTypes {\n//    RAW,\n//    MP3,\n//    WAV,\n//    OGG,\n//    Unknown\n// };\nexport default class twrLibAudio extends twrLibrary {\n    id;\n    imports = {\n        \"twrAudioFromFloatPCM\": {},\n        \"twrAudioFrom8bitPCM\": {},\n        \"twrAudioFrom16bitPCM\": {},\n        \"twrAudioFrom32bitPCM\": {},\n        \"twrAudioGetFloatPCM\": { isAsyncFunction: true },\n        \"twrAudioGet8bitPCM\": { isAsyncFunction: true },\n        \"twrAudioGet16bitPCM\": { isAsyncFunction: true },\n        \"twrAudioGet32bitPCM\": { isAsyncFunction: true },\n        \"twrAudioPlay\": {},\n        \"twrAudioPlayRange\": {},\n        \"twrAudioQueryPlaybackPosition\": {},\n        \"twrAudioLoadSync\": { isAsyncFunction: true, isModuleAsyncOnly: true },\n        \"twrAudioLoad\": {},\n        \"twrAudioFreeID\": {},\n        \"twrAudioStopPlayback\": {},\n        \"twrAudioGetMetadata\": {},\n        \"twrAudioPlaySync\": { isAsyncFunction: true, isModuleAsyncOnly: true },\n        \"twrAudioRangePlaySync\": { isAsyncFunction: true, isModuleAsyncOnly: true },\n        \"twrAudioModifyPlaybackVolume\": {},\n        \"twrAudioModifyPlaybackPan\": {},\n        \"twrAudioModifyPlaybackRate\": {},\n        \"twrAudioPlayFile\": {},\n    };\n    nextID = 0;\n    nextPlaybackID = 0;\n    context = new AudioContext();\n    nodes = [];\n    playbacks = [];\n    // every library should have this line\n    libSourcePath = new URL(import.meta.url).pathname;\n    constructor() {\n        // all library constructors should start with these two lines\n        super();\n        this.id = twrLibraryInstanceRegistry.register(this);\n    }\n    //loads audio from samples using createBuffer and then loading the given data in\n    //data is expected to be a 2d array of channels with data length equal to singleChannelDataLen\n    //so if len is 10 and channels is 1, data is of total length 10\n    //if len is 10 and channels is 2, data is of total length 20, etc.\n    internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen) {\n        const arrayBuffer = this.context.createBuffer(numChannels, singleChannelDataLen, sampleRate);\n        const id = this.nextID++;\n        this.nodes[id] = [NodeType.AudioBuffer, arrayBuffer];\n        return [arrayBuffer, id];\n    }\n    twrAudioFromFloatPCM(mod, numChannels, sampleRate, dataPtr, singleChannelDataLen) {\n        const [arrayBuffer, id] = this.internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen);\n        for (let channel = 0; channel < numChannels; channel++) {\n            const channelBuff = arrayBuffer.getChannelData(channel);\n            const startPos = dataPtr / 4.0 + channel * singleChannelDataLen;\n            channelBuff.set(mod.wasmMem.memF.slice(startPos, startPos + singleChannelDataLen));\n        }\n        return id;\n    }\n    twrAudioFrom8bitPCM(mod, numChannels, sampleRate, dataPtr, singleChannelDataLen) {\n        const [arrayBuffer, id] = this.internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen);\n        for (let channel = 0; channel < numChannels; channel++) {\n            const channelBuff = arrayBuffer.getChannelData(channel);\n            const startPos = dataPtr / 1.0 + channel * singleChannelDataLen;\n            const dataBuff = mod.wasmMem.mem8.slice(startPos, startPos + singleChannelDataLen);\n            for (let i = 0; i < singleChannelDataLen; i++) {\n                //convert 8-bit PCM to float\n                //data is signed, so it will also need to find the negatives\n                channelBuff[i] = dataBuff[i] > 127 ? (dataBuff[i] - 256) / 128 : dataBuff[i] / 128;\n            }\n        }\n        return id;\n    }\n    twrAudioFrom16bitPCM(mod, numChannels, sampleRate, dataPtr, singleChannelDataLen) {\n        const [arrayBuffer, id] = this.internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen);\n        for (let channel = 0; channel < numChannels; channel++) {\n            const channelBuff = arrayBuffer.getChannelData(channel);\n            const startPos = dataPtr / 2.0 + channel * singleChannelDataLen;\n            const dataBuff = mod.wasmMem.mem16.slice(startPos, startPos + singleChannelDataLen);\n            for (let i = 0; i < singleChannelDataLen * 2; i += 2) {\n                //convert 16-bit PCM to float\n                channelBuff[i] = dataBuff[i] > 32767 ? (dataBuff[i] - 65536) / 32768 : dataBuff[i] / 32768;\n            }\n        }\n        return id;\n    }\n    twrAudioFrom32bitPCM(mod, numChannels, sampleRate, dataPtr, singleChannelDataLen) {\n        const [arrayBuffer, id] = this.internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen);\n        for (let channel = 0; channel < numChannels; channel++) {\n            const channelBuff = arrayBuffer.getChannelData(channel);\n            const startPos = dataPtr / 4.0 + channel * singleChannelDataLen;\n            const dataBuff = mod.wasmMem.mem32.slice(startPos, startPos + singleChannelDataLen);\n            for (let i = 0; i < singleChannelDataLen; i++) {\n                //convert 32-bit PCM to float\n                channelBuff[i] = dataBuff[i] > 2147483647 ? (dataBuff[i] - 4294967296) / 2147483648 : dataBuff[i] / 2147483648;\n            }\n        }\n        return id;\n    }\n    internalGetAnyPCMPart1(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        if (!(nodeID in this.nodes))\n            throw new Error(`twrAudioGetSamples couldn't find node of ID ${nodeID}`);\n        const node = this.nodes[nodeID];\n        if (node[0] != NodeType.AudioBuffer)\n            throw new Error(`twrAudioGetSamples expected a node of type AudioBuffer, got ${NodeType[node[0]]}!`);\n        const audioBuffer = node[1];\n        const totalLen = audioBuffer.length * audioBuffer.numberOfChannels;\n        mod.wasmMem.setLong(singleChannelDataLenPtr, audioBuffer.length);\n        mod.wasmMem.setLong(channelPtr, audioBuffer.numberOfChannels);\n        return [audioBuffer, totalLen];\n    }\n    internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, dataSize, part2) {\n        const [node, totalLen] = this.internalGetSamplesPart1(mod, nodeID, singleChannelDataLenPtr, channelPtr);\n        const bufferPtr = mod.malloc(totalLen * dataSize); //len(floatArray) * dataSize bytes/item\n        part2(mod, node, bufferPtr);\n        return bufferPtr;\n    }\n    async internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, dataSize, part2) {\n        const [node, totalLen] = this.internalGetSamplesPart1(mod, nodeID, singleChannelDataLenPtr, channelPtr);\n        const bufferPtr = await mod.malloc(totalLen * dataSize); //len(floatArray) * dataSize bytes/item\n        part2(mod, node, bufferPtr);\n        return bufferPtr;\n    }\n    internalGetSamplesPart1(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        if (!(nodeID in this.nodes))\n            throw new Error(`twrAudioGetSamples couldn't find node of ID ${nodeID}`);\n        const node = this.nodes[nodeID];\n        if (node[0] != NodeType.AudioBuffer)\n            throw new Error(`twrAudioGetSamples expected a node of type AudioBuffer, got ${NodeType[node[0]]}!`);\n        const audioBuffer = node[1];\n        const totalLen = audioBuffer.length * audioBuffer.numberOfChannels;\n        mod.wasmMem.setLong(singleChannelDataLenPtr, audioBuffer.length);\n        mod.wasmMem.setLong(channelPtr, audioBuffer.numberOfChannels);\n        return [audioBuffer, totalLen];\n    }\n    internalGetFloatPCMPart2(mod, buffer, bufferPtr) {\n        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n            let data = buffer.getChannelData(channel);\n            const startPos = bufferPtr / 4 + channel * buffer.length;\n            mod.wasmMem.memF.set(data.slice(0, buffer.length), startPos);\n        }\n    }\n    //Separated into a sync and async module, gets the total amount of data stored\n    //mallocs a buffer of appropriate size (split by sync and async since async needs await)\n    //then copies the audio buffer to the malloced memory and returns the pointer to the memory\n    twrAudioGetFloatPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return this.internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 4, this.internalGetFloatPCMPart2);\n    }\n    async twrAudioGetFloatPCM_async(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return await this.internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 4, this.internalGetFloatPCMPart2);\n    }\n    internalGet8bitPCMPart2(mod, buffer, bufferPtr) {\n        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n            let data = buffer.getChannelData(channel);\n            const startPos = bufferPtr + channel * buffer.length;\n            const retBuffer = mod.wasmMem.mem8.slice(startPos, buffer.length);\n            for (let i = 0; i < buffer.length; i++) {\n                //nergative values will automatically be converted to unsigned when assigning to retBuffer\n                retBuffer[i] = Math.round(data[i] * 128);\n            }\n        }\n    }\n    twrAudioGet8bitPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return this.internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 1, this.internalGet8bitPCMPart2);\n    }\n    async twrAudioGet8bitPCM_async(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return await this.internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 1, this.internalGet8bitPCMPart2);\n    }\n    internalGet16bitPCMPart2(mod, buffer, bufferPtr) {\n        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n            let data = buffer.getChannelData(channel);\n            const startPos = bufferPtr / 2.0 + channel * buffer.length;\n            const retBuffer = mod.wasmMem.mem16.slice(startPos, buffer.length);\n            for (let i = 0; i < buffer.length; i++) {\n                //nergative values will automatically be converted to unsigned when assigning to retBuffer\n                retBuffer[i] = Math.round(data[i] * 32768);\n            }\n        }\n    }\n    twrAudioGet16bitPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return this.internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 2, this.internalGet16bitPCMPart2);\n    }\n    async twrAudioGet16bitPCM_async(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return await this.internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 2, this.internalGet16bitPCMPart2);\n    }\n    internalGet32bitPCMPart2(mod, buffer, bufferPtr) {\n        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n            let data = buffer.getChannelData(channel);\n            const startPos = bufferPtr / 4.0 + channel * buffer.length;\n            const retBuffer = mod.wasmMem.mem32.slice(startPos, buffer.length);\n            for (let i = 0; i < buffer.length; i++) {\n                //nergative values will automatically be converted to unsigned when assigning to retBuffer\n                retBuffer[i] = Math.round(data[i] * 2147483648);\n            }\n        }\n    }\n    twrAudioGet32bitPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return this.internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 4, this.internalGet32bitPCMPart2);\n    }\n    async twrAudioGet21bitPCM_async(mod, nodeID, singleChannelDataLenPtr, channelPtr) {\n        return await this.internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 4, this.internalGet32bitPCMPart2);\n    }\n    //starts playing an audio node,\n    //all nodes are cloned by default so they can be played multiple times\n    //therefor, a new playback_id is returned for querying status\n    twrAudioPlay(mod, nodeID, volume = 1, pan = 0, finishCallback = null) {\n        return this.twrAudioPlayRange(mod, nodeID, 0, null, false, null, volume, pan, finishCallback);\n    }\n    internalAudioPlayRange(mod, nodeID, startSample, endSample, loop, sampleRate, volume, pan) {\n        if (!(nodeID in this.nodes))\n            throw new Error(`twrLibAudio twrAudioPlayNode was given a non-existant nodeID (${nodeID})!`);\n        if (sampleRate == 0) { //assume a 0 sample_rate is just normal speed or null\n            sampleRate = null;\n        }\n        const node = this.nodes[nodeID];\n        let id = this.nextPlaybackID++;\n        let promise;\n        switch (node[0]) {\n            case NodeType.AudioBuffer:\n                {\n                    if (endSample == null) {\n                        endSample = node[1].length;\n                    }\n                    const buffer = node[1];\n                    const sourceBuffer = this.context.createBufferSource();\n                    sourceBuffer.buffer = buffer;\n                    promise = new Promise((resolve, reject) => {\n                        sourceBuffer.onended = () => {\n                            delete this.playbacks[id];\n                            resolve(id);\n                        };\n                    });\n                    const startTime = startSample / node[1].sampleRate;\n                    const endTime = (endSample - startSample) / node[1].sampleRate;\n                    sourceBuffer.loop = loop;\n                    sourceBuffer.loopStart = startTime;\n                    sourceBuffer.loopEnd = endSample / node[1].sampleRate;\n                    sourceBuffer.playbackRate.value = sampleRate ? sampleRate / node[1].sampleRate : 1.0;\n                    sourceBuffer.start(0, startTime, loop ? undefined : endTime);\n                    const gainNode = this.context.createGain();\n                    gainNode.gain.value = volume;\n                    sourceBuffer.connect(gainNode);\n                    const panNode = this.context.createStereoPanner();\n                    panNode.pan.value = pan;\n                    gainNode.connect(panNode);\n                    panNode.connect(this.context.destination);\n                    this.playbacks[id] = [NodeType.AudioBuffer, sourceBuffer, (new Date()).getTime(), node[1].sampleRate, gainNode, panNode];\n                }\n                break;\n            default:\n                throw new Error(`twrAudioPlayNode unknown type! ${node[0]}`);\n        }\n        return [promise, id];\n    }\n    twrAudioPlayRange(mod, nodeID, startSample, endSample = null, loop = false, sampleRate = null, volume = 1, pan = 0, finishCallback = null) {\n        if (finishCallback == -1000) { //no callback, used in twr_audio_play_range_full\n            finishCallback = null;\n        }\n        let [promise, id] = this.internalAudioPlayRange(mod, nodeID, startSample, endSample, loop, sampleRate, volume, pan);\n        if (finishCallback != null) {\n            promise.then((playback_id) => {\n                mod.postEvent(finishCallback, playback_id);\n            });\n        }\n        return id;\n    }\n    async twrAudioPlaySync_async(mod, nodeID, volume = 1, pan = 0) {\n        return this.twrAudioPlayRangeSync_async(mod, nodeID, 0, null, false, null, volume, pan);\n    }\n    async twrAudioPlayRangeSync_async(mod, nodeID, startSample, endSample = null, loop = false, sampleRate = null, volume = 1, pan = 0) {\n        let [promise, id] = this.internalAudioPlayRange(mod, nodeID, startSample, endSample, loop, sampleRate, volume, pan);\n        await promise;\n        return id;\n    }\n    //queries current playback positions\n    //if the given ID doesn't exist, assume it was removed because it ended and return -1\n    twrAudioQueryPlaybackPosition(mod, playbackID) {\n        if (!(playbackID in this.playbacks))\n            return -1;\n        const playback = this.playbacks[playbackID];\n        switch (playback[0]) {\n            case NodeType.AudioBuffer:\n                {\n                    return ((new Date()).getTime() - playback[2]);\n                }\n                break;\n            case NodeType.HTMLAudioElement:\n                {\n                    return playback[1].currentTime;\n                }\n                break;\n            default:\n                throw new Error(`twrAudioQueryPlaybackPosition unknown type! ${playback[0]}`);\n        }\n    }\n    async internalLoadAudio(mod, urlPtr, id) {\n        const url = mod.wasmMem.getString(urlPtr);\n        const res = await fetch(url);\n        const buffer = await this.context.decodeAudioData(await res.arrayBuffer());\n        this.nodes[id] = [NodeType.AudioBuffer, buffer];\n    }\n    async twrAudioLoadSync_async(mod, urlPtr) {\n        const id = this.nextID++;\n        await this.internalLoadAudio(mod, urlPtr, id);\n        return id;\n    }\n    twrAudioLoad(mod, eventID, urlPtr) {\n        const id = this.nextID++;\n        this.internalLoadAudio(mod, urlPtr, id).then(() => {\n            mod.postEvent(eventID, id);\n        });\n        return id;\n    }\n    twrAudioFreeID(mod, nodeID) {\n        if (!(nodeID in this.nodes))\n            throw new Error(`twrAudioFreeID couldn't find node of ID ${nodeID}`);\n        delete this.nodes[nodeID];\n    }\n    // need to clarify some implementation details\n    twrAudioGetMetadata(mod, nodeID, metadataPtr) {\n        if (!(nodeID in this.nodes))\n            throw new Error(`twrAudioGetMetadata couldn't find node of ID ${nodeID}`);\n        /*\n        struct AudioMetadata {\n           long length;\n           long sample_rate;\n           long channels;\n        };*/\n        const node = this.nodes[nodeID];\n        switch (node[0]) {\n            case NodeType.AudioBuffer:\n                {\n                    mod.wasmMem.setLong(metadataPtr + 0, node[1].length);\n                    mod.wasmMem.setLong(metadataPtr + 4, node[1].sampleRate);\n                    mod.wasmMem.setLong(metadataPtr + 8, node[1].numberOfChannels);\n                }\n                break;\n            default:\n                throw new Error(`twrAudioGetMetadata unknown type! ${node[0]}`);\n        }\n    }\n    twrAudioStopPlayback(mod, playbackID) {\n        if (!(playbackID in this.playbacks)) {\n            console.log(`Warning: twrAudioStopPlayback was given an ID that didn't exist (${playbackID})!`);\n            return;\n        }\n        const node = this.playbacks[playbackID];\n        // console.log(\"hi!!\");\n        switch (node[0]) {\n            case NodeType.AudioBuffer:\n                {\n                    node[1].stop();\n                }\n                break;\n            case NodeType.HTMLAudioElement:\n                {\n                    node[1].loop = false;\n                    node[1].currentTime = Number.MAX_SAFE_INTEGER;\n                    //delete index just in case audio hasn't loaded yet\n                    delete this.playbacks[playbackID];\n                }\n                break;\n            default:\n                throw new Error(`twrAudioStopPlayback unknown type! ${node[0]}`);\n        }\n        // delete this.playbacks[playbackID];\n    }\n    twrAudioModifyPlaybackVolume(mod, playbackID, volume) {\n        if (!(playbackID in this.playbacks)) {\n            console.log(`Warning: twrAudioModifyPlaybackVolume was given an ID that didn't exist (${playbackID})!`);\n            return;\n        }\n        const node = this.playbacks[playbackID];\n        if (volume > 1 || volume < 0) {\n            console.log(`Warning! twrAudioModifyPlaybackVolume was given a volume (${volume}) that wasn't between 0 and 1!`);\n            volume = Math.max(Math.min(volume, 1), 0);\n        }\n        switch (node[0]) {\n            case NodeType.AudioBuffer:\n                {\n                    const gainNode = node[4];\n                    gainNode.gain.value = volume;\n                }\n                break;\n            case NodeType.HTMLAudioElement:\n                {\n                    const audio = node[1];\n                    audio.volume = volume;\n                }\n                break;\n        }\n    }\n    twrAudioModifyPlaybackPan(mod, playbackID, pan) {\n        if (!(playbackID in this.playbacks)) {\n            console.log(`Warning: twrAudioModifyPlaybackPan was given an ID that didn't exist (${playbackID})!`);\n            return;\n        }\n        const node = this.playbacks[playbackID];\n        switch (node[0]) {\n            case NodeType.AudioBuffer:\n                {\n                    const panNode = node[5];\n                    panNode.pan.value = pan;\n                }\n                break;\n            case NodeType.HTMLAudioElement:\n                {\n                    throw new Error(\"Can't modify the pan of a playback started by twrAudioPlayFile!\");\n                }\n                break;\n        }\n    }\n    twrAudioModifyPlaybackRate(mod, playbackID, sampleRate) {\n        if (!(playbackID in this.playbacks)) {\n            console.log(`Warning: twrAudioModifyPlaybackRate was given an ID that didn't exist (${playbackID})!`);\n            return;\n        }\n        const node = this.playbacks[playbackID];\n        switch (node[0]) {\n            case NodeType.AudioBuffer:\n                {\n                    const playback = node[1];\n                    const baseSampleRate = node[3];\n                    playback.playbackRate.value = sampleRate / baseSampleRate;\n                }\n                break;\n            case NodeType.HTMLAudioElement:\n                {\n                    const audio = node[1];\n                    audio.playbackRate = sampleRate;\n                }\n                break;\n        }\n    }\n    twrAudioPlayFile(mod, fileURLPtr, volume = 1.0, playbackRate = 1.0, loop = false) {\n        const playbackID = this.nextPlaybackID++;\n        const fileURL = mod.wasmMem.getString(fileURLPtr);\n        const audio = new Audio(fileURL);\n        audio.volume = volume;\n        audio.loop = loop;\n        audio.playbackRate = playbackRate;\n        audio.onended = () => {\n            delete this.playbacks[playbackID];\n        };\n        audio.play();\n        this.playbacks[playbackID] = [NodeType.HTMLAudioElement, audio];\n        return playbackID;\n    }\n}\n//# sourceMappingURL=twrlibaudio.js.map","import { TLibImports, twrLibrary, twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\nimport { IWasmModule } from \"./twrmod\";\nimport { IWasmModuleAsync } from \"./twrmodasync\";\n\nenum NodeType {\n   AudioBuffer,\n   HTMLAudioElement,\n}\ntype Node = [NodeType.AudioBuffer, AudioBuffer];\n\ntype BufferPlaybackNode = [NodeType.AudioBuffer, AudioBufferSourceNode, number, number, GainNode, StereoPannerNode];\ntype AudioPlaybackNode = [NodeType.HTMLAudioElement, HTMLAudioElement]; \ntype PlaybackNode = BufferPlaybackNode | AudioPlaybackNode;\n\n// enum AudioFileTypes {\n//    RAW,\n//    MP3,\n//    WAV,\n//    OGG,\n//    Unknown\n// };\n\nexport default class twrLibAudio extends twrLibrary {\n   id: number;\n\n   imports: TLibImports = {\n      \"twrAudioFromFloatPCM\": {},\n      \"twrAudioFrom8bitPCM\": {},\n      \"twrAudioFrom16bitPCM\": {},\n      \"twrAudioFrom32bitPCM\": {},\n\n      \"twrAudioGetFloatPCM\": {isAsyncFunction: true},\n      \"twrAudioGet8bitPCM\": {isAsyncFunction: true},\n      \"twrAudioGet16bitPCM\": {isAsyncFunction: true},\n      \"twrAudioGet32bitPCM\": {isAsyncFunction: true},\n\n      \"twrAudioPlay\": {},\n      \"twrAudioPlayRange\": {},\n      \"twrAudioQueryPlaybackPosition\": {},\n      \"twrAudioLoadSync\": {isAsyncFunction: true, isModuleAsyncOnly: true},\n      \"twrAudioLoad\": {},\n      \"twrAudioFreeID\": {},\n      \"twrAudioStopPlayback\": {},\n      \"twrAudioGetMetadata\": {},\n      \"twrAudioPlaySync\": {isAsyncFunction: true, isModuleAsyncOnly: true},\n      \"twrAudioRangePlaySync\": {isAsyncFunction: true, isModuleAsyncOnly: true},\n      \"twrAudioModifyPlaybackVolume\": {},\n      \"twrAudioModifyPlaybackPan\": {},\n      \"twrAudioModifyPlaybackRate\": {},\n      \"twrAudioPlayFile\": {},\n   };\n   nextID: number = 0;\n   nextPlaybackID: number = 0;\n   context: AudioContext = new AudioContext();\n   nodes: Node[] = [];\n   playbacks: PlaybackNode[] = [];\n   \n\n   // every library should have this line\n   libSourcePath = new URL(import.meta.url).pathname;\n\n   constructor() {\n      // all library constructors should start with these two lines\n      super();\n      this.id=twrLibraryInstanceRegistry.register(this);\n   }\n\n\n   //loads audio from samples using createBuffer and then loading the given data in\n   //data is expected to be a 2d array of channels with data length equal to singleChannelDataLen\n   //so if len is 10 and channels is 1, data is of total length 10\n   //if len is 10 and channels is 2, data is of total length 20, etc.\n   internalSetupAudioBuffer(numChannels: number, sampleRate: number, singleChannelDataLen: number): [AudioBuffer, number] {\n      const arrayBuffer = this.context.createBuffer(\n         numChannels,\n         singleChannelDataLen,\n         sampleRate\n      );\n\n      const id = this.nextID++;\n      this.nodes[id] = [NodeType.AudioBuffer, arrayBuffer];\n\n      return [arrayBuffer, id];\n   }\n\n   twrAudioFromFloatPCM(mod: IWasmModuleAsync|IWasmModule, numChannels: number, sampleRate: number, dataPtr: number, singleChannelDataLen: number) {\n      const [arrayBuffer, id] = this.internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen);\n\n      for (let channel = 0; channel < numChannels; channel++) {\n         const channelBuff = arrayBuffer.getChannelData(channel);\n         const startPos = dataPtr/4.0 + channel*singleChannelDataLen;\n         channelBuff.set(mod.wasmMem.memF!.slice(startPos, startPos + singleChannelDataLen));\n      }\n\n      return id;\n   }\n\n   twrAudioFrom8bitPCM(mod: IWasmModuleAsync|IWasmModule, numChannels: number, sampleRate: number, dataPtr: number, singleChannelDataLen: number) {\n      const [arrayBuffer, id] = this.internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen);\n\n      for (let channel = 0; channel < numChannels; channel++) {\n         const channelBuff = arrayBuffer.getChannelData(channel);\n         const startPos = dataPtr/1.0 + channel*singleChannelDataLen;\n\n         const dataBuff = mod.wasmMem.mem8.slice(startPos, startPos + singleChannelDataLen);\n\n         for (let i = 0; i < singleChannelDataLen; i++) {\n            //convert 8-bit PCM to float\n            //data is signed, so it will also need to find the negatives\n            channelBuff[i] = dataBuff[i] > 127 ? (dataBuff[i] - 256)/128 : dataBuff[i]/128;\n         }\n      }\n\n      return id;\n   }\n\n   twrAudioFrom16bitPCM(mod: IWasmModuleAsync|IWasmModule, numChannels: number, sampleRate: number, dataPtr: number, singleChannelDataLen: number) {\n      const [arrayBuffer, id] = this.internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen);\n\n      for (let channel = 0; channel < numChannels; channel++) {\n         const channelBuff = arrayBuffer.getChannelData(channel);\n         const startPos = dataPtr/2.0 + channel*singleChannelDataLen;\n\n         const dataBuff = mod.wasmMem.mem16.slice(startPos, startPos + singleChannelDataLen);\n\n         for (let i = 0; i < singleChannelDataLen*2; i += 2) {\n            //convert 16-bit PCM to float\n            channelBuff[i] = dataBuff[i] > 32767 ? (dataBuff[i] - 65536)/32768 : dataBuff[i]/32768;\n         }\n      }\n\n      return id;\n   }\n\n   twrAudioFrom32bitPCM(mod: IWasmModuleAsync|IWasmModule, numChannels: number, sampleRate: number, dataPtr: number, singleChannelDataLen: number) {\n      const [arrayBuffer, id] = this.internalSetupAudioBuffer(numChannels, sampleRate, singleChannelDataLen);\n\n      for (let channel = 0; channel < numChannels; channel++) {\n         const channelBuff = arrayBuffer.getChannelData(channel);\n         const startPos = dataPtr/4.0 + channel*singleChannelDataLen;\n\n         const dataBuff = mod.wasmMem.mem32.slice(startPos, startPos + singleChannelDataLen);\n\n         for (let i = 0; i < singleChannelDataLen; i++) {\n            //convert 32-bit PCM to float\n            channelBuff[i] = dataBuff[i] > 2147483647 ? (dataBuff[i] - 4294967296)/2147483648 : dataBuff[i]/2147483648;\n         }\n      }\n\n      return id;\n   }\n   internalGetAnyPCMPart1(mod: IWasmModuleAsync|IWasmModule, nodeID: number, singleChannelDataLenPtr: number, channelPtr: number): [AudioBuffer, number] {\n      if (!(nodeID in this.nodes)) throw new Error(`twrAudioGetSamples couldn't find node of ID ${nodeID}`);\n      \n      const node = this.nodes[nodeID];\n      if (node[0] != NodeType.AudioBuffer) throw new Error(`twrAudioGetSamples expected a node of type AudioBuffer, got ${NodeType[node[0]]}!`);\n\n      const audioBuffer = node[1] as AudioBuffer;\n\n      const totalLen = audioBuffer.length * audioBuffer.numberOfChannels;\n\n      mod.wasmMem.setLong(singleChannelDataLenPtr, audioBuffer.length);\n      mod.wasmMem.setLong(channelPtr, audioBuffer.numberOfChannels);\n\n      return [audioBuffer, totalLen];\n   }\n\n   internalSyncGetAnyPCM(mod: IWasmModule, nodeID: number, singleChannelDataLenPtr: number, channelPtr: number, dataSize: number, part2: (a: IWasmModuleAsync|IWasmModule, b: AudioBuffer, c: number) => void) {\n      const [node, totalLen] = this.internalGetSamplesPart1(mod, nodeID, singleChannelDataLenPtr, channelPtr);\n      const bufferPtr = mod.malloc!(totalLen * dataSize); //len(floatArray) * dataSize bytes/item\n      part2(mod, node, bufferPtr);\n\n      return bufferPtr\n   }\n\n   async internalAsyncGetAnyPCM(mod: IWasmModuleAsync, nodeID: number, singleChannelDataLenPtr: number, channelPtr: number, dataSize: number, part2: (a: IWasmModuleAsync|IWasmModule, b: AudioBuffer, c: number) => void) {\n      const [node, totalLen] = this.internalGetSamplesPart1(mod, nodeID, singleChannelDataLenPtr, channelPtr);\n      const bufferPtr = await mod.malloc!(totalLen * dataSize); //len(floatArray) * dataSize bytes/item\n      part2(mod, node, bufferPtr);\n\n      return bufferPtr\n   }\n\n   internalGetSamplesPart1(mod: IWasmModuleAsync|IWasmModule, nodeID: number, singleChannelDataLenPtr: number, channelPtr: number): [AudioBuffer, number] {\n      if (!(nodeID in this.nodes)) throw new Error(`twrAudioGetSamples couldn't find node of ID ${nodeID}`);\n      \n      const node = this.nodes[nodeID];\n      if (node[0] != NodeType.AudioBuffer) throw new Error(`twrAudioGetSamples expected a node of type AudioBuffer, got ${NodeType[node[0]]}!`);\n\n      const audioBuffer = node[1] as AudioBuffer;\n\n      const totalLen = audioBuffer.length * audioBuffer.numberOfChannels;\n\n      mod.wasmMem.setLong(singleChannelDataLenPtr, audioBuffer.length);\n      mod.wasmMem.setLong(channelPtr, audioBuffer.numberOfChannels);\n\n      return [audioBuffer, totalLen];\n   }\n   internalGetFloatPCMPart2(mod: IWasmModuleAsync|IWasmModule, buffer: AudioBuffer, bufferPtr: number) {\n      for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n         let data = buffer.getChannelData(channel);\n         const startPos = bufferPtr/4 + channel*buffer.length;\n         mod.wasmMem.memF.set(data.slice(0, buffer.length), startPos);\n      }\n   }\n\n   //Separated into a sync and async module, gets the total amount of data stored\n   //mallocs a buffer of appropriate size (split by sync and async since async needs await)\n   //then copies the audio buffer to the malloced memory and returns the pointer to the memory\n   twrAudioGetFloatPCM(mod: IWasmModule, nodeID: number, singleChannelDataLenPtr: number, channelPtr: number) {\n      return this.internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 4, this.internalGetFloatPCMPart2);\n   }\n\n   async twrAudioGetFloatPCM_async(mod: IWasmModuleAsync, nodeID: number, singleChannelDataLenPtr: number, channelPtr: number) {\n      return await this.internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 4, this.internalGetFloatPCMPart2);\n   }\n\n   internalGet8bitPCMPart2(mod: IWasmModuleAsync|IWasmModule, buffer: AudioBuffer, bufferPtr: number) {\n      for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n         let data = buffer.getChannelData(channel);\n         const startPos = bufferPtr + channel*buffer.length;\n         const retBuffer = mod.wasmMem.mem8.slice(startPos, buffer.length);\n\n         for (let i = 0; i < buffer.length; i++) {\n            //nergative values will automatically be converted to unsigned when assigning to retBuffer\n            retBuffer[i] = Math.round(data[i] * 128); \n         }\n      }\n   }\n\n   twrAudioGet8bitPCM(mod: IWasmModule, nodeID: number, singleChannelDataLenPtr: number, channelPtr: number) {\n      return this.internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 1, this.internalGet8bitPCMPart2);\n   }\n\n   async twrAudioGet8bitPCM_async(mod: IWasmModuleAsync, nodeID: number, singleChannelDataLenPtr: number, channelPtr: number) {\n      return await this.internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 1, this.internalGet8bitPCMPart2);\n   }\n\n   internalGet16bitPCMPart2(mod: IWasmModuleAsync|IWasmModule, buffer: AudioBuffer, bufferPtr: number) {\n      for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n         let data = buffer.getChannelData(channel);\n         const startPos = bufferPtr/2.0 + channel*buffer.length;\n         const retBuffer = mod.wasmMem.mem16.slice(startPos, buffer.length);\n\n         for (let i = 0; i < buffer.length; i++) {\n            //nergative values will automatically be converted to unsigned when assigning to retBuffer\n            retBuffer[i] = Math.round(data[i] * 32768); \n         }\n      }\n   }\n\n   twrAudioGet16bitPCM(mod: IWasmModule, nodeID: number, singleChannelDataLenPtr: number, channelPtr: number) {\n      return this.internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 2, this.internalGet16bitPCMPart2);\n   }\n\n   async twrAudioGet16bitPCM_async(mod: IWasmModuleAsync, nodeID: number, singleChannelDataLenPtr: number, channelPtr: number) {\n      return await this.internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 2, this.internalGet16bitPCMPart2);\n   }\n\n   internalGet32bitPCMPart2(mod: IWasmModuleAsync|IWasmModule, buffer: AudioBuffer, bufferPtr: number) {\n      for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n         let data = buffer.getChannelData(channel);\n         const startPos = bufferPtr/4.0 + channel*buffer.length;\n         const retBuffer = mod.wasmMem.mem32.slice(startPos, buffer.length);\n\n         for (let i = 0; i < buffer.length; i++) {\n            //nergative values will automatically be converted to unsigned when assigning to retBuffer\n            retBuffer[i] = Math.round(data[i] * 2147483648); \n         }\n      }\n   }\n\n   twrAudioGet32bitPCM(mod: IWasmModule, nodeID: number, singleChannelDataLenPtr: number, channelPtr: number) {\n      return this.internalSyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 4, this.internalGet32bitPCMPart2);\n   }\n\n   async twrAudioGet21bitPCM_async(mod: IWasmModuleAsync, nodeID: number, singleChannelDataLenPtr: number, channelPtr: number) {\n      return await this.internalAsyncGetAnyPCM(mod, nodeID, singleChannelDataLenPtr, channelPtr, 4, this.internalGet32bitPCMPart2);\n   }\n\n\n   //starts playing an audio node,\n   //all nodes are cloned by default so they can be played multiple times\n   //therefor, a new playback_id is returned for querying status\n   twrAudioPlay(mod: IWasmModuleAsync|IWasmModule, nodeID: number, volume: number = 1, pan: number = 0, finishCallback: number | null = null) {\n      return this.twrAudioPlayRange(mod, nodeID, 0, null, false, null, volume, pan, finishCallback);\n   }\n\n   internalAudioPlayRange(mod: IWasmModuleAsync|IWasmModule, nodeID: number, startSample: number, endSample: number | null, loop: boolean, sampleRate: number | null, volume: number, pan: number): [Promise<number>, number] {\n      if (!(nodeID in this.nodes)) throw new Error(`twrLibAudio twrAudioPlayNode was given a non-existant nodeID (${nodeID})!`);\n\n      if (sampleRate == 0) { //assume a 0 sample_rate is just normal speed or null\n         sampleRate = null;\n      }\n\n      const node = this.nodes[nodeID];\n\n      let id = this.nextPlaybackID++;\n      let promise: Promise<number>;\n\n      switch (node[0]) {\n         case NodeType.AudioBuffer:\n         {\n            if (endSample == null) {\n               endSample = node[1].length;\n            }\n            \n            const buffer = node[1] as AudioBuffer;\n            const sourceBuffer = this.context.createBufferSource();\n            sourceBuffer.buffer = buffer;\n\n            promise = new Promise((resolve, reject) => {\n               sourceBuffer.onended = () => {\n                  delete this.playbacks[id];\n                  resolve(id);\n               }\n            });\n            \n\n            const startTime = startSample/node[1].sampleRate;\n            const endTime = (endSample - startSample)/node[1].sampleRate;\n            \n            sourceBuffer.loop = loop;\n            sourceBuffer.loopStart = startTime;\n            sourceBuffer.loopEnd = endSample/node[1].sampleRate;\n\n            sourceBuffer.playbackRate.value = sampleRate ? sampleRate/node[1].sampleRate : 1.0;\n\n            sourceBuffer.start(0, startTime, loop ? undefined : endTime);\n\n            const gainNode = this.context.createGain();\n            gainNode.gain.value = volume;\n            sourceBuffer.connect(gainNode);\n\n            const panNode = this.context.createStereoPanner();\n            panNode.pan.value = pan;\n            gainNode.connect(panNode);\n            panNode.connect(this.context.destination);\n\n            this.playbacks[id] = [NodeType.AudioBuffer, sourceBuffer, (new Date()).getTime(), node[1].sampleRate, gainNode, panNode];\n         }\n         break;\n\n         default:\n            throw new Error(`twrAudioPlayNode unknown type! ${node[0]}`);\n      }\n\n      return [promise, id];\n   }\n\n   twrAudioPlayRange(mod: IWasmModuleAsync|IWasmModule, nodeID: number, startSample: number, endSample: number | null = null, loop: boolean = false, sampleRate: number | null = null, volume: number = 1, pan: number = 0, finishCallback: number | null = null) {\n      if (finishCallback == -1000) { //no callback, used in twr_audio_play_range_full\n         finishCallback = null;\n      }\n      let [promise, id] = this.internalAudioPlayRange(mod, nodeID, startSample, endSample, loop, sampleRate, volume, pan);\n      if (finishCallback != null) {\n         promise.then((playback_id) => {\n            mod.postEvent(finishCallback, playback_id);\n         });\n      }\n      \n      return id;\n   }\n\n   async twrAudioPlaySync_async(mod: IWasmModuleAsync, nodeID: number, volume: number = 1, pan: number = 0) {\n      return this.twrAudioPlayRangeSync_async(mod, nodeID, 0, null, false, null, volume, pan,);\n   }\n   async twrAudioPlayRangeSync_async(mod: IWasmModuleAsync, nodeID: number, startSample: number, endSample: number | null = null, loop: boolean = false, sampleRate: number | null = null, volume: number = 1, pan: number = 0) {\n      let [promise, id] = this.internalAudioPlayRange(mod, nodeID, startSample, endSample, loop, sampleRate, volume, pan);\n      \n      await promise;\n      \n      return id;\n   }\n\n   //queries current playback positions\n   //if the given ID doesn't exist, assume it was removed because it ended and return -1\n   twrAudioQueryPlaybackPosition(mod: IWasmModuleAsync|IWasmModule, playbackID: number) {\n      if (!(playbackID in this.playbacks)) return -1;\n\n      const playback = this.playbacks[playbackID];\n\n      switch (playback[0]) {\n         case NodeType.AudioBuffer:\n         {\n            return ((new Date()).getTime() - playback[2]);\n         }\n         break;\n\n         case NodeType.HTMLAudioElement:\n         {\n            return playback[1].currentTime;\n         }\n         break;\n\n         default:\n            throw new Error(`twrAudioQueryPlaybackPosition unknown type! ${playback[0]}`);\n      }\n   }\n\n   async internalLoadAudio(mod: IWasmModuleAsync|IWasmModule, urlPtr: number, id: number) {\n      const url = mod.wasmMem.getString(urlPtr);\n      const res = await fetch(url);\n\n      const buffer = await this.context.decodeAudioData(await res.arrayBuffer());\n      this.nodes[id] = [NodeType.AudioBuffer, buffer];\n\n   }\n   async twrAudioLoadSync_async(mod: IWasmModuleAsync, urlPtr: number) {\n      const id = this.nextID++;\n      await this.internalLoadAudio(mod, urlPtr, id);\n      return id;\n   }\n\n   twrAudioLoad(mod: IWasmModuleAsync|IWasmModule, eventID: number, urlPtr: number) {\n      const id = this.nextID++;\n\n      this.internalLoadAudio(mod, urlPtr, id).then(() => {\n         mod.postEvent(eventID, id);\n      });\n\n\n      return id;\n   }\n\n   twrAudioFreeID(mod: IWasmModule|IWasmModuleAsync, nodeID: number) {\n      if (!(nodeID in this.nodes)) throw new Error(`twrAudioFreeID couldn't find node of ID ${nodeID}`);\n\n      delete this.nodes[nodeID];\n   }\n\n   \n   // need to clarify some implementation details\n   twrAudioGetMetadata(mod: IWasmModuleAsync|IWasmModule, nodeID: number, metadataPtr: number) {\n      if (!(nodeID in this.nodes)) throw new Error(`twrAudioGetMetadata couldn't find node of ID ${nodeID}`);\n\n      /*\n      struct AudioMetadata {\n         long length;\n         long sample_rate;\n         long channels;\n      };*/\n\n      const node = this.nodes[nodeID];\n\n      switch (node[0]) {\n         case NodeType.AudioBuffer:\n         {\n            mod.wasmMem.setLong(metadataPtr+0, node[1].length);\n            mod.wasmMem.setLong(metadataPtr+4, node[1].sampleRate);\n            mod.wasmMem.setLong(metadataPtr+8, node[1].numberOfChannels);\n         }\n         break;\n\n\n         default:\n            throw new Error(`twrAudioGetMetadata unknown type! ${node[0]}`);\n      }\n      \n   }\n\n   twrAudioStopPlayback(mod: IWasmModule|IWasmModuleAsync, playbackID: number) {\n      if (!(playbackID in this.playbacks)) {\n         console.log(`Warning: twrAudioStopPlayback was given an ID that didn't exist (${playbackID})!`);\n         return;\n      }\n\n      const node = this.playbacks[playbackID];\n\n      // console.log(\"hi!!\");\n      \n      switch (node[0]) {\n         case NodeType.AudioBuffer:\n         {\n            node[1].stop();\n         }\n         break;\n\n         case NodeType.HTMLAudioElement:\n         {\n            node[1].loop = false;\n            node[1].currentTime = Number.MAX_SAFE_INTEGER;\n            //delete index just in case audio hasn't loaded yet\n            delete this.playbacks[playbackID];\n         }\n         break;\n\n\n         default:\n            throw new Error(`twrAudioStopPlayback unknown type! ${node[0]}`);\n      }\n      // delete this.playbacks[playbackID];\n   }\n\n   twrAudioModifyPlaybackVolume(mod: IWasmModule|IWasmModuleAsync, playbackID: number, volume: number) {\n      if (!(playbackID in this.playbacks)) {\n         console.log(`Warning: twrAudioModifyPlaybackVolume was given an ID that didn't exist (${playbackID})!`);\n         return;\n      }\n\n      const node = this.playbacks[playbackID];\n      if (volume > 1 || volume < 0) {\n         console.log(`Warning! twrAudioModifyPlaybackVolume was given a volume (${volume}) that wasn't between 0 and 1!`)\n         volume = Math.max(Math.min(volume, 1), 0);\n      }\n\n      switch (node[0]) {\n         case NodeType.AudioBuffer: \n         {\n            const gainNode = node[4];\n            gainNode.gain.value = volume;\n         }\n         break;\n\n         case NodeType.HTMLAudioElement:\n         {\n            const audio = node[1];\n            audio.volume = volume;\n         }\n         break;\n      }\n   }\n\n   twrAudioModifyPlaybackPan(mod: IWasmModule|IWasmModuleAsync, playbackID: number, pan: number) {\n      if (!(playbackID in this.playbacks)) {\n         console.log(`Warning: twrAudioModifyPlaybackPan was given an ID that didn't exist (${playbackID})!`);\n         return;\n      }\n\n      const node = this.playbacks[playbackID];\n\n      switch (node[0]) {\n         case NodeType.AudioBuffer: \n         {\n            const panNode = node[5];\n            panNode.pan.value = pan;\n         }\n         break;\n         case NodeType.HTMLAudioElement:\n         {\n            throw new Error(\"Can't modify the pan of a playback started by twrAudioPlayFile!\");\n         }\n         break;\n      }\n   }\n\n   twrAudioModifyPlaybackRate(mod: IWasmModule|IWasmModuleAsync, playbackID: number, sampleRate: number) {\n      if (!(playbackID in this.playbacks)) {\n         console.log(`Warning: twrAudioModifyPlaybackRate was given an ID that didn't exist (${playbackID})!`);\n         return;\n      }\n\n      const node = this.playbacks[playbackID];\n\n      switch (node[0]) {\n         case NodeType.AudioBuffer: \n         {\n            const playback = node[1];\n            const baseSampleRate = node[3];\n            playback.playbackRate.value = sampleRate/baseSampleRate;\n         }\n         break;\n         case NodeType.HTMLAudioElement:\n         {\n            const audio = node[1];\n            audio.playbackRate = sampleRate;\n         }\n         break;\n      }\n   }\n\n   twrAudioPlayFile(mod: IWasmModule|IWasmModuleAsync, fileURLPtr: number, volume: number = 1.0, playbackRate: number = 1.0, loop: boolean = false) {\n      const playbackID = this.nextPlaybackID++;\n      \n      const fileURL = mod.wasmMem.getString(fileURLPtr);\n      const audio = new Audio(fileURL);\n\n      audio.volume = volume;\n      audio.loop = loop;\n      audio.playbackRate = playbackRate;\n\n      audio.onended = () => {\n         delete this.playbacks[playbackID];\n      };\n\n      audio.play();\n      \n      this.playbacks[playbackID] = [NodeType.HTMLAudioElement, audio];\n\n      return playbackID;\n   }\n}","import { twrLibrary, twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\n//TODO!! Add more Date functions (as alternatives to std c lib)?\n// add built-in Libraries (like this one) to twrLibBultins\n// libraries use the default export\nexport default class twrLibDate extends twrLibrary {\n    id;\n    imports = {\n        twrTimeEpoch: { isCommonCode: true }\n    };\n    libSourcePath = new URL(import.meta.url).pathname;\n    constructor() {\n        // all library constructors should start with these two lines\n        super();\n        this.id = twrLibraryInstanceRegistry.register(this);\n    }\n    // return ms since epoch as int64_t\n    twrTimeEpoch(callingMod) {\n        return BigInt(Date.now());\n    }\n}\n//# sourceMappingURL=twrlibdate.js.map","import {IWasmModule} from \"./twrmod.js\"\nimport {twrWasmBase} from \"./twrwasmbase.js\"\nimport {twrLibrary, TLibImports, twrLibraryInstanceRegistry} from \"./twrlibrary.js\";\n\n//TODO!! Add more Date functions (as alternatives to std c lib)?\n\n// add built-in Libraries (like this one) to twrLibBultins\n// libraries use the default export\nexport default class twrLibDate extends twrLibrary {\n   id:number;\n   \n   imports:TLibImports = {\n      twrTimeEpoch:{isCommonCode: true}\n   }\n\n   libSourcePath = new URL(import.meta.url).pathname;\n\n   constructor() {\n      // all library constructors should start with these two lines\n      super();\n      this.id=twrLibraryInstanceRegistry.register(this);\n   }\n\n   // return ms since epoch as int64_t\n   twrTimeEpoch(callingMod:IWasmModule|twrWasmBase) {\n\n      return BigInt(Date.now());\n\n   }\n}\n\n","import { twrLibrary, twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\n// This class exists so the twrlibbuiltin can cause all functions (like twrConCls) to resolve at runtime link time\n// twr.a links to all of these, even if the relevant console is not loaded by the app at runtime\n// These functions should never be called, because twrLibrary routes a call (like io_cls(id)) to the correct console instance based on id\n// see TODO comments in twrLibrary.ts for possible better fixes\nexport default class twrConsoleDummy extends twrLibrary {\n    id;\n    imports = {\n        twrConCharOut: { noBlock: true },\n        twrConGetProp: {},\n        twrConPutStr: { noBlock: true },\n        twrConCharIn: { isAsyncFunction: true, isModuleAsyncOnly: true },\n        twrConSetFocus: { noBlock: true },\n        twrConSetC32: { noBlock: true },\n        twrConCls: { noBlock: true },\n        twrConSetRange: { noBlock: true },\n        twrConSetReset: { noBlock: true },\n        twrConPoint: {},\n        twrConSetCursor: { noBlock: true },\n        twrConSetCursorXY: { noBlock: true },\n        twrConSetColors: { noBlock: true },\n        twrConDrawSeq: {},\n        twrConLoadImage: { isModuleAsyncOnly: true, isAsyncFunction: true },\n    };\n    libSourcePath = new URL(import.meta.url).pathname;\n    interfaceName = \"twrConsole\";\n    constructor() {\n        // all library constructors should start with these two lines\n        super();\n        this.id = twrLibraryInstanceRegistry.register(this);\n    }\n    twrConGetProp(callingMod, pn) {\n        throw new Error(\"internal error\");\n    }\n    keyDown(ev) {\n        throw new Error(\"internal error\");\n    }\n    twrConCharOut(callingMod, c, codePage) {\n        throw new Error(\"internal error\");\n    }\n    twrConPutStr(callingMod, chars, codePage) {\n        throw new Error(\"internal error\");\n    }\n    twrConSetC32(callingMod, location, c32) {\n        throw new Error(\"internal error\");\n    }\n    twrConCls() {\n        throw new Error(\"internal error\");\n    }\n    twrConSetRange(callingMod, chars, start, len) {\n        throw new Error(\"internal error\");\n    }\n    setRangeJS(start, values) {\n        throw new Error(\"internal error\");\n    }\n    twrConSetReset(callingMod, x, y, isset) {\n        throw new Error(\"internal error\");\n    }\n    twrConPoint(callingMod, x, y) {\n        throw new Error(\"internal error\");\n    }\n    twrConSetCursor(callingMod, location) {\n        throw new Error(\"internal error\");\n    }\n    twrConSetCursorXY(callingMod, x, y) {\n        throw new Error(\"internal error\");\n    }\n    twrConSetColors(callingMod, foreground, background) {\n        throw new Error(\"internal error\");\n    }\n    async twrConCharIn_async(callingMod) {\n        throw new Error(\"internal error\");\n    }\n    twrConSetFocus() {\n        throw new Error(\"internal error\");\n    }\n    twrConDrawSeq(mod, ds) {\n        throw new Error(\"internal error\");\n    }\n    getProp(name) {\n        throw new Error(\"internal error\");\n    }\n    putStr(str) {\n        throw new Error(\"internal error\");\n    }\n    charOut(c32) {\n        throw new Error(\"internal error\");\n    }\n    twrConLoadImage_async(mod, urlPtr, id) {\n        throw new Error(\"internal error\");\n    }\n}\n//# sourceMappingURL=twrcondummy.js.map","import {IConsoleStreamOut, IConsoleStreamIn, IConsoleCanvas, IConsoleAddressable, ICanvasProps } from \"./twrcon.js\"\nimport {IWasmModuleAsync} from \"./twrmodasync.js\";\nimport {IWasmModule} from \"./twrmod.js\"\nimport {twrLibrary, TLibImports, twrLibraryInstanceRegistry} from \"./twrlibrary.js\";\n\n// This class exists so the twrlibbuiltin can cause all functions (like twrConCls) to resolve at runtime link time\n// twr.a links to all of these, even if the relevant console is not loaded by the app at runtime\n// These functions should never be called, because twrLibrary routes a call (like io_cls(id)) to the correct console instance based on id\n// see TODO comments in twrLibrary.ts for possible better fixes\n\nexport default class twrConsoleDummy extends twrLibrary implements IConsoleStreamIn, IConsoleStreamOut, IConsoleAddressable, IConsoleCanvas  {\n   id:number;\n\n   imports:TLibImports = {\n      twrConCharOut:{noBlock:true},\n      twrConGetProp:{},\n      twrConPutStr:{noBlock:true},\n      twrConCharIn:{isAsyncFunction: true, isModuleAsyncOnly: true},\n      twrConSetFocus:{noBlock:true},\n      twrConSetC32:{noBlock:true},\n      twrConCls:{noBlock:true},\n      twrConSetRange:{noBlock:true},\n      twrConSetReset:{noBlock:true},\n      twrConPoint:{},\n      twrConSetCursor:{noBlock:true},\n      twrConSetCursorXY:{noBlock:true},\n      twrConSetColors:{noBlock:true},\n      twrConDrawSeq:{},\n      twrConLoadImage:{isModuleAsyncOnly:true, isAsyncFunction:true},\n   };\n\n   libSourcePath = new URL(import.meta.url).pathname;\n   interfaceName = \"twrConsole\";\n\n   constructor() {\n      // all library constructors should start with these two lines\n      super();\n      this.id=twrLibraryInstanceRegistry.register(this);\n   }\n   \n   twrConGetProp(callingMod:IWasmModule|IWasmModuleAsync, pn:number):number {\n      throw new Error(\"internal error\");\n   }\n\n   keyDown(ev:KeyboardEvent)  {\n      throw new Error(\"internal error\");\n   }\n\n   twrConCharOut(callingMod:any, c:number, codePage:number)  {\n      throw new Error(\"internal error\");\n   }\n\n   twrConPutStr(callingMod:IWasmModule|IWasmModuleAsync, chars:number, codePage:number) {\n      throw new Error(\"internal error\");\n   }\n\n   twrConSetC32(callingMod:any, location:number, c32:number) : void {\n      throw new Error(\"internal error\");\n   }\n\n   twrConCls()  {\n      throw new Error(\"internal error\");\n   }\n\n   twrConSetRange(callingMod:IWasmModule|IWasmModuleAsync, chars:number, start:number, len:number) {\n      throw new Error(\"internal error\");\n   }\n\n   setRangeJS(start:number, values:number[]) {\n      throw new Error(\"internal error\");\n   }\n\n   twrConSetReset(callingMod:IWasmModule|IWasmModuleAsync, x:number, y:number, isset:boolean) : void  {\n      throw new Error(\"internal error\");\n   }\n\n   twrConPoint(callingMod:IWasmModule|IWasmModuleAsync, x:number, y:number) : boolean  {\n      throw new Error(\"internal error\");\n   }\n\n   twrConSetCursor(callingMod:IWasmModule|IWasmModuleAsync, location:number) : void   {\n      throw new Error(\"internal error\");\n   }\n\n   twrConSetCursorXY(callingMod:IWasmModule|IWasmModuleAsync, x:number, y:number) {\n      throw new Error(\"internal error\");\n   }\n\n   twrConSetColors(callingMod:IWasmModule|IWasmModuleAsync, foreground:number, background:number) : void {\n      throw new Error(\"internal error\");\n   }\n\n   async twrConCharIn_async(callingMod: IWasmModuleAsync):Promise<number> {\n      throw new Error(\"internal error\");\n   }\n\n   twrConSetFocus() {\n      throw new Error(\"internal error\");\n   }\n\n   twrConDrawSeq(mod:IWasmModuleAsync|IWasmModule, ds:number) {\n      throw new Error(\"internal error\");\n   }\n\n   getProp(name:keyof ICanvasProps): number {\n      throw new Error(\"internal error\");\n   }\n\n   putStr(str:string) {\n      throw new Error(\"internal error\");\n   }\n\n   charOut(c32:string) {\n      throw new Error(\"internal error\");\n   }\n\n   twrConLoadImage_async(mod: IWasmModuleAsync, urlPtr: number, id: number) : Promise<number> {\n      throw new Error(\"internal error\");\n   }\n\n}\n","import { logToCon } from \"./twrcon.js\";\nimport { parseModOptions } from './twrmodutil.js';\nimport { twrWasmMemoryAsync } from \"./twrwasmmem.js\";\nimport { twrWasmModuleCallAsync } from \"./twrwasmcall.js\";\nimport { twrLibraryInstanceRegistry } from \"./twrlibrary.js\";\nimport { twrEventQueueSend } from \"./twreventqueue.js\";\nimport { twrLibBuiltIns } from \"./twrlibbuiltin.js\";\nexport class twrWasmModuleAsync {\n    myWorker;\n    loadWasmResolve;\n    loadWasmReject;\n    callCMap;\n    uniqueInt;\n    initLW = false;\n    io;\n    ioNamesToID;\n    wasmMem;\n    callCInstance;\n    eventQueueSend = new twrEventQueueSend;\n    isTwrWasmModuleAsync = true;\n    // divLog is deprecated.  Use IConsole.putStr or log\n    divLog;\n    log;\n    // IWasmMemory\n    // These are deprecated, use wasmMem instead.\n    memory;\n    exports;\n    mem8;\n    mem32;\n    memD;\n    stringToU8;\n    copyString;\n    getLong;\n    setLong;\n    getDouble;\n    setDouble;\n    getShort;\n    getString;\n    getU8Arr;\n    getU32Arr;\n    malloc;\n    free;\n    putString;\n    putU8;\n    putArrayBuffer;\n    constructor(opts) {\n        [this.io, this.ioNamesToID] = parseModOptions(opts);\n        this.callCMap = new Map();\n        this.uniqueInt = 1;\n        if (!window.Worker)\n            throw new Error(\"This browser doesn't support web workers.\");\n        const url = new URL('twrmodasyncproxy.js', import.meta.url);\n        this.myWorker = new Worker(url, { type: \"module\" });\n        this.myWorker.onerror = (event) => {\n            console.log(\"this.myWorker.onerror (undefined message typically means Worker failed to load)\");\n            console.log(\"event.message: \" + event.message);\n            throw event;\n        };\n        this.myWorker.onmessage = this.processMsg.bind(this);\n        this.log = logToCon.bind(undefined, this.io.stdio);\n        this.divLog = this.log;\n    }\n    async loadWasm(pathToLoad) {\n        if (this.initLW)\n            throw new Error(\"twrWasmModuleAsync::loadWasm can only be called once per instance\");\n        this.initLW = true;\n        // load builtin libraries\n        await twrLibBuiltIns();\n        return new Promise((resolve, reject) => {\n            this.loadWasmResolve = resolve;\n            this.loadWasmReject = reject;\n            // libProxyParams will be everything needed to create Proxy versions of all twrLibraries\n            // libClassInstances has one entry per class, even if multiple instances of same class are registered (ie, interfaceName set)\n            let libProxyParams = [];\n            for (let i = 0; i < twrLibraryInstanceRegistry.libInterfaceInstances.length; i++) {\n                libProxyParams.push(twrLibraryInstanceRegistry.libInterfaceInstances[i].getProxyParams());\n            }\n            const allProxyParams = {\n                libProxyParams: libProxyParams,\n                ioNamesToID: this.ioNamesToID, // console instance name mappings\n                eventQueueBuffer: this.eventQueueSend.circBuffer.saBuffer\n            };\n            const urlToLoad = new URL(pathToLoad, document.URL);\n            const startMsg = { urlToLoad: urlToLoad.href, allProxyParams: allProxyParams };\n            this.myWorker.postMessage(['startup', startMsg]);\n        });\n    }\n    postEvent(eventID, ...params) {\n        this.eventQueueSend.postEvent(eventID, ...params);\n        this.myWorker.postMessage(['tickleEventLoop']);\n    }\n    async callC(params) {\n        const cparams = await this.callCInstance.preCallC(params); // will also validate params[0]\n        const retval = await this.callCImpl(params[0], cparams);\n        await this.callCInstance.postCallC(cparams, params);\n        return retval;\n    }\n    async callCImpl(fname, cparams = []) {\n        return new Promise((resolve, reject) => {\n            const p = {\n                callCResolve: resolve,\n                callCReject: reject\n            };\n            this.callCMap.set(++this.uniqueInt, p);\n            this.myWorker.postMessage(['callC', this.uniqueInt, fname, cparams]);\n        });\n    }\n    // this implementation piggybacks of callCImpl -- it is essentially a specific version of callC\n    // instead of sending a message to the twrWasmModuleAsync thread (as callCImpl does), we post a malloc command\n    // in the eventQueue.  This allows it to be processed  by the twrWasmModuleAsync event loop.  malloc was previously sent using callCImpl, but \n    // callCImpl uses postMessage, and the twrWasmModuleAsync thread will not process the callCImpl message while inside another callC,\n    // and malloc may be used by wasmMem.putXX functions, inside twrWasmLibrary derived classes, which are called from C, inside of a callC.\n    //\n    async mallocImpl(size) {\n        return new Promise((resolve, reject) => {\n            const p = {\n                callCResolve: resolve,\n                callCReject: reject\n            };\n            this.callCMap.set(++this.uniqueInt, p);\n            this.eventQueueSend.postMalloc(this.uniqueInt, size);\n            this.myWorker.postMessage(['tickleEventLoop']);\n        });\n    }\n    // the API user can call this to default to stdio\n    // or the API user can call keyDown on a particular console\n    keyDown(ev) {\n        if (!this.io.stdio)\n            throw new Error(\"internal error - stdio not defined\");\n        if (!this.io.stdio.keyDown)\n            throw new Error(\"stdio.keyDown not defined. Console must implemented IConsoleStreamIn.\");\n        this.io.stdio.keyDown(ev);\n    }\n    // this function is deprecated and here for backward compatibility\n    keyDownDiv(ev) {\n        if (this.io.stdio.element && this.io.stdio.element.id == \"twr_iodiv\")\n            this.keyDown(ev);\n        else\n            throw new Error(\"keyDownDiv is deprecated, but in any case should only be used with twr_iodiv\");\n    }\n    // this function is deprecated and here for backward compatibility\n    keyDownCanvas(ev) {\n        if (this.io.stdio.element && this.io.stdio.element.id == \"twr_iocanvas\")\n            this.keyDown(ev);\n        else\n            throw new Error(\"keyDownCanvas is deprecated, but in any case should only be used with twr_iocanvas\");\n    }\n    //  this.myWorker.onmessage = this.processMsg.bind(this);\n    async processMsg(event) {\n        const msg = event.data;\n        const [msgClass, id] = msg;\n        //console.log(\"twrWasmAsyncModule - got message: \"+event.data)\n        if (msgClass === \"twrWasmModule\") {\n            const [, , msgType, ...params] = msg;\n            switch (msgType) {\n                case \"setmemory\":\n                    this.memory = params[0];\n                    if (!this.memory)\n                        throw new Error(\"unexpected error - undefined memory\");\n                    this.wasmMem = new twrWasmMemoryAsync(this.memory, this.mallocImpl.bind(this), this.callCImpl.bind(this));\n                    this.callCInstance = new twrWasmModuleCallAsync(this.wasmMem, this.callCImpl.bind(this));\n                    // backwards compatible\n                    this.mem8 = this.wasmMem.mem8;\n                    this.mem32 = this.wasmMem.mem32;\n                    this.memD = this.wasmMem.memD;\n                    this.stringToU8 = this.wasmMem.stringToU8;\n                    this.copyString = this.wasmMem.copyString;\n                    this.getLong = this.wasmMem.getLong;\n                    this.setLong = this.wasmMem.setLong;\n                    this.getDouble = this.wasmMem.getDouble;\n                    this.setDouble = this.wasmMem.setDouble;\n                    this.getShort = this.wasmMem.getShort;\n                    this.getString = this.wasmMem.getString;\n                    this.getU8Arr = this.wasmMem.getU8Arr;\n                    this.getU32Arr = this.wasmMem.getU32Arr;\n                    this.malloc = this.wasmMem.malloc;\n                    this.free = this.wasmMem.free;\n                    this.putString = this.wasmMem.putString;\n                    this.putU8 = this.wasmMem.putU8;\n                    this.putArrayBuffer = this.wasmMem.putArrayBuffer;\n                    break;\n                case \"startupFail\":\n                    const [returnCode] = params;\n                    if (this.loadWasmReject)\n                        this.loadWasmReject(returnCode);\n                    else\n                        throw new Error(\"twrWasmAsyncModule.processMsg unexpected error (undefined loadWasmReject)\");\n                    break;\n                case \"startupOkay\":\n                    if (this.loadWasmResolve)\n                        this.loadWasmResolve(undefined);\n                    else\n                        throw new Error(\"twrWasmAsyncModule.processMsg unexpected error (undefined loadWasmResolve)\");\n                    break;\n                case \"callCFail\":\n                    {\n                        const [returnCode] = params;\n                        const p = this.callCMap.get(id);\n                        if (!p)\n                            throw new Error(\"internal error\");\n                        this.callCMap.delete(id);\n                        if (p.callCReject)\n                            p.callCReject(returnCode);\n                        else\n                            throw new Error(\"twrWasmAsyncModule.processMsg unexpected error (undefined callCReject)\");\n                    }\n                    break;\n                case \"callCOkay\":\n                    {\n                        const [returnCode] = params;\n                        const p = this.callCMap.get(id);\n                        if (!p)\n                            throw new Error(\"internal error\");\n                        this.callCMap.delete(id);\n                        if (p.callCResolve)\n                            p.callCResolve(returnCode);\n                        else\n                            throw new Error(\"twrWasmAsyncModule.processMsg unexpected error (undefined callCResolve)\");\n                        break;\n                    }\n                default:\n                    throw new Error(\"internal error: \" + msgType);\n            }\n        }\n        else if (msgClass === \"twrLibrary\") {\n            const lib = twrLibraryInstanceRegistry.getLibraryInstance(id);\n            const msgLib = msg;\n            await lib.processMessageFromProxy(msg, this);\n        }\n        else {\n            throw new Error(\"twrWasmAsyncModule - unknown and unexpected msgClass: \" + msgClass);\n        }\n    }\n    // given a url, load its contents, and stuff into Wasm memory similar to Unint8Array\n    async fetchAndPutURL(fnin) {\n        if (!(typeof fnin === 'object' && fnin instanceof URL))\n            throw new Error(\"fetchAndPutURL param must be URL\");\n        try {\n            let response = await fetch(fnin);\n            let buffer = await response.arrayBuffer();\n            let src = new Uint8Array(buffer);\n            let dest = await this.wasmMem.putU8(src);\n            return [dest, src.length];\n        }\n        catch (err) {\n            console.log('fetchAndPutURL Error. URL: ' + fnin + '\\n' + err + (err.stack ? \"\\n\" + err.stack : ''));\n            throw err;\n        }\n    }\n}\n//# sourceMappingURL=twrmodasync.js.map","import {IAllProxyParams} from \"./twrmodasyncproxy.js\"\nimport {IConsole, logToCon} from \"./twrcon.js\";\nimport {parseModOptions, IModOpts} from './twrmodutil.js'\nimport {IWasmMemoryAsync, twrWasmMemoryAsync} from \"./twrwasmmem.js\";\nimport {twrWasmModuleCallAsync, TCallCAsync, TCallCImplAsync } from \"./twrwasmcall.js\"\nimport {TLibraryMessage, TLibraryProxyParams, twrLibraryInstanceRegistry} from \"./twrlibrary.js\"\nimport {twrEventQueueSend} from \"./twreventqueue.js\"\nimport {twrLibBuiltIns} from \"./twrlibbuiltin.js\"\n\n// class twrWasmModuleAsync consist of two parts:\n//   twrWasmModuleAsync runs in the main JavaScript event loop\n//   twrWasmModuleAsyncProxy runs in a WebWorker thread\n//      - the wasm module is loaded by the webworker, and C calls into javascript are handed by proxy classes which call the 'main' class via a message\n\n// IWasmModuleAsync is the Async version of IWasmModule\n// Partial<IWasmMemoryAsync> defines the deprecated module level memory access functions\n\n\nexport type TModuleMessage=[msgClass:\"twrWasmModule\", id:number, msgType:string, ...params:any[]];\n\nexport type TModAsyncMessage=TLibraryMessage|TModuleMessage;\n\nexport interface IWasmModuleAsync extends Partial<IWasmMemoryAsync> {\n   wasmMem: IWasmMemoryAsync;\n   callCInstance: twrWasmModuleCallAsync;\n   callC:TCallCAsync;\n   callCImpl:TCallCImplAsync;\n   eventQueueSend:twrEventQueueSend;\n   isTwrWasmModuleAsync:true;  // to avoid circular references -- check if twrWasmModuleAsync without importing twrWasmModuleAsync\n   //TODO!! put these into IWasmModuleBase (some could be implemented in twrWasmModuleBase, but many have different implementations)\n   loadWasm: (pathToLoad:string)=>Promise<void>;\n   postEvent:(eventID:number, ...params:number[])=>void;\n   fetchAndPutURL: (fnin:URL)=>Promise<[number, number]>;\n   divLog:(...params: string[])=>void;\n   log:(...params: string[])=>void;\n}\n\nexport type TModAsyncProxyStartupMsg = {\n   urlToLoad: string,\n   allProxyParams: IAllProxyParams,\n};\n\ninterface ICallCPromise {\n   callCResolve: (value: any) => void;\n   callCReject: (reason?: any) => void;\n}\n    \nexport class twrWasmModuleAsync implements IWasmModuleAsync {\n   myWorker:Worker;\n   loadWasmResolve?: (value: void) => void;\n   loadWasmReject?: (reason?: any) => void;\n   callCMap:Map<number, ICallCPromise>;\n   uniqueInt: number;\n   initLW=false;\n   io:{[key:string]: IConsole};\n   ioNamesToID: {[key: string]: number};\n   wasmMem!: IWasmMemoryAsync;\n   callCInstance!: twrWasmModuleCallAsync;\n   eventQueueSend:twrEventQueueSend=new twrEventQueueSend;\n   isTwrWasmModuleAsync:true=true;\n\n\n   // divLog is deprecated.  Use IConsole.putStr or log\n   divLog:(...params: string[])=>void;\n   log:(...params: string[])=>void;\n\n   // IWasmMemory\n   // These are deprecated, use wasmMem instead.\n   memory!:WebAssembly.Memory;\n   exports!:WebAssembly.Exports;\n   mem8!:Uint8Array;\n   mem32!:Uint32Array;\n   memD!:Float64Array;\n   stringToU8!:(sin:string, codePage?:number)=>Uint8Array;\n   copyString!:(buffer:number, buffer_size:number, sin:string, codePage?:number)=>void;\n   getLong!:(idx:number)=>number;\n   setLong!:(idx:number, value:number)=>void;\n   getDouble!:(idx:number)=>number;\n   setDouble!:(idx:number, value:number)=>void;\n   getShort!:(idx:number)=>number;\n   getString!:(strIndex:number, len?:number, codePage?:number)=>string;\n   getU8Arr!:(idx:number)=>Uint8Array;\n   getU32Arr!:(idx:number)=>Uint32Array;\n\n   malloc!:(size:number)=>Promise<number>;\n   free!:(size:number)=>Promise<void>;\n   putString!:(sin:string, codePage?:number)=>Promise<number>;\n   putU8!:(u8a:Uint8Array)=>Promise<number>;\n   putArrayBuffer!:(ab:ArrayBuffer)=>Promise<number>;\n\n   constructor(opts?:IModOpts) {\n\n      [this.io, this.ioNamesToID] = parseModOptions(opts);\n\n      this.callCMap=new Map();\n      this.uniqueInt=1;\n\n      if (!window.Worker) throw new Error(\"This browser doesn't support web workers.\");\n      const url=new URL('twrmodasyncproxy.js', import.meta.url);\n      this.myWorker = new Worker(url, {type: \"module\" });\n      this.myWorker.onerror = (event: ErrorEvent) => {\n         console.log(\"this.myWorker.onerror (undefined message typically means Worker failed to load)\");\n         console.log(\"event.message: \"+event.message)\n         throw event;\n      };\n      this.myWorker.onmessage= this.processMsg.bind(this);\n\n      this.log=logToCon.bind(undefined, this.io.stdio);\n      this.divLog=this.log;\n   }\n\n   async loadWasm(pathToLoad:string) {\n      if (this.initLW) \tthrow new Error(\"twrWasmModuleAsync::loadWasm can only be called once per instance\");\n      this.initLW=true;\n\n      // load builtin libraries\n      await twrLibBuiltIns();\n\n      return new Promise<void>((resolve, reject)=>{\n         this.loadWasmResolve=resolve;\n         this.loadWasmReject=reject;\n\n         // libProxyParams will be everything needed to create Proxy versions of all twrLibraries\n         // libClassInstances has one entry per class, even if multiple instances of same class are registered (ie, interfaceName set)\n         let libProxyParams:TLibraryProxyParams[] = [];\n         for (let i=0; i<twrLibraryInstanceRegistry.libInterfaceInstances.length; i++) {\n            libProxyParams.push(twrLibraryInstanceRegistry.libInterfaceInstances[i].getProxyParams());\n         }\n\n         const allProxyParams:IAllProxyParams={\n            libProxyParams: libProxyParams,\n            ioNamesToID: this.ioNamesToID,  // console instance name mappings\n            eventQueueBuffer: this.eventQueueSend.circBuffer.saBuffer\n         };\n         const urlToLoad = new URL(pathToLoad, document.URL);\n         const startMsg:TModAsyncProxyStartupMsg={ urlToLoad: urlToLoad.href, allProxyParams: allProxyParams};\n         this.myWorker.postMessage(['startup', startMsg]);\n      });\n   }\n\n   postEvent(eventID:number, ...params:number[]) {\n      this.eventQueueSend.postEvent(eventID, ...params);\n      this.myWorker.postMessage(['tickleEventLoop']);\n   }\n\n   async callC(params:[string, ...(string|number|bigint|ArrayBuffer)[]]) {\n      const cparams=await this.callCInstance.preCallC(params); // will also validate params[0]\n      const retval=await this.callCImpl(params[0], cparams);\n      await this.callCInstance.postCallC(cparams, params);\n      return retval;\n   }\t\n\n   async callCImpl(fname:string, cparams:(number|bigint)[]=[]) {\n      return new Promise<any>((resolve, reject)=>{\n         const p:ICallCPromise={\n            callCResolve: resolve,\n            callCReject: reject\n         }\n         this.callCMap.set(++this.uniqueInt, p);\n         this.myWorker.postMessage(['callC', this.uniqueInt, fname, cparams]);\n      });\n   }\n\n   // this implementation piggybacks of callCImpl -- it is essentially a specific version of callC\n   // instead of sending a message to the twrWasmModuleAsync thread (as callCImpl does), we post a malloc command\n   // in the eventQueue.  This allows it to be processed  by the twrWasmModuleAsync event loop.  malloc was previously sent using callCImpl, but \n   // callCImpl uses postMessage, and the twrWasmModuleAsync thread will not process the callCImpl message while inside another callC,\n   // and malloc may be used by wasmMem.putXX functions, inside twrWasmLibrary derived classes, which are called from C, inside of a callC.\n   //\n   async mallocImpl(size:number) {\n      return new Promise<any>((resolve, reject)=>{\n         const p:ICallCPromise={\n            callCResolve: resolve,\n            callCReject: reject\n         }\n        this.callCMap.set(++this.uniqueInt, p);\n         this.eventQueueSend.postMalloc(this.uniqueInt, size);\n         this.myWorker.postMessage(['tickleEventLoop']);\n      });\n   }\n   \n   // the API user can call this to default to stdio\n   // or the API user can call keyDown on a particular console\n   keyDown(ev:KeyboardEvent) {\n      if (!this.io.stdio) throw new Error(\"internal error - stdio not defined\");\n      if (!this.io.stdio.keyDown) throw new Error(\"stdio.keyDown not defined. Console must implemented IConsoleStreamIn.\")\n      this.io.stdio.keyDown(ev);\n   }\n\n   // this function is deprecated and here for backward compatibility\n   keyDownDiv(ev:KeyboardEvent) {\n      if (this.io.stdio.element && this.io.stdio.element.id==\"twr_iodiv\")\n         this.keyDown(ev);\n      else  \n         throw new Error(\"keyDownDiv is deprecated, but in any case should only be used with twr_iodiv\")\n   }\n\n   // this function is deprecated and here for backward compatibility\n   keyDownCanvas(ev:KeyboardEvent) {\n      if (this.io.stdio.element && this.io.stdio.element.id==\"twr_iocanvas\")\n         this.keyDown(ev);\n      else  \n         throw new Error(\"keyDownCanvas is deprecated, but in any case should only be used with twr_iocanvas\")\n   }\n\n   //  this.myWorker.onmessage = this.processMsg.bind(this);\n   async processMsg(event: MessageEvent<TModAsyncMessage>) {\n      const msg=event.data;\n      const [msgClass, id]=msg;\n\n      //console.log(\"twrWasmAsyncModule - got message: \"+event.data)\n\n      if (msgClass===\"twrWasmModule\") {\n         const [,, msgType, ...params]=msg;\n         \n         switch (msgType) {\n            case \"setmemory\":\n               this.memory=params[0];\n               if (!this.memory) throw new Error(\"unexpected error - undefined memory\");\n\n               this.wasmMem=new twrWasmMemoryAsync(this.memory, this.mallocImpl.bind(this), this.callCImpl.bind(this));\n               this.callCInstance=new twrWasmModuleCallAsync(this.wasmMem, this.callCImpl.bind(this));\n\n               // backwards compatible\n               this.mem8 = this.wasmMem.mem8;\n               this.mem32 = this.wasmMem.mem32;\n               this.memD = this.wasmMem.memD;\n               this.stringToU8=this.wasmMem.stringToU8;\n               this.copyString=this.wasmMem.copyString;\n               this.getLong=this.wasmMem.getLong;\n               this.setLong=this.wasmMem.setLong;\n               this.getDouble=this.wasmMem.getDouble;\n               this.setDouble=this.wasmMem.setDouble;\n               this.getShort=this.wasmMem.getShort;\n               this.getString=this.wasmMem.getString;\n               this.getU8Arr=this.wasmMem.getU8Arr;\n               this.getU32Arr=this.wasmMem.getU32Arr;\n            \n               this.malloc=this.wasmMem.malloc;\n               this.free=this.wasmMem.free;\n               this.putString=this.wasmMem.putString;\n               this.putU8=this.wasmMem.putU8;\n               this.putArrayBuffer=this.wasmMem.putArrayBuffer;\n               break;\n\n            case \"startupFail\":\n               const [returnCode]=params;\n               if (this.loadWasmReject)\n                  this.loadWasmReject(returnCode);\n               else\n                  throw new Error(\"twrWasmAsyncModule.processMsg unexpected error (undefined loadWasmReject)\");\n               break;\n\n            case \"startupOkay\":\n\n               if (this.loadWasmResolve)\n                  this.loadWasmResolve(undefined);\n               else\n                  throw new Error(\"twrWasmAsyncModule.processMsg unexpected error (undefined loadWasmResolve)\");\n               break;\n\n            case \"callCFail\":\n            {\n               const [returnCode]=params;\n               const p=this.callCMap.get(id);\n               if (!p) throw new Error(\"internal error\");\n               this.callCMap.delete(id);\n               if (p.callCReject)\n                  p.callCReject(returnCode);\n               else\n                  throw new Error(\"twrWasmAsyncModule.processMsg unexpected error (undefined callCReject)\");\n            }\n               break;\n\n            case \"callCOkay\":\n            {\n               const [returnCode]=params;\n               const p=this.callCMap.get(id);\n               if (!p) throw new Error(\"internal error\");\n               this.callCMap.delete(id);\n               if (p.callCResolve)\n                  p.callCResolve(returnCode);\n               else\n                  throw new Error(\"twrWasmAsyncModule.processMsg unexpected error (undefined callCResolve)\");\n               break;\n            }\n\n            default:\n               throw new Error(\"internal error: \"+msgType)\n         }\n      }\n      \n      else if (msgClass===\"twrLibrary\") {\n         const lib=twrLibraryInstanceRegistry.getLibraryInstance(id);\n         const msgLib=msg as TLibraryMessage;\n         await lib.processMessageFromProxy(msg, this);\n      }\n\n      else {\n         throw new Error(\"twrWasmAsyncModule - unknown and unexpected msgClass: \"+msgClass);\n      }\n   }\n\n   // given a url, load its contents, and stuff into Wasm memory similar to Unint8Array\n   async fetchAndPutURL(fnin:URL):Promise<[number, number]> {\n\n      if (!(typeof fnin === 'object' && fnin instanceof URL))\n         throw new Error(\"fetchAndPutURL param must be URL\");\n\n      try {\n         let response=await fetch(fnin);\n         let buffer = await response.arrayBuffer();\n         let src = new Uint8Array(buffer);\n         let dest=await this.wasmMem.putU8(src);\n         return [dest, src.length];\n         \n      } catch(err:any) {\n         console.log('fetchAndPutURL Error. URL: '+fnin+'\\n' + err + (err.stack ? \"\\n\" + err.stack : ''));\n         throw err;\n      }\n   }\n}\n","module.exports = new __parcel__URL__(\"../twrmodasyncproxy.205483dd.js\").toString();"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","twrWasmModule","twrWasmModuleAsync","twrConsoleDiv","twrConsoleTerminal","keyEventToCodePoint","twrConsoleDebug","twrConsoleCanvas","twrLibrary","twrLibraryInstanceRegistry","$e3af081ed3b5b25b$export$599419144fb0094a","$3tyux","$7KBfz","$6QEzV","wasmMem","wasmCall","callC","getImports","imports","twr_register_callback","registerCallback","bind","loadWasm","pathToLoad","response","instance","fetch","ok","statusText","console","log","wasmBytes","arrayBuffer","WebAssembly","instantiate","env","stack","memory","malloc","free","twrWasmMemory","twrWasmCall","funcNameIdx","funcName","getString","onEventCallback","twrEventQueueReceive","$287ed5d7d50ba8d6$export$d835cdc0f59e6ea8","$287ed5d7d50ba8d6$export$f59b88b16ecb0d13","$lVt1a","$287ed5d7d50ba8d6$export$ad21274072098225","mem8","mem16","mem32","memF","memD","constructor","Uint8Array","buffer","Uint16Array","Uint32Array","Float32Array","Float64Array","stringToU8","sin","codePage","codePageUTF8","ru8","encoder","TextEncoder","encode","codePage1252","length","i","to1252","codePageASCII","r","toASCII","copyString","buffer_size","getLong","idx","idx32","Math","floor","setLong","value","getDouble","idx64","setDouble","getShort","strIndex","len","encodeFormat","indexOf","td","TextDecoder","u8todecode","ArrayBuffer","decode","regularUint8Array","getU8Arr","rv","slice","size","dataptr","getU32Arr","putString","putU8","u8a","dest","putArrayBuffer","ab","u8","mallocImpl","callCImpl","$ff656e333be58c07$export$53f1026d7d1c23fb","$ff656e333be58c07$export$29f202393adbf96","$ff656e333be58c07$export$3d6ef5b62200d8d1","$ff656e333be58c07$export$ddea6250b326d061","$ff656e333be58c07$export$2e2bcd8739ae039","$ff656e333be58c07$export$c7de3f2686797480","$ff656e333be58c07$export$8644084c19ac418e","$ff656e333be58c07$export$69111c4ea6e0c4a0","$9lAov","twrUnicodeCodePointToCodePage","isCommonCode","twrCodePageToUnicodeCodePoint","twrUserLanguage","twrTimeTmLocal","twrUserLconv","twrRegExpTest1252","twrToUpper1252","twrToLower1252","twrStrcoll","twrGetDtnames","libSourcePath","URL","pathname","cpTranslate","cpTranslate2","callingMod","c","convert","outstr","cp","String","fromCodePoint","navigator","language","regexpStrIdx","regexp","RegExp","cstr","decoder1252","test","toLocaleLowerCase","codePointAt","toLocaleUpperCase","lhs","rhs","lhStr","undefined","rhStr","collator","Intl","Collator","compare","tmIdx","epochSecs","d","Date","getSeconds","getMinutes","getHours","getDate","getMonth","getFullYear","getDay","getDayOfYear","isDst","getTimezoneOffset","getTZ","date","start","diff","getTime","timeString","toLocaleTimeString","timeZoneName","includes","timeZone","split","pop","setAndPutString","mem","stridx","lconvIdx","locDec","getLocaleDecimalPoint","locSep","getLocaleThousandsSeparator","getLocalCurrencySymbol","formattedNumber","formatter","NumberFormat","format","replace","charAt","minimumFractionDigits","getLocaleCurrencyDecimalPoint","localeCurrency","tempFormatter","style","currency","resolvedOptions","dtnamesStructIdx","getLocalizedDayName","getLocalizedMonthNames","getLocalizedAM","getLocalizedPM","weekdayType","setDate","DateTimeFormat","weekday","monthType","month","morningDate","dayPeriodPart","formattedParts","hour","hour12","formatToParts","find","part","type","afternoonDate","instr","normalize","decoderUTF8","stream","fromCharCode","$6ce24e5be95ebe48$export$e0c9f0d281d749b5","$6ce24e5be95ebe48$export$67aa3c579b4a4587","$6ce24e5be95ebe48$export$5ab2b60d8abc5018","$6ce24e5be95ebe48$export$fdde87911cbb71ae","interfaceName","isTwrWasmModuleAsync","wasmImports","isModuleAsyncOnly","nullFun","derivedInstanceThis","libFunc","mod","libID","params","lib","getLibraryInstance","f","derivedLib","getProxyParams","processMessageFromProxy","msg","retVal","msgClass","doAwait","returnValueEventID","libThis","derivedInstance","eventQueueSend","postEvent","called","className","remoteProcedureCall","ownerMod","isAsyncFunction","args","postMessage","retVals","eventQueueReceive","waitEvent","getProxyImports","libClass","libMod","default","noBlock","registerEvent","libInstances","libInterfaceInstances","libInstance","push","interfaceID","getLibraryInstanceByInterfaceName","alreadyRegisteredLibInstance","$6ce24e5be95ebe48$var$CompareImports","obj1","obj2","keys1","keys","keys2","k","$6ce24e5be95ebe48$var$shallowEqual","getLibraryInstanceByClass","name","path","getLibraryInstanceID","libProxyInstances","registerProxy","libProxyInstance","getLibraryInstanceProxy","every","key","$4fc713716bd016cb$export$a2b31bb9f5a7d633","$4fc713716bd016cb$export$c59837088adec3b3","$dRr3I","circBuffer","twrSharedCircularBuffer","eventID","writeArray","postMalloc","mallocID","pendingEventIDs","pendingEventArgs","unqiueInt","onEventCallbacks","eventQueueBuffer","readEventRemainder","read","argLen","arg","readMallocRemainder","readCommandRemainder","firstValue","readCommand","readWaitCommand","readWait","findEvent","filterEvent","shift","index","splice","isEmpty","doCallbacks","upToIndex","end","processIncomingCommands","$a17536f066adc156$export$a01cca24f011573a","saBuffer","f64Array","i32Array","sa","window","crossOriginIsolated","location","protocol","SharedArrayBuffer","$a17536f066adc156$var$LEN","Int32Array","silentWrite","arr","Atomics","notify","write","rdptr","wait","$5a49b95e459921ed$export$adadb990ab47e6f0","$5a49b95e459921ed$export$9d4f0c051dfa35a8","fname","cparams","preCallC","retval","postCallC","Array","ci","p","j","$3c56311baef528c2$export$3298af74d75b595c","$eZP3w","$4Jz48","$jxXdl","$kwtqA","twrWasmBase","io","ioNamesToID","divLog","opts","parseModOptions","logToCon","stdio","twrLibBuiltIns","twrConGetIDFromName","nameIdx","twr_wasm_init","stderr","std2d","fetchAndPutURL","fnin","src","peekEvent","eventName","$aeae5dd39662a3ec$export$4dd3e184aad418c6","$8wznr","$8vcno","$a7Sa2","$9kgjF","document","eiodiv","getElementById","eiocanvas","foreColor","forecolor","backColor","backcolor","fontSize","fontsize","widthInChars","windim","heightInChars","d2dcanvas","ed2dcanvas","forEach","$634cc10760be4c8e$export$b0aa7e35767ef6cf","element","CURSOR","cursorOn","lastChar","extraBR","keyBuffer","keyWaiting","twrConCharOut","twrConGetProp","twrConPutStr","twrConCharIn","twrConSetFocus","HTMLDivElement","backgroundColor","color","font","toString","isHtmlEntityAtEnd","str","entityPattern","removeHtmlEntityAtEnd","focus","charOut","codePageUTF32","ch","innerHTML","chnum","getBoundingClientRect","scrollTo","height","newchr","pn","propName","getProp","IOTypes","CHARWRITE","CHARREAD","keyDown","ev","twrConCharIn_async","Promise","resolve","putStr","chars","$372690b1a012f88a$export$5d8b86200307417d","$372690b1a012f88a$export$7c0e7cc0cf9b4038","$372690b1a012f88a$export$7bb3402d2891b796","ADDRESSABLE_DISPLAY","CANVAS2D","EVENTS","isComposing","metaKey","con","$630ad1ae0230dd63$export$e1daeed5216ed90a","D2DType","$630ad1ae0230dd63$var$D2DType","ctx","props","precomputedObjects","twrConDrawSeq","twrConLoadImage","HTMLCanvasElement","getContext","textBaseline","canvasHeight","canvasWidth","width","twrConLoadImage_async","urlPtr","url","img","Image","onload","onerror","ds","nextInsHdr","currentInsHdr","lastInsHdr","currentInsParams","D2D_FILLRECT","x","y","w","h","fillRect","D2D_STROKERECT","strokeRect","D2D_FILLCODEPOINT","txt","fillText","D2D_FILLTEXT","strPointer","D2D_MEASURETEXT","tmidx","tm","measureText","actualBoundingBoxAscent","actualBoundingBoxDescent","actualBoundingBoxLeft","actualBoundingBoxRight","fontBoundingBoxAscent","fontBoundingBoxDescent","D2D_SETFONT","fontPointer","D2D_SETFILLSTYLERGBA","cssColor","fillStyle","D2D_SETSTROKESTYLERGBA","strokeStyle","D2D_SETFILLSTYLE","cssColorPointer","D2D_SETSTROKESTYLE","D2D_SETLINEWIDTH","lineWidth","D2D_MOVETO","moveTo","D2D_LINETO","lineTo","D2D_BEZIERTO","cp1x","cp1y","cp2x","cp2y","bezierCurveTo","D2D_BEGINPATH","beginPath","D2D_FILL","fill","D2D_SAVE","save","D2D_RESTORE","restore","D2D_STROKE","stroke","D2D_ARC","radius","startAngle","endAngle","counterClockwise","arc","D2D_IMAGEDATA","z","Uint8ClampedArray","ImageData","D2D_CREATERADIALGRADIENT","x0","y0","radius0","x1","y1","radius1","gradient","createRadialGradient","D2D_CREATELINEARGRADIENT","createLinearGradient","D2D_SETCOLORSTOP","pos","addColorStop","D2D_SETFILLSTYLEGRADIENT","D2D_RELEASEID","D2D_PUTIMAGEDATA","imgData","dx","dy","dirtyX","dirtyY","dirtyWidth","dirtyHeight","from","putImageData","D2D_CLOSEPATH","closePath","D2D_RESET","reset","D2D_CLEARRECT","clearRect","D2D_SCALE","scale","D2D_TRANSLATE","translate","D2D_ROTATE","angle","rotate","D2D_GETTRANSFORM","matrix_ptr","transform","getTransform","a","b","D2D_SETTRANSFORM","setTransform","D2D_RESETTRANSFORM","resetTransform","D2D_STROKETEXT","strokeText","D2D_ROUNDRECT","radii","roundRect","D2D_ELLIPSE","radiusX","radiusY","rotation","ellipse","D2D_QUADRATICCURVETO","cpx","cpy","quadraticCurveTo","D2D_SETLINEDASH","segment_len","seg_ptr","segments","setLineDash","D2D_GETLINEDASH","getLineDash","buffer_length","buffer_ptr","segment_length_ptr","min","D2D_ARCTO","x2","y2","arcTo","D2D_GETLINEDASHLENGTH","D2D_DRAWIMAGE","sx","sy","sWidth","sHeight","dWidth","dHeight","drawImage","D2D_RECT","rect","D2D_TRANSFORM","D2D_SETLINECAP","lineCapPtr","lineCap","D2D_SETLINEJOIN","lineJoinPtr","lineJoin","D2D_SETLINEDASHOFFSET","lineDashOffset","D2D_GETIMAGEDATA","getImageData","D2D_IMAGEDATATOC","bufferPtr","bufferLen","imgLen","data","byteLength","D2D_GETCANVASPROPDOUBLE","valPtr","namePtr","val","D2D_GETCANVASPROPSTRING","valMaxLen","encodedVal","strLen","D2D_SETCANVASPROPDOUBLE","prevVal","D2D_SETCANVASPROPSTRING","$75f49210bbda5451$export$3217cba298dc07f7","cellWidth","cellHeight","cellW1","cellW2","cellH1","cellH2","cellH3","isCursorVisible","videoMem","foreColorMem","backColorMem","twrConSetC32","twrConCls","twrConSetRange","twrConSetReset","twrConPoint","twrConSetCursor","twrConSetCursorXY","twrConSetColors","canvasElement","sampleText","charWidth","ceil","fM","charHeight","c2","backColorAsRGB","Number","foreColorAsRGB","cursorPos","RGB_TO_RGBA","eraseLine","setC32","c32","drawRange","startSave","endSave","setFillStyleRGB","padStart","drawTrs80Graphic","offset","fgc","bgc","drawCell","setRangeJS","values","isset","loc","cellx","celly","foreground","background","$6ca2a3642a328c4c$export$e501d006d4cbf5f7","logline","char","$ef0d9f8991255236$export$76382e3dd4b349bf","$dCETg","$ezn7a","$8YYID","$3kGIl","$7qdpQ","$ef0d9f8991255236$var$defaultLibsAreRegistered","$9eae8aeb8166011a$export$2e2bcd8739ae039","twrSin","twrCos","twrTan","twrACos","twrASin","twrATan","twrATan2","twrFAbs","twrExp","twrFloor","twrCeil","twrLog","twrSqrt","twrTrunc","twrFMod","twrPow","twrAtod","twrDtoa","twrToFixed","twrToExponential","twrFcvtS","cos","tan","acos","asin","atan","atan2","abs","exp","sqrt","trunc","pow","atod","dtoa","toFixed","toExponential","fcvtS","strptr","upper","trimStart","toUpperCase","POSITIVE_INFINITY","NEGATIVE_INFINITY","parseFloat","replaceAll","max_precision","toPrecision","decdigits","sizeInBytes","fracpart_numdigits","dec","sign","digits","decpos","isNaN","isFinite","intPart","fracPart","roundValStr","$a9b643aa1d2067d4$export$2e2bcd8739ae039","twr_timer_single_shot","twr_timer_repeat","twr_timer_cancel","twr_sleep","milliSeconds","setTimeout","setInterval","timerID","clearInterval","twr_sleep_async","$68a306d142e55338$export$2e2bcd8739ae039","NodeType","$68a306d142e55338$var$NodeType","nextID","nextPlaybackID","context","AudioContext","nodes","playbacks","internalSetupAudioBuffer","numChannels","sampleRate","singleChannelDataLen","createBuffer","AudioBuffer","twrAudioFromFloatPCM","dataPtr","channel","channelBuff","getChannelData","startPos","twrAudioFrom8bitPCM","dataBuff","twrAudioFrom16bitPCM","twrAudioFrom32bitPCM","internalGetAnyPCMPart1","nodeID","singleChannelDataLenPtr","channelPtr","node","audioBuffer","totalLen","numberOfChannels","internalSyncGetAnyPCM","dataSize","part2","internalGetSamplesPart1","internalAsyncGetAnyPCM","internalGetFloatPCMPart2","twrAudioGetFloatPCM","twrAudioGetFloatPCM_async","internalGet8bitPCMPart2","retBuffer","round","twrAudioGet8bitPCM","twrAudioGet8bitPCM_async","internalGet16bitPCMPart2","twrAudioGet16bitPCM","twrAudioGet16bitPCM_async","internalGet32bitPCMPart2","twrAudioGet32bitPCM","twrAudioGet21bitPCM_async","twrAudioPlay","volume","pan","finishCallback","twrAudioPlayRange","internalAudioPlayRange","startSample","endSample","loop","promise","sourceBuffer","createBufferSource","reject","onended","startTime","endTime","loopStart","loopEnd","playbackRate","gainNode","createGain","gain","connect","panNode","createStereoPanner","destination","then","playback_id","twrAudioPlaySync_async","twrAudioPlayRangeSync_async","twrAudioQueryPlaybackPosition","playbackID","playback","HTMLAudioElement","currentTime","internalLoadAudio","res","decodeAudioData","twrAudioLoadSync_async","twrAudioLoad","twrAudioFreeID","twrAudioGetMetadata","metadataPtr","twrAudioStopPlayback","stop","MAX_SAFE_INTEGER","twrAudioModifyPlaybackVolume","max","audio","twrAudioModifyPlaybackPan","twrAudioModifyPlaybackRate","baseSampleRate","twrAudioPlayFile","fileURLPtr","Audio","play","$26d45f890e168707$export$2e2bcd8739ae039","twrTimeEpoch","BigInt","now","$56755e380ef9440b$export$2e2bcd8739ae039","$0a8a936a2dc396bf$export$678fe6e36ab9a6ff","myWorker","loadWasmResolve","loadWasmReject","callCMap","uniqueInt","initLW","callCInstance","twrEventQueueSend","Map","Worker","event","message","onmessage","processMsg","libProxyParams","allProxyParams","startMsg","urlToLoad","href","callCResolve","callCReject","keyDownDiv","keyDownCanvas","msgType","twrWasmMemoryAsync","twrWasmModuleCallAsync","returnCode","delete"],"version":3,"file":"index.e96d9fe1.js.map"}