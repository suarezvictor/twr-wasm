{"mappings":"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","sources":["<anon>","../lib-js/twrmodasyncproxy.js","../source/twr-ts/twrmodasyncproxy.ts","../lib-js/twrmodbase.js","../source/twr-ts/twrmodbase.ts","../lib-js/twrfloat.js","../source/twr-ts/twrfloat.ts","../lib-js/twrlocale.js","../source/twr-ts/twrlocale.ts","../lib-js/twrdate.js","../source/twr-ts/twrdate.ts","../lib-js/twrcondiv.js","../source/twr-ts/twrcondiv.ts","../lib-js/twrcircular.js","../source/twr-ts/twrcircular.ts","../lib-js/twrcon.js","../source/twr-ts/twrcon.ts","../lib-js/twrconreg.js","../source/twr-ts/twrconreg.ts","../lib-js/twrwaitingcalls.js","../source/twr-ts/twrwaitingcalls.ts","../lib-js/twrsignal.js","../source/twr-ts/twrsignal.ts","../lib-js/twrcanvas.js","../source/twr-ts/twrcanvas.ts","../lib-js/twrcondebug.js","../source/twr-ts/twrcondebug.ts","../lib-js/twrconterm.js","../source/twr-ts/twrconterm.ts"],"sourcesContent":["(() => {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $2e39aae7c890164c$exports = {};\n\n$parcel$export($2e39aae7c890164c$exports, \"twrWasmModuleAsyncProxy\", () => $2e39aae7c890164c$export$a5f3f3f0bd96bb23);\nclass $9bb9a90df2906a7c$export$918ffb7e046a537b {\n    mod;\n    constructor(mod){\n        this.mod = mod;\n    }\n    atod(strptr, len) {\n        const str = this.mod.getString(strptr, len);\n        const upper = str.trimStart().toUpperCase();\n        if (upper == \"INF\" || upper == \"+INF\" || upper == \"INFINITY\" || upper == \"+INFINITY\") return Number.POSITIVE_INFINITY;\n        else if (upper == \"-INF\" || upper == \"-INFINITY\") return Number.NEGATIVE_INFINITY;\n        else {\n            // allow D for exponent -- old microsoft format they still support in _fctv and I support in my awbasic\n            // parseFloat will handle 'Infinity' and'-Infinity' literal\n            // parseFloat appears to be case sensitive when parsing 'Infinity'\n            // parseFloat ignores leading whitespace\n            // parseFloat() is more lenient than Number() because it ignores trailing invalid characters\n            const r = Number.parseFloat(str.replaceAll(\"D\", \"e\").replaceAll(\"d\", \"e\"));\n            return r;\n        }\n    }\n    dtoa(buffer, buffer_size, value, max_precision) {\n        if (max_precision == -1) {\n            const r = value.toString();\n            this.mod.copyString(buffer, buffer_size, r);\n        } else {\n            let r = value.toString();\n            if (r.length > max_precision) r = value.toPrecision(max_precision);\n            this.mod.copyString(buffer, buffer_size, r);\n        }\n    }\n    toFixed(buffer, buffer_size, value, decdigits) {\n        const r = value.toFixed(decdigits);\n        this.mod.copyString(buffer, buffer_size, r);\n    }\n    toExponential(buffer, buffer_size, value, decdigits) {\n        const r = value.toExponential(decdigits);\n        this.mod.copyString(buffer, buffer_size, r);\n    }\n    // emulates the MS C lib function _fcvt_s, but doesn't support all ranges of number.\n    // Number.toFixed() has a max size of 100 fractional digits,  and values must be less than 1e+21\n    // Negative exponents must be now smaller than 1e-99\n    // fully-function C version also int he source, but this is the version enabled by default\n    fcvtS(buffer, sizeInBytes, value, fracpart_numdigits, dec, sign // int *\n    ) {\n        if (buffer == 0 || sign == 0 || dec == 0 || sizeInBytes < 1) return 1;\n        let digits;\n        let decpos;\n        let s = 0; // default to positive\n        if (Number.isNaN(value)) {\n            digits = \"1#QNAN00000000000000000000000000000\".slice(0, fracpart_numdigits + 1);\n            decpos = 1;\n        } else if (!Number.isFinite(value)) {\n            digits = \"1#INF00000000000000000000000000000\".slice(0, fracpart_numdigits + 1);\n            decpos = 1;\n        } else if (value == 0) {\n            digits = \"000000000000000000000000000000000000\".slice(0, fracpart_numdigits);\n            decpos = 0;\n        } else {\n            if (value < 0) {\n                s = 1; // negative\n                value = Math.abs(value);\n            }\n            if (fracpart_numdigits > 100 || value > 1e+21 || value < 1e-99) {\n                this.mod.copyString(buffer, sizeInBytes, \"\");\n                this.mod.mem32[dec] = 0;\n                return 1;\n            }\n            const roundValStr = value.toFixed(fracpart_numdigits);\n            let [intPart = \"\", fracPart = \"\"] = roundValStr.split(\".\");\n            if (intPart == \"0\") intPart = \"\";\n            if (intPart.length > 0) {\n                decpos = intPart.length;\n                digits = intPart + fracPart;\n            } else {\n                digits = fracPart.replace(/^0+/, \"\"); // remove leading zeros\n                decpos = digits.length - fracPart.length;\n            }\n        }\n        if (sizeInBytes - 1 < digits.length) return 1;\n        this.mod.copyString(buffer, sizeInBytes, digits);\n        this.mod.setLong(dec, decpos);\n        this.mod.setLong(sign, s);\n        return 0;\n    /*\n        this version 'works' with larger numbers than using toFixed, but doesn't round correctly\n\n        let decpos=0;\n        let digits:string;\n        if (value!=0) decpos=Math.floor(Math.log10(value))+1;\n    \n        if (decpos>0) { // has integer part\n            const intlen=Math.max(decpos, 0);\n            console.log(\"intlen=\",intlen, \"decpos=\",decpos);\n            const [nonExponent, exponent=0] = value.toPrecision(intlen+fracpart_numdigits).split('e');\n            digits=nonExponent.replace('.', '');\n            digits=digits.replace(/^0+/,\"\");  // remove leading zeros\n        }\n        else { // only a fraction\n            const intpart=Math.trunc(value);\n            const fracpart=value-intpart;\n            const prec=fracpart_numdigits- (-decpos);\n            console.log(\"prec=\",prec);\n            if (prec<1) {\n                digits=\"\";\n            }\n            else {\n                const [nonExponent, exponent=0] = fracpart.toPrecision(prec).split('e');\n                digits=nonExponent.replace('.', '');\n                digits=digits.replace(/^0+/,\"\");\n            }\n        }\n\n        console.log(\"fcvtS value\",value,\"fracpart_numdigits\",fracpart_numdigits);\n        console.log('digits=',digits);\n        console.log('dec=',decpos);\n        console.log(\"sign=\",s);\n    */ }\n}\n\n\n// these match C #defines in locale.h\nconst $07ff08a59ba75008$export$53f1026d7d1c23fb = 0;\nconst $07ff08a59ba75008$export$29f202393adbf96 = 1252;\nconst $07ff08a59ba75008$export$3d6ef5b62200d8d1 = 65001;\nconst $07ff08a59ba75008$export$ddea6250b326d061 = 12000;\nclass $07ff08a59ba75008$export$c7de3f2686797480 {\n    decoderUTF8 = new TextDecoder(\"utf-8\");\n    decoder1252 = new TextDecoder(\"windows-1252\");\n    convert(c, codePage) {\n        let outstr;\n        if (codePage == $07ff08a59ba75008$export$3d6ef5b62200d8d1) outstr = this.decoderUTF8.decode(new Uint8Array([\n            c\n        ]), {\n            stream: true\n        });\n        else if (codePage == $07ff08a59ba75008$export$29f202393adbf96) outstr = this.decoder1252.decode(new Uint8Array([\n            c\n        ]));\n        else if (codePage == $07ff08a59ba75008$export$53f1026d7d1c23fb) {\n            if (c > 127) outstr = \"\";\n            else outstr = String.fromCharCode(c);\n        } else if (codePage == $07ff08a59ba75008$export$ddea6250b326d061) outstr = String.fromCodePoint(c);\n        else throw new Error(\"unsupported CodePage: \" + codePage);\n        return outstr.codePointAt(0) || 0;\n    }\n}\nconst $07ff08a59ba75008$var$cpTranslate = new $07ff08a59ba75008$export$c7de3f2686797480();\nfunction $07ff08a59ba75008$export$b1748e2af4950b56(outstr, cp, codePage) {\n    return $07ff08a59ba75008$var$noasyncCopyString(this, outstr, String.fromCodePoint(cp), codePage);\n}\nfunction $07ff08a59ba75008$export$99a2816c432302a9() {\n    return $07ff08a59ba75008$var$noasyncPutString(this, navigator.language, $07ff08a59ba75008$export$53f1026d7d1c23fb);\n}\nfunction $07ff08a59ba75008$export$6e12283a61625fd2(regexpStrIdx, c) {\n    const regexpStr = this.getString(regexpStrIdx);\n    const regexp = new RegExp(regexpStr, \"u\");\n    const cstr = $07ff08a59ba75008$var$cpTranslate.decoder1252.decode(new Uint8Array([\n        c\n    ]));\n    const r = regexp.test(cstr);\n    if (r) return 1;\n    else return 0;\n}\nfunction $07ff08a59ba75008$export$8644084c19ac418e(instr) {\n    if (instr.codePointAt(0) == 8239) return 32; // turn narrow-no-break-space into space\n    // this first switch statment fixes what appears to be a bug in safari 15.6.1 (17613.3.9.1.16) (comparisons to the character string fail)\n    let cp = instr.codePointAt(0) || 0;\n    switch(cp){\n        case 338:\n            return 0x8C;\n        case 339:\n            return 0x9C;\n        case 352:\n            return 0x8A;\n        case 353:\n            return 0x9A;\n        case 376:\n            return 0x9F;\n        case 381:\n            return 0x8E;\n        case 382:\n            return 0x9E;\n        case 402:\n            return 0x83;\n        case 710:\n            return 0x88;\n    }\n    switch(instr.normalize()){\n        case \"\\u20AC\":\n            return 0x80;\n        case \"\\u201A\":\n            return 0x82;\n        case \"\\u0192\":\n            return 0x83;\n        case \"\\u201E\":\n            return 0x84;\n        case \"\\u2026\":\n            return 0x85;\n        case \"\\u2020\":\n            return 0x86;\n        case \"\\u2021\":\n            return 0x87;\n        case \"\\u02C6\":\n            return 0x88;\n        case \"\\u2030\":\n            return 0x89;\n        case \"\\u0160\":\n            return 0x8A;\n        case \"\\u2039\":\n            return 0x8B;\n        case \"\\u0152\":\n            return 0x8C;\n        case \"\\u017D\":\n            return 0x8E;\n        case \"\\u2018\":\n            return 0x91;\n        case \"\\u2019\":\n            return 0x92;\n        case \"\\u201C\":\n            return 0x93;\n        case \"\\u201D\":\n            return 0x94;\n        case \"\\u2022\":\n            return 0x95;\n        case \"\\u2013\":\n            return 0x96;\n        case \"\\u2014\":\n            return 0x97;\n        case \"\\u02DC\":\n            return 0x98;\n        case \"\\u2122\":\n            return 0x99;\n        case \"\\u0161\":\n            return 0x9A;\n        case \"\\u203A\":\n            return 0x9B;\n        case \"\\u0153\":\n            return 0x9C;\n        case \"\\u017E\":\n            return 0x9E;\n        case \"\\u0178\":\n            return 0x9F;\n    }\n    if (cp > 255) {\n        console.log(\"twr-wasm.to1252(): unable to convert: \", instr, cp);\n        cp = 0;\n    }\n    return cp;\n}\nfunction $07ff08a59ba75008$export$69111c4ea6e0c4a0(instr) {\n    if (instr == \"\\u0192\") return 102; // lowercase 'f'\n    if (instr.codePointAt(0) == 8239) return 32; // turn narrow-no-break-space into space\n    let cp = instr.codePointAt(0) || 0;\n    if (cp > 127) return 63; // ASCII for \"?\"\n    return cp;\n}\nfunction $07ff08a59ba75008$export$1619a0be8731b76a(c) {\n    const cstr = $07ff08a59ba75008$var$cpTranslate.decoder1252.decode(new Uint8Array([\n        c\n    ]));\n    const regexp = new RegExp(\"^\\\\p{Letter}$\", \"u\");\n    if (regexp.test(cstr)) {\n        const r = $07ff08a59ba75008$export$8644084c19ac418e(cstr.toLocaleLowerCase());\n        //console.log(\"twrToLower1252Impl: isLetter\", c, cstr, cstr.codePointAt(0), cstr.toLocaleLowerCase(), cstr.toLocaleLowerCase().codePointAt(0), r);\n        return r;\n    } else //console.log(\"twrToLower1252Impl: isNOTLetter\", c, cstr, cstr.codePointAt(0));\n    return c;\n}\nfunction $07ff08a59ba75008$export$b8cd0608a44dce64(c) {\n    const cstr = $07ff08a59ba75008$var$cpTranslate.decoder1252.decode(new Uint8Array([\n        c\n    ]));\n    if (cstr.codePointAt(0) == 402) return c; // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is ƒ\n    if (cstr.codePointAt(0) == 181) return c; // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is µ\n    if (cstr.codePointAt(0) == 223) return c; // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is ß'\n    if (cstr == \"\\xb5\") return c; // upper case version doesn't fit in 1252\n    if (cstr == \"\\u0192\") return c; // upper case version doesn't fit in 1252\n    if (cstr == \"\\xdf\") return c; // toLocaleUpperCase() will convert beta to SS\n    const regexp = new RegExp(\"^\\\\p{Letter}$\", \"u\");\n    if (regexp.test(cstr)) return $07ff08a59ba75008$export$8644084c19ac418e(cstr.toLocaleUpperCase());\n    else return c;\n}\nfunction $07ff08a59ba75008$export$2663d7470da86e92(lhs, rhs, codePage) {\n    const lhStr = this.getString(lhs, undefined, codePage);\n    const rhStr = this.getString(rhs, undefined, codePage);\n    // c strcmp(): A positive integer if str1 is greater than str2.\n    // 1 if string 1 (lh) comes after string 2 (rh)\n    const collator = new Intl.Collator();\n    const r = collator.compare(lhStr, rhStr);\n    return r;\n}\nfunction $07ff08a59ba75008$export$a0bf9983b7d1ed7c(tmIdx, epochSecs) {\n    const d = new Date(epochSecs * 1000);\n    this.setLong(tmIdx, d.getSeconds());\n    this.setLong(tmIdx + 4, d.getMinutes());\n    this.setLong(tmIdx + 8, d.getHours());\n    this.setLong(tmIdx + 12, d.getDate());\n    this.setLong(tmIdx + 16, d.getMonth());\n    this.setLong(tmIdx + 20, d.getFullYear() - 1900);\n    this.setLong(tmIdx + 24, d.getDay());\n    this.setLong(tmIdx + 28, $07ff08a59ba75008$var$getDayOfYear(d));\n    this.setLong(tmIdx + 32, $07ff08a59ba75008$var$isDst());\n    this.setLong(tmIdx + 36, -d.getTimezoneOffset() * 60);\n    this.setLong(tmIdx + 40, $07ff08a59ba75008$var$noasyncPutString(this, $07ff08a59ba75008$var$getTZ(d), $07ff08a59ba75008$export$53f1026d7d1c23fb));\n}\nfunction $07ff08a59ba75008$var$getDayOfYear(date) {\n    const start = new Date(date.getFullYear(), 0, 1);\n    const diff = date.getTime() - start.getTime(); // Difference in milliseconds\n    const oneDay = 86400000; // Number of milliseconds in one day\n    const day = Math.floor(diff / oneDay);\n    return day;\n}\nfunction $07ff08a59ba75008$var$isDst() {\n    const timeString = new Date().toLocaleTimeString(\"en-US\", {\n        timeZoneName: \"long\"\n    });\n    if (timeString.includes(\"Daylight\")) return 1;\n    else return 0;\n}\nfunction $07ff08a59ba75008$var$getTZ(date) {\n    const timeZone = date.toLocaleTimeString(\"en-US\", {\n        timeZoneName: \"short\"\n    }).split(\" \").pop();\n    return timeZone ? timeZone : \"UTC\";\n}\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\nfunction $07ff08a59ba75008$var$setAndPutString(mod, idx, sin, codePage) {\n    const stridx = $07ff08a59ba75008$var$noasyncPutString(mod, sin, codePage);\n    mod.setLong(idx, stridx);\n}\n// JS string into the webassembly module memory.  \n// Does not verify outbuf length. \n// Encode the Wasm string using codePage\n// Does NOT zero terminate string\nfunction $07ff08a59ba75008$var$noasyncCopyString(mod, outbuf, sin, codePage) {\n    const ru8 = mod.stringToU8(sin, codePage);\n    mod.mem8.set(ru8, outbuf);\n    return ru8.length;\n}\n// allocate and copy a JS string into the webassembly module memory, encode the Wasm string using codePage\nfunction $07ff08a59ba75008$var$noasyncPutString(mod, sin, codePage) {\n    const ru8 = mod.stringToU8(sin, codePage);\n    const malloc = mod.exports.malloc;\n    const strIndex = malloc(ru8.length + 1);\n    mod.mem8.set(ru8, strIndex);\n    mod.mem8[strIndex + ru8.length] = 0;\n    return strIndex;\n}\nfunction $07ff08a59ba75008$export$714291919e374cc0(lconvIdx, codePage) {\n    const locDec = $07ff08a59ba75008$var$getLocaleDecimalPoint();\n    const locSep = $07ff08a59ba75008$var$getLocaleThousandsSeparator();\n    $07ff08a59ba75008$var$setAndPutString(this, lconvIdx + 0, locDec, codePage);\n    $07ff08a59ba75008$var$setAndPutString(this, lconvIdx + 4, locSep, codePage);\n    $07ff08a59ba75008$var$setAndPutString(this, lconvIdx + 20, locDec, codePage);\n    $07ff08a59ba75008$var$setAndPutString(this, lconvIdx + 24, locSep, codePage);\n    $07ff08a59ba75008$var$setAndPutString(this, lconvIdx + 24, locSep, codePage);\n    $07ff08a59ba75008$var$setAndPutString(this, lconvIdx + 24, locSep, codePage);\n    $07ff08a59ba75008$var$setAndPutString(this, lconvIdx + 32, \"+\", codePage);\n    $07ff08a59ba75008$var$setAndPutString(this, lconvIdx + 36, \"-\", codePage);\n    $07ff08a59ba75008$var$setAndPutString(this, lconvIdx + 12, $07ff08a59ba75008$var$getLocalCurrencySymbol(), codePage);\n    $07ff08a59ba75008$var$setAndPutString(this, lconvIdx + 16, $07ff08a59ba75008$var$getLocalCurrencySymbol(), codePage);\n}\nfunction $07ff08a59ba75008$var$getLocaleDecimalPoint() {\n    const formatter = new Intl.NumberFormat();\n    //console.log(\"dec resolvedOptions\", formatter.resolvedOptions());\n    // Format a test number to find out the decimal point.\n    const formattedNumber = formatter.format(1.1);\n    //console.log(\"dec formattedNumber\", formattedNumber);\n    // Find the character between the numeric parts.\n    const decimalPoint = formattedNumber.replace(/[0-9]/g, \"\").charAt(0);\n    return decimalPoint;\n}\nfunction $07ff08a59ba75008$var$getLocaleThousandsSeparator() {\n    const formatter = new Intl.NumberFormat(undefined, {\n        minimumFractionDigits: 0 // Ensure no decimal part interferes\n    });\n    // Format a test number to include a thousands separator.\n    const formattedNumber = formatter.format(1000);\n    //console.log(\"sep formattedNumber\", formattedNumber);\n    // Extract the thousands separator by removing numeric characters and possible decimal points.\n    // This may need adjustment depending on whether other characters are present.\n    let thousandsSeparator = formattedNumber.replace(/[0-9]/g, \"\").charAt(0); // Assumes separator is the first character.\n    //console.log(\"sep code\",  thousandsSeparator.codePointAt(0));\n    return thousandsSeparator;\n}\n// this doesn't work, localeCurrency is not correct\nfunction $07ff08a59ba75008$var$getLocaleCurrencyDecimalPoint() {\n    // Create an initial NumberFormat object to detect the locale's currency\n    const tempFormatter = new Intl.NumberFormat(undefined, {\n        style: \"currency\",\n        currency: \"USD\"\n    });\n    const localeCurrency = tempFormatter.resolvedOptions().currency;\n    const formatter = new Intl.NumberFormat(undefined, {\n        style: \"currency\",\n        currency: localeCurrency\n    });\n    // Format a test number to find out the decimal point.\n    const formattedNumber = formatter.format(1.1);\n    // Find the character between the numeric parts.\n    // char(0) is the currency symbol\n    const decimalPoint = formattedNumber.replace(/[0-9]/g, \"\").charAt(1);\n    return decimalPoint;\n}\nfunction $07ff08a59ba75008$var$getLocalCurrencySymbol() {\n    switch(navigator.language){\n        case \"en-US\":\n        case \"en-CA\":\n        case \"fr-CA\":\n        case \"en-AU\":\n        case \"es-MX\":\n        case \"es-AR\":\n        case \"es-CL\":\n        case \"es-CO\":\n        case \"es-EC\":\n        case \"en-GY\":\n        case \"nl-SR\":\n        case \"es-UY\":\n        case \"en-BZ\":\n        case \"es-SV\":\n        case \"es-PA\":\n            return \"$\";\n        case \"es-BO\":\n        case \"es-VE\":\n            return \"Bs.\";\n        case \"es-PY\":\n            return \"\\u20B2\";\n        case \"es-PE\":\n            return \"S/\";\n        case \"es-CR\":\n            return \"\\u20A1\";\n        case \"es-GT\":\n            return \"Q\";\n        case \"es-HN\":\n            return \"L\";\n        case \"es-NI\":\n            return \"C$\";\n        case \"en-GB\":\n            return \"\\xa3\";\n        case \"en-IE\":\n        case \"de-DE\":\n        case \"fr-FR\":\n        case \"de-AT\":\n        case \"nl-BE\":\n        case \"fr-BE\":\n        case \"el-CY\":\n        case \"et-EE\":\n        case \"fi-FI\":\n        case \"sv-FI\":\n        case \"el-GR\":\n        case \"it-IT\":\n        case \"lv-LV\":\n        case \"lt-LT\":\n        case \"fr-LU\":\n        case \"de-LU\":\n        case \"lb-LU\":\n        case \"mt-MT\":\n        case \"nl-NL\":\n        case \"pt-PT\":\n        case \"sk-SK\":\n        case \"sl-SI\":\n        case \"es-ES\":\n            return \"\\u20AC\";\n        case \"ja-JP\":\n            return \"\\xa5\";\n        case \"zh-CN\":\n            return \"\\xa5\";\n        case \"de-CH\":\n        case \"fr-CH\":\n        case \"it-CH\":\n            return \"CHF\";\n        case \"sv-SE\":\n        case \"da-DK\":\n        case \"nb-NO\":\n            return \"kr\";\n        case \"ru-RU\":\n            return \"\\u20BD\";\n        case \"ko-KR\":\n            return \"\\u20A9\";\n        case \"en-IN\":\n            return \"\\u20B9\";\n        case \"pt-BR\":\n            return \"R$\";\n        case \"he-IL\":\n            return \"\\u20AA\";\n        case \"tr-TR\":\n            return \"\\u20BA\";\n        default:\n            return \"\";\n    }\n}\nfunction $07ff08a59ba75008$export$6e74b5e725f469d6(codePage) {\n    const malloc = this.exports.malloc;\n    const dtnamesStructIdx = malloc(160);\n    for(let i = 0; i < 7; i++)$07ff08a59ba75008$var$setAndPutString(this, dtnamesStructIdx + i * 4, $07ff08a59ba75008$var$getLocalizedDayName(i, \"long\"), codePage);\n    for(let i = 0; i < 7; i++)$07ff08a59ba75008$var$setAndPutString(this, dtnamesStructIdx + (i + 7) * 4, $07ff08a59ba75008$var$getLocalizedDayName(i, \"short\"), codePage);\n    for(let i = 0; i < 12; i++)$07ff08a59ba75008$var$setAndPutString(this, dtnamesStructIdx + (i + 14) * 4, $07ff08a59ba75008$var$getLocalizedMonthNames(i, \"long\"), codePage);\n    for(let i = 0; i < 12; i++)$07ff08a59ba75008$var$setAndPutString(this, dtnamesStructIdx + (i + 14 + 12) * 4, $07ff08a59ba75008$var$getLocalizedMonthNames(i, \"short\"), codePage);\n    $07ff08a59ba75008$var$setAndPutString(this, dtnamesStructIdx + 152, $07ff08a59ba75008$var$getLocalizedAM(), codePage);\n    $07ff08a59ba75008$var$setAndPutString(this, dtnamesStructIdx + 156, $07ff08a59ba75008$var$getLocalizedPM(), codePage);\n    return dtnamesStructIdx;\n}\nfunction $07ff08a59ba75008$var$getLocalizedDayName(n, weekdayType) {\n    // Create a Date object for the desired day of the week\n    const date = new Date();\n    date.setDate(date.getDate() - date.getDay() + n);\n    // Create an Intl.DateTimeFormat object with the desired locale and options\n    const formatter = new Intl.DateTimeFormat(undefined, {\n        weekday: weekdayType\n    });\n    // Format the date to get the full day name\n    return formatter.format(date);\n}\nfunction $07ff08a59ba75008$var$getLocalizedMonthNames(n, monthType) {\n    const formatter = new Intl.DateTimeFormat(undefined, {\n        month: monthType\n    });\n    const date = new Date(2000, n, 1);\n    return formatter.format(date);\n}\nfunction $07ff08a59ba75008$var$getLocalizedAM() {\n    // Create a Date object for a time in the morning\n    const morningDate = new Date(2000, 0, 1, 9, 0, 0);\n    // Create an Intl.DateTimeFormat object with the desired locale and options\n    const formatter = new Intl.DateTimeFormat(undefined, {\n        hour: \"numeric\",\n        hour12: true\n    });\n    // Format the date and get the parts\n    const formattedParts = formatter.formatToParts(morningDate);\n    // Find the part of the formatted string that corresponds to the day period (AM/PM)\n    const dayPeriodPart = formattedParts.find((part)=>part.type === \"dayPeriod\");\n    return dayPeriodPart ? dayPeriodPart.value : \"\";\n}\nfunction $07ff08a59ba75008$var$getLocalizedPM() {\n    // Create a Date object for a time in the afternoon\n    const afternoonDate = new Date(2000, 0, 1, 15, 0, 0);\n    // Create an Intl.DateTimeFormat object with the desired locale and options\n    const formatter = new Intl.DateTimeFormat(undefined, {\n        hour: \"numeric\",\n        hour12: true\n    });\n    // Format the date and get the parts\n    const formattedParts = formatter.formatToParts(afternoonDate);\n    // Find the part of the formatted string that corresponds to the day period (AM/PM)\n    const dayPeriodPart = formattedParts.find((part)=>part.type === \"dayPeriod\");\n    return dayPeriodPart ? dayPeriodPart.value : \"\";\n}\n\n\nclass $650c04823a04b22b$export$c83a0a3bffe07399 {\n    memory;\n    mem8;\n    mem32;\n    memD;\n    exports;\n    isAsyncProxy = false;\n    floatUtil;\n    constructor(){\n        this.mem8 = new Uint8Array(); // avoid type errors\n        this.mem32 = new Uint32Array(); // avoid type errors\n        this.memD = new Float64Array(); // avoid type errors\n        this.floatUtil = new (0, $9bb9a90df2906a7c$export$918ffb7e046a537b)(this);\n    //console.log(\"size of mem8 after constructor\",this.mem8.length);\n    }\n    /*********************************************************************/ /*********************************************************************/ // overridden by twrWasmModuleAsync\n    async loadWasm(pathToLoad, imports, ioNamesToID) {\n        //console.log(\"fileToLoad\",fileToLoad)\n        let response;\n        try {\n            response = await fetch(pathToLoad);\n        } catch (err) {\n            console.log(\"loadWasm() failed to fetch: \" + pathToLoad);\n            throw err;\n        }\n        if (!response.ok) throw new Error(\"fetch response error on file '\" + pathToLoad + \"'\\n\" + response.statusText);\n        try {\n            let wasmBytes = await response.arrayBuffer();\n            let instance = await WebAssembly.instantiate(wasmBytes, {\n                env: imports\n            });\n            this.exports = instance.instance.exports;\n            if (!this.exports) throw new Error(\"Unexpected error - undefined instance.exports\");\n            if (this.memory) throw new Error(\"unexpected error -- this.memory already set\");\n            this.memory = this.exports.memory;\n            if (!this.memory) throw new Error(\"Unexpected error - undefined exports.memory\");\n            this.mem8 = new Uint8Array(this.memory.buffer);\n            this.mem32 = new Uint32Array(this.memory.buffer);\n            this.memD = new Float64Array(this.memory.buffer);\n            // SharedArrayBuffer required for twrWasmModuleAsync/twrWasmModuleAsyncProxy\n            // instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error\n            // (don't check for instanceof SharedArrayBuffer, since it can cause an runtime error when SharedArrayBuffer does not exist)\n            if (this.isAsyncProxy) {\n                if (this.memory.buffer instanceof ArrayBuffer) console.log(\"twrWasmModuleAsync requires shared Memory. Add wasm-ld --shared-memory --no-check-features (see docs)\");\n                postMessage([\n                    \"setmemory\",\n                    this.memory\n                ]);\n            } else // here if twrWasmModule because twrWasmModuleAsync overrides this function, and twrWasmModuleAsyncProxy was handled above\n            if (!(this.memory.buffer instanceof ArrayBuffer)) console.log(\"twrWasmModule does not require shared Memory. Okay to remove wasm-ld --shared-memory --no-check-features\");\n            this.malloc = (size)=>{\n                return new Promise((resolve)=>{\n                    const m = this.exports.malloc;\n                    resolve(m(size));\n                });\n            };\n            this.init(ioNamesToID);\n        } catch (err) {\n            console.log(\"Wasm instantiate error: \" + err + (err.stack ? \"\\n\" + err.stack : \"\"));\n            throw err;\n        }\n    }\n    init(ioNamesToID) {\n        const twrInit = this.exports.twr_wasm_init;\n        twrInit(ioNamesToID.stdio, ioNamesToID.stderr, ioNamesToID.std2d == undefined ? -1 : ioNamesToID.std2d, this.mem8.length);\n    }\n    /*\n    * this is overridden by twrmodasync (although its worker side will call this version)\n    *\n    * callC takes an array where:\n    * the first entry is the name of the C function in the Wasm module to call (must be exported, typically via the --export clang flag)\n    * and the next entries are a variable number of arguments to pass to the C function, of type\n    * number - converted to int32 or float64 as appropriate\n    * string - converted to a an index (ptr) into a module Memory returned via stringToMem()\n    * URL - the file contents are loaded into module Memory via fetchAndPutURL(), and two C arguments are generated - index (pointer) to the memory, and length\n    * ArrayBuffer - the array is loaded into module memory via putArrayBuffer\n    */ async callC(params) {\n        const cparams = await this.preCallC(params);\n        let retval = await this.callCImpl(params[0], cparams);\n        await this.postCallC(cparams, params);\n        return retval;\n    }\n    async callCImpl(fname, cparams = []) {\n        if (!this.exports) throw new Error(\"this.exports undefined\");\n        if (!this.exports[fname]) throw new Error(\"callC: function '\" + fname + \"' not in export table.  Use --export wasm-ld flag.\");\n        const f = this.exports[fname];\n        let cr = f(...cparams);\n        return cr;\n    }\n    // convert an array of arguments to numbers by stuffing contents into malloc'd Wasm memory\n    async preCallC(params) {\n        if (!(params.constructor === Array)) throw new Error(\"callC: params must be array, first arg is function name\");\n        if (params.length == 0) throw new Error(\"callC: missing function name\");\n        let cparams = [];\n        let ci = 0;\n        for(let i = 1; i < params.length; i++){\n            const p = params[i];\n            switch(typeof p){\n                case \"number\":\n                case \"bigint\":\n                    cparams[ci++] = p;\n                    break;\n                case \"string\":\n                    cparams[ci++] = await this.putString(p);\n                    break;\n                case \"object\":\n                    if (p instanceof URL) {\n                        const r = await this.fetchAndPutURL(p);\n                        cparams[ci++] = r[0]; // mem index\n                        cparams[ci++] = r[1]; // len\n                        break;\n                    } else if (p instanceof ArrayBuffer) {\n                        const r = await this.putArrayBuffer(p);\n                        cparams[ci++] = r; // mem index\n                        break;\n                    }\n                default:\n                    throw new Error(\"callC: invalid object type passed in\");\n            }\n        }\n        return cparams;\n    }\n    // free the mallocs; copy array buffer data from malloc back to arraybuffer\n    async postCallC(cparams, params) {\n        let ci = 0;\n        for(let i = 1; i < params.length; i++){\n            const p = params[i];\n            switch(typeof p){\n                case \"number\":\n                case \"bigint\":\n                    ci++;\n                    break;\n                case \"string\":\n                    await this.callCImpl(\"free\", [\n                        cparams[ci]\n                    ]);\n                    ci++;\n                    break;\n                case \"object\":\n                    if (p instanceof URL) {\n                        await this.callCImpl(\"free\", [\n                            cparams[ci]\n                        ]);\n                        ci = ci + 2;\n                        break;\n                    } else if (p instanceof ArrayBuffer) {\n                        const u8 = new Uint8Array(p);\n                        const idx = cparams[ci];\n                        for(let j = 0; j < u8.length; j++)u8[j] = this.mem8[idx + j]; // mod.mem8 is a Uint8Array view of the module's WebAssembly Memory\n                        await this.callCImpl(\"free\", [\n                            idx\n                        ]);\n                        ci++;\n                        break;\n                    } else throw new Error(\"postCallC: internal error A\");\n                default:\n                    throw new Error(\"postCallC: internal error B\");\n            }\n        }\n        return cparams;\n    }\n    /*********************************************************************/ /*********************************************************************/ // convert a Javascript string into byte sequence that encodes the string using UTF8, or the requested codePage\n    stringToU8(sin, codePage = (0, $07ff08a59ba75008$export$3d6ef5b62200d8d1)) {\n        let ru8;\n        if (codePage == (0, $07ff08a59ba75008$export$3d6ef5b62200d8d1)) {\n            const encoder = new TextEncoder();\n            ru8 = encoder.encode(sin);\n        } else if (codePage == (0, $07ff08a59ba75008$export$29f202393adbf96)) {\n            ru8 = new Uint8Array(sin.length);\n            for(let i = 0; i < sin.length; i++)ru8[i] = (0, $07ff08a59ba75008$export$8644084c19ac418e)(sin[i]);\n        } else if (codePage == (0, $07ff08a59ba75008$export$53f1026d7d1c23fb)) {\n            ru8 = new Uint8Array(sin.length);\n            for(let i = 0; i < sin.length; i++){\n                const r = (0, $07ff08a59ba75008$export$69111c4ea6e0c4a0)(sin[i]);\n                ru8[i] = r;\n            }\n        } else throw new Error(\"unknown codePage: \" + codePage);\n        return ru8;\n    }\n    // copy a string into existing buffer in the webassembly module memory as utf8 (or specified codePage)\n    // result always null terminated\n    copyString(buffer, buffer_size, sin, codePage = (0, $07ff08a59ba75008$export$3d6ef5b62200d8d1)) {\n        if (buffer_size < 1) throw new Error(\"copyString buffer_size must have length > 0 (room for terminating 0): \" + buffer_size);\n        const ru8 = this.stringToU8(sin, codePage);\n        let i;\n        for(i = 0; i < ru8.length && i < buffer_size - 1; i++)this.mem8[buffer + i] = ru8[i];\n        this.mem8[buffer + i] = 0;\n    }\n    // allocate and copy a string into the webassembly module memory as utf8 (or the specified codePage)\n    async putString(sin, codePage = (0, $07ff08a59ba75008$export$3d6ef5b62200d8d1)) {\n        const ru8 = this.stringToU8(sin, codePage);\n        const strIndex = await this.malloc(ru8.length + 1);\n        this.mem8.set(ru8, strIndex);\n        this.mem8[strIndex + ru8.length] = 0;\n        return strIndex;\n    }\n    // allocate and copy a Uint8Array into Wasm mod memory\n    async putU8(u8a) {\n        let dest = await this.malloc(u8a.length);\n        this.mem8.set(u8a, dest);\n        return dest;\n    }\n    async putArrayBuffer(ab) {\n        const u8 = new Uint8Array(ab);\n        return this.putU8(u8);\n    }\n    // given a url, load its contents, and stuff into Wasm memory similar to Unint8Array\n    async fetchAndPutURL(fnin) {\n        if (!(typeof fnin === \"object\" && fnin instanceof URL)) throw new Error(\"fetchAndPutURL param must be URL\");\n        try {\n            let response = await fetch(fnin);\n            let buffer = await response.arrayBuffer();\n            let src = new Uint8Array(buffer);\n            let dest = await this.putU8(src);\n            return [\n                dest,\n                src.length\n            ];\n        } catch (err) {\n            console.log(\"fetchAndPutURL Error. URL: \" + fnin + \"\\n\" + err + (err.stack ? \"\\n\" + err.stack : \"\"));\n            throw err;\n        }\n    }\n    getLong(idx) {\n        const idx32 = Math.floor(idx / 4);\n        if (idx32 * 4 != idx) throw new Error(\"getLong passed non long aligned address\");\n        if (idx32 < 0 || idx32 >= this.mem32.length) throw new Error(\"invalid index passed to getLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\n        const long = this.mem32[idx32];\n        return long;\n    }\n    setLong(idx, value) {\n        const idx32 = Math.floor(idx / 4);\n        if (idx32 * 4 != idx) throw new Error(\"setLong passed non long aligned address\");\n        if (idx32 < 0 || idx32 >= this.mem32.length - 1) throw new Error(\"invalid index passed to setLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\n        this.mem32[idx32] = value;\n    }\n    getDouble(idx) {\n        const idx64 = Math.floor(idx / 8);\n        if (idx64 * 8 != idx) throw new Error(\"getLong passed non Float64 aligned address\");\n        const long = this.memD[idx64];\n        return long;\n    }\n    setDouble(idx, value) {\n        const idx64 = Math.floor(idx / 8);\n        if (idx64 * 8 != idx) throw new Error(\"setDouble passed non Float64 aligned address\");\n        this.memD[idx64] = value;\n    }\n    getShort(idx) {\n        if (idx < 0 || idx >= this.mem8.length) throw new Error(\"invalid index passed to getShort: \" + idx);\n        const short = this.mem8[idx] + this.mem8[idx + 1] * 256;\n        return short;\n    }\n    // get a string out of module memory\n    // null terminated, up until max of (optional) len bytes\n    // len may be longer than the number of characters, if characters are utf-8 encoded\n    getString(strIndex, len, codePage = (0, $07ff08a59ba75008$export$3d6ef5b62200d8d1)) {\n        if (strIndex < 0 || strIndex >= this.mem8.length) throw new Error(\"invalid strIndex passed to getString: \" + strIndex);\n        if (len) {\n            if (len < 0 || len + strIndex > this.mem8.length) throw new Error(\"invalid len  passed to getString: \" + len);\n        } else {\n            len = this.mem8.indexOf(0, strIndex);\n            if (len == -1) throw new Error(\"string is not null terminated\");\n            len = len - strIndex;\n        }\n        let encodeFormat;\n        if (codePage == (0, $07ff08a59ba75008$export$3d6ef5b62200d8d1)) encodeFormat = \"utf-8\";\n        else if (codePage == (0, $07ff08a59ba75008$export$29f202393adbf96)) encodeFormat = \"windows-1252\";\n        else throw new Error(\"Unsupported codePage: \" + codePage);\n        const td = new TextDecoder(encodeFormat);\n        const u8todecode = new Uint8Array(this.mem8.buffer, strIndex, len);\n        // chrome throws exception when using TextDecoder on SharedArrayBuffer\n        // BUT, instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error, so don't check directly\n        if (this.mem8.buffer instanceof ArrayBuffer) {\n            const sout = td.decode(u8todecode);\n            return sout;\n        } else {\n            const regularArrayBuffer = new ArrayBuffer(len);\n            const regularUint8Array = new Uint8Array(regularArrayBuffer);\n            regularUint8Array.set(u8todecode);\n            const sout = td.decode(regularUint8Array);\n            return sout;\n        }\n    }\n    // get a byte array out of module memory when passed in index to [size, dataptr]\n    getU8Arr(idx) {\n        if (idx < 0 || idx >= this.mem8.length) throw new Error(\"invalid index passed to getU8: \" + idx);\n        const rv = new Uint32Array(this.mem8.slice(idx, idx + 8).buffer);\n        let size = rv[0];\n        let dataptr = rv[1];\n        if (dataptr < 0 || dataptr >= this.mem8.length) throw new Error(\"invalid idx.dataptr passed to getU8\");\n        if (size < 0 || size > this.mem8.length - dataptr) throw new Error(\"invalid idx.size passed to  getU8\");\n        const u8 = this.mem8.slice(dataptr, dataptr + size);\n        return u8;\n    }\n    // get a int32 array out of module memory when passed in index to [size, dataptr]\n    getU32Arr(idx) {\n        if (idx < 0 || idx >= this.mem8.length) throw new Error(\"invalid index passed to getU32: \" + idx);\n        const rv = new Uint32Array(this.mem8.slice(idx, idx + 8).buffer);\n        let size = rv[0];\n        let dataptr = rv[1];\n        if (dataptr < 0 || dataptr >= this.mem8.length) throw new Error(\"invalid idx.dataptr passed to getU32\");\n        if (size < 0 || size > this.mem8.length - dataptr) throw new Error(\"invalid idx.size passed to  getU32\");\n        if (size % 4 != 0) throw new Error(\"idx.size is not an integer number of 32 bit words\");\n        const u32 = new Uint32Array(this.mem8.slice(dataptr, dataptr + size).buffer);\n        return u32;\n    }\n}\n\n\n// return ms since epoch as double\nfunction $25e0032167928e0e$export$a952b8f8c62754b8() {\n    return Date.now();\n}\n\n\n\n//\n// This class implements a circular buffer that the main javascript thread can write to, \n// and a blocking WebWorker thread can read from.  This allows keyboard characters to be transferred from the main JS thread to a WebWorker thread.\n// The WebWorker can use the readWait() function to sleep, w/o participating in the normal \n// async callback dispatch method.  This allows a C program that is a single blocking loop to receive input from the primary javascript thread.\n// readWait() is used used when io_getc32() or io_mbgetstr() is called from a C function.\n//\nconst $997394d69310721e$var$RDIDX = 256;\nconst $997394d69310721e$var$WRIDX = 257;\nconst $997394d69310721e$var$LEN = 256;\nclass $997394d69310721e$export$a01cca24f011573a {\n    sharedArray;\n    buf;\n    constructor(sa){\n        if (typeof window !== \"undefined\") {\n            if (!crossOriginIsolated && !(window.location.protocol === \"file:\")) throw new Error(\"twrSharedCircularBuffer constructor, crossOriginIsolated=\" + crossOriginIsolated + \". See SharedArrayBuffer docs.\");\n        }\n        if (sa) this.sharedArray = sa;\n        else this.sharedArray = new SharedArrayBuffer(1032);\n        this.buf = new Int32Array(this.sharedArray);\n        this.buf[$997394d69310721e$var$RDIDX] = 0;\n        this.buf[$997394d69310721e$var$WRIDX] = 0;\n    }\n    write(n) {\n        let i = this.buf[$997394d69310721e$var$WRIDX];\n        this.buf[i] = n;\n        i++;\n        if (i == $997394d69310721e$var$LEN) i = 0;\n        this.buf[$997394d69310721e$var$WRIDX] = i;\n        Atomics.notify(this.buf, $997394d69310721e$var$WRIDX);\n    }\n    read() {\n        if (!this.isEmpty()) {\n            let i = this.buf[$997394d69310721e$var$RDIDX];\n            let n = this.buf[i];\n            i++;\n            this.buf[$997394d69310721e$var$RDIDX] = i;\n            return n;\n        } else return -1;\n    }\n    readWait() {\n        if (this.isEmpty()) {\n            const rdptr = this.buf[$997394d69310721e$var$RDIDX];\n            // verifies that a shared memory location still contains a given value and if so sleeps until notified.\n            Atomics.wait(this.buf, $997394d69310721e$var$WRIDX, rdptr);\n        }\n        return this.read();\n    }\n    isEmpty() {\n        return this.buf[$997394d69310721e$var$RDIDX] == this.buf[$997394d69310721e$var$WRIDX];\n    }\n}\n\n\n\n//TODO:\n//\tstruct IoDisplay: need to add a setc32 equiv for back/fore color\n// add io_get_type\n// i can't figure out how to have this param be a keyof instead of string, with separate params for Stream and Terminal:  getProp: (propName: string)=>number;\n// change printf, and other optimizations if they exist, to call io_putstr\n// implement or deprecate io_begin_draw \n// get rid of IoConsoleWindow, and just use IoConsole for everything?\n// add a typedef for struct IoConsole\n// remove from IModParams: imports:{[index:string]:Function},\n// implement \t//\tIModOpts.imports in twrWasmModuleInJSMain\n// add ability to determine if a console has the input focus\n// remove support for io:{[key:string]: IConsole};\n// add codepage as arg to charout.io_putc to make it more flexible and to align with how setc32 works in io_functions\n// add ability to set a max size for a div con, or to trim it.\n// add helloworld-b to index.html?\n// finish inkey\n// add io_setrange example/test case\n// get rid of this.io and just use ioIDtoNames?\n// must match IO_TYPEs in twr_io.h\nclass $99d2301965139f24$export$5d8b86200307417d {\n    static CHARREAD = 1;\n    static CHARWRITE = 2;\n    static ADDRESSABLE_DISPLAY = 4;\n    static CANVAS2D = 8;\n    static EVENTS = 16;\n    // Private constructor to prevent instantiation\n    constructor(){}\n}\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\nfunction $99d2301965139f24$var$keyEventProcess(ev) {\n    if (!ev.isComposing && !ev.metaKey && ev.key != \"Control\" && ev.key != \"Alt\") {\n        //console.log(\"keyDownDiv: \",ev.key, ev.code, ev.key.codePointAt(0), ev);\n        if (ev.key.length == 1) return ev.key.codePointAt(0);\n        else {\n            switch(ev.key){\n                case \"Backspace\":\n                    return 8;\n                case \"Enter\":\n                    return 10;\n                case \"Escape\":\n                    return 0x1B;\n                case \"Delete\":\n                    return 0x7F;\n                case \"ArrowLeft\":\n                    return 0x2190;\n                case \"ArrowUp\":\n                    return 0x2191;\n                case \"ArrowRight\":\n                    return 0x2192;\n                case \"ArrowDown\":\n                    return 0x2193;\n            }\n            console.log(\"keyEventProcess SKIPPED: \", ev.key, ev.code, ev.key.codePointAt(0), ev);\n        }\n    } else console.log(\"keyEventProcess SKIPPED-2: \", ev.key, ev.code, ev.key.codePointAt(0), ev);\n    return undefined;\n}\nfunction $99d2301965139f24$export$d081dc64f99d208b(destinationCon, ev) {\n    if (!destinationCon.keys) throw new Error(\"keyDown requires twrModuleAsync\");\n    else {\n        const r = $99d2301965139f24$var$keyEventProcess(ev);\n        if (r) destinationCon.keys.write(r);\n    }\n}\n\n\n// this is global in the JS main thread address space\n// all consoles are registered here\nclass $6a274cb2c782baea$export$401f32ea04a2dc08 {\n    static consoles = [];\n    // create a pairing between an instance of type IConsole and an integer ID\n    static registerConsole(con) {\n        $6a274cb2c782baea$export$401f32ea04a2dc08.consoles.push(con);\n        return $6a274cb2c782baea$export$401f32ea04a2dc08.consoles.length - 1;\n    }\n    static getConsole(id) {\n        if (id < 0 || id >= $6a274cb2c782baea$export$401f32ea04a2dc08.consoles.length) throw new Error(\"Invalid console ID: \" + id);\n        return $6a274cb2c782baea$export$401f32ea04a2dc08.consoles[id];\n    }\n    static getConsoleID(con) {\n        for(let i = 0; i < $6a274cb2c782baea$export$401f32ea04a2dc08.consoles.length; i++)if ($6a274cb2c782baea$export$401f32ea04a2dc08.consoles[i] == con) return i;\n        throw new Error(\"IConsole not in registry\");\n    }\n}\nclass $6a274cb2c782baea$export$c966f466478010bf {\n    static consoles = [];\n    // create a pairing between an instance of type IConsole and an integer ID\n    static registerConsoleProxy(con) {\n        $6a274cb2c782baea$export$c966f466478010bf.consoles[con.id] = con;\n        return con.id;\n    }\n    static getConsoleProxy(id) {\n        if (id < 0 || id >= $6a274cb2c782baea$export$c966f466478010bf.consoles.length) throw new Error(\"Invalid console ID: \" + id);\n        return $6a274cb2c782baea$export$c966f466478010bf.consoles[id];\n    }\n    static getConsoleID(con) {\n        for(let i = 0; i < $6a274cb2c782baea$export$c966f466478010bf.consoles.length; i++)if ($6a274cb2c782baea$export$c966f466478010bf.consoles[i] == con) return i;\n        throw new Error(\"IConsoleProxy not in registry\");\n    }\n}\n\n\nclass $c484b2e8c67a7340$export$b0aa7e35767ef6cf {\n    element;\n    id;\n    keys;\n    CURSOR = String.fromCharCode(9611);\n    cursorOn = false;\n    lastChar = 0;\n    extraBR = false;\n    cpTranslate;\n    constructor(element, params){\n        this.element = element;\n        if (params) {\n            if (params.backColor) this.element.style.backgroundColor = params.backColor;\n            if (params.foreColor) this.element.style.color = params.foreColor;\n            if (params.fontSize) this.element.style.font = params.fontSize.toString() + \"px arial\";\n        }\n        this.cpTranslate = new (0, $07ff08a59ba75008$export$c7de3f2686797480)();\n        this.id = (0, $6a274cb2c782baea$export$401f32ea04a2dc08).registerConsole(this);\n    }\n    isHtmlEntityAtEnd(str) {\n        const entityPattern = /&[^;]+;$/;\n        return entityPattern.test(str);\n    }\n    removeHtmlEntityAtEnd(str) {\n        const entityPattern = /&[^;]+;$/;\n        return str.replace(entityPattern, \"\");\n    }\n    /*\n     * add utf-8 or windows-1252 character to div.  Supports the following control codes:\n     * any of CRLF, CR (/r), or LF(/n)  will cause a new line\n     * 0x8 backspace\n     * 0xE cursor on\n     * 0xF cursor off\n    */ charOut(ch, codePage) {\n        if (!this.element) throw new Error(\"internal error\");\n        //console.log(\"div::charout: \", ch, codePage);\n        if (this.extraBR) {\n            this.extraBR = false;\n            if (this.cursorOn) this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n            this.element.innerHTML = this.element.innerHTML.slice(0, -4);\n            if (this.cursorOn) this.element.innerHTML += this.CURSOR;\n        }\n        const chnum = this.cpTranslate.convert(ch, codePage);\n        if (chnum != 0) {\n            switch(chnum){\n                case 10:\n                case 13:\n                    if (ch == 10 && this.lastChar == 13) break; // detect CR LF and treat as single new line\n                    if (this.cursorOn) this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    this.element.innerHTML += \"<br><br>\"; //2nd break is a place holder for next line (fixes scroll issue at bottom)\n                    this.extraBR = true;\n                    if (this.cursorOn) this.element.innerHTML += this.CURSOR;\n                    //element.scrollIntoView();\n                    //element.scrollTop = element.scrollHeight;\n                    let p = this.element.getBoundingClientRect();\n                    window.scrollTo(0, p.height + 100);\n                    break;\n                case 8:\n                    if (this.cursorOn) this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    if (this.isHtmlEntityAtEnd(this.element.innerHTML)) this.element.innerHTML = this.removeHtmlEntityAtEnd(this.element.innerHTML);\n                    else this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    if (this.cursorOn) this.element.innerHTML += this.CURSOR;\n                    break;\n                case 0xE:\n                    if (!this.cursorOn) {\n                        this.cursorOn = true;\n                        this.element.innerHTML += this.CURSOR;\n                        this.element.focus();\n                    }\n                    break;\n                case 0xF:\n                    if (this.cursorOn) {\n                        this.cursorOn = false;\n                        this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    }\n                    break;\n                default:\n                    if (this.cursorOn) this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    let newchr = String.fromCodePoint(chnum);\n                    // in html, multiple spaces will be collapsed into one space.  This prevents that behavior.\n                    if (newchr == \" \") newchr = \"&nbsp;\";\n                    this.element.innerHTML += newchr;\n                    if (this.cursorOn) this.element.innerHTML += this.CURSOR;\n                    break;\n            }\n            this.lastChar = chnum;\n        }\n    }\n    getProp(propName) {\n        if (propName === \"type\") return (0, $99d2301965139f24$export$5d8b86200307417d).CHARWRITE | (0, $99d2301965139f24$export$5d8b86200307417d).CHARREAD;\n        console.log(\"twrConsoleDiv.getProp passed unknown property name: \", propName);\n        return 0;\n    }\n    getProxyParams() {\n        this.keys = new (0, $997394d69310721e$export$a01cca24f011573a)(); // tsconfig, lib must be set to 2017 or higher\n        return [\n            \"twrConsoleDivProxy\",\n            this.id,\n            this.keys.sharedArray\n        ];\n    }\n    keyDown(ev) {\n        (0, $99d2301965139f24$export$d081dc64f99d208b)(this, ev);\n    }\n    processMessage(msgType, data) {\n        const [id, ...params] = data;\n        if (id != this.id) throw new Error(\"internal error\"); // should never happen\n        switch(msgType){\n            case \"div-charout\":\n                {\n                    const [ch, codePage] = params;\n                    this.charOut(ch, codePage);\n                }\n                break;\n            case \"div-putstr\":\n                {\n                    const [str] = params;\n                    this.putStr(str);\n                }\n                break;\n            case \"div-focus\":\n                this.element.focus();\n                break;\n            default:\n                return false;\n        }\n        return true;\n    }\n    putStr(str) {\n        for(let i = 0; i < str.length; i++)this.charOut(str.codePointAt(i) || 0, (0, $07ff08a59ba75008$export$ddea6250b326d061));\n    }\n}\nclass $c484b2e8c67a7340$export$e4a97cb991521e57 {\n    keys;\n    id;\n    constructor(params){\n        const [className, id, keysBuffer] = params;\n        this.keys = new (0, $997394d69310721e$export$a01cca24f011573a)(keysBuffer);\n        this.id = id;\n    }\n    charIn() {\n        return this.keys.readWait(); // wait for a key, then read it\n    }\n    inkey() {\n        if (this.keys.isEmpty()) return 0;\n        else return this.charIn();\n    }\n    charOut(ch, codePoint) {\n        postMessage([\n            \"div-charout\",\n            [\n                this.id,\n                ch,\n                codePoint\n            ]\n        ]);\n    }\n    putStr(str) {\n        postMessage([\n            \"div-putstr\",\n            [\n                this.id,\n                str\n            ]\n        ]);\n    }\n    getProp(propName) {\n        if (propName === \"type\") return (0, $99d2301965139f24$export$5d8b86200307417d).CHARWRITE | (0, $99d2301965139f24$export$5d8b86200307417d).CHARREAD;\n        console.log(\"twrConsoleDivProxy.getProp passed unknown property name: \", propName);\n        return 0;\n    }\n    setFocus() {\n        postMessage([\n            \"div-focus\",\n            [\n                this.id\n            ]\n        ]);\n    }\n}\n\n\n//\n// This class implements a simple signal/wait mechanism\n// It is used by the WebWorker thread to block/wait, and the main JS thread to signal when to unblock\n//\nvar $d97fe2e0130c8ea6$var$twrSignalState;\n(function(twrSignalState) {\n    twrSignalState[twrSignalState[\"WAITING\"] = 0] = \"WAITING\";\n    twrSignalState[twrSignalState[\"SIGNALED\"] = 1] = \"SIGNALED\";\n})($d97fe2e0130c8ea6$var$twrSignalState || ($d97fe2e0130c8ea6$var$twrSignalState = {}));\nclass $d97fe2e0130c8ea6$export$e37a7b7b851b97f3 {\n    sharedArray;\n    buf;\n    constructor(sa){\n        if (typeof window !== \"undefined\") {\n            if (!crossOriginIsolated && !(window.location.protocol === \"file:\")) throw new Error(\"twrSignal constructor, crossOriginIsolated=\" + crossOriginIsolated + \". See SharedArrayBuffer docs.\");\n        }\n        if (sa) this.sharedArray = sa;\n        else this.sharedArray = new SharedArrayBuffer(4);\n        this.buf = new Int32Array(this.sharedArray);\n        this.buf[0] = $d97fe2e0130c8ea6$var$twrSignalState.WAITING;\n    }\n    signal() {\n        this.buf[0] = $d97fe2e0130c8ea6$var$twrSignalState.SIGNALED;\n        //console.log(\"about to signal\");\n        Atomics.notify(this.buf, 0);\n    }\n    wait() {\n        if (this.buf[0] == $d97fe2e0130c8ea6$var$twrSignalState.WAITING) //console.log(\"waiting...\");\n        Atomics.wait(this.buf, 0, $d97fe2e0130c8ea6$var$twrSignalState.WAITING);\n    }\n    isSignaled() {\n        return this.buf[0] == $d97fe2e0130c8ea6$var$twrSignalState.SIGNALED;\n    }\n    reset() {\n        this.buf[0] = $d97fe2e0130c8ea6$var$twrSignalState.WAITING;\n    }\n}\n\n\nclass $7c86b727c15072df$export$9e37856d1928d388 {\n    callCompleteSignal;\n    parameters;\n    constructor(){\n        this.callCompleteSignal = new (0, $d97fe2e0130c8ea6$export$e37a7b7b851b97f3)();\n        this.parameters = new Uint32Array(new SharedArrayBuffer(4));\n    }\n    startSleep(ms) {\n        setTimeout(()=>{\n            this.callCompleteSignal.signal();\n        }, ms);\n    }\n    getProxyParams() {\n        return [\n            this.callCompleteSignal.sharedArray,\n            this.parameters.buffer\n        ];\n    }\n    processMessage(msgType, data) {\n        switch(msgType){\n            case \"sleep\":\n                const [ms] = data;\n                this.startSleep(ms);\n                break;\n            default:\n                return false;\n        }\n        return true;\n    }\n}\nclass $7c86b727c15072df$export$78d2a4633fe89379 {\n    callCompleteSignal;\n    parameters;\n    constructor(params){\n        this.callCompleteSignal = new (0, $d97fe2e0130c8ea6$export$e37a7b7b851b97f3)(params[0]);\n        this.parameters = new Uint32Array(params[1]);\n    }\n    sleep(ms) {\n        this.callCompleteSignal.reset();\n        postMessage([\n            \"sleep\",\n            [\n                ms\n            ]\n        ]);\n        this.callCompleteSignal.wait();\n    }\n}\n\n\n\n\n\n\nvar $496ef95f52233740$var$D2DType;\n(function(D2DType) {\n    D2DType[D2DType[\"D2D_FILLRECT\"] = 1] = \"D2D_FILLRECT\";\n    D2DType[D2DType[\"D2D_FILLCODEPOINT\"] = 5] = \"D2D_FILLCODEPOINT\";\n    D2DType[D2DType[\"D2D_SETLINEWIDTH\"] = 10] = \"D2D_SETLINEWIDTH\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLERGBA\"] = 11] = \"D2D_SETFILLSTYLERGBA\";\n    D2DType[D2DType[\"D2D_SETFONT\"] = 12] = \"D2D_SETFONT\";\n    D2DType[D2DType[\"D2D_BEGINPATH\"] = 13] = \"D2D_BEGINPATH\";\n    D2DType[D2DType[\"D2D_MOVETO\"] = 14] = \"D2D_MOVETO\";\n    D2DType[D2DType[\"D2D_LINETO\"] = 15] = \"D2D_LINETO\";\n    D2DType[D2DType[\"D2D_FILL\"] = 16] = \"D2D_FILL\";\n    D2DType[D2DType[\"D2D_STROKE\"] = 17] = \"D2D_STROKE\";\n    D2DType[D2DType[\"D2D_SETSTROKESTYLERGBA\"] = 18] = \"D2D_SETSTROKESTYLERGBA\";\n    D2DType[D2DType[\"D2D_ARC\"] = 19] = \"D2D_ARC\";\n    D2DType[D2DType[\"D2D_STROKERECT\"] = 20] = \"D2D_STROKERECT\";\n    D2DType[D2DType[\"D2D_FILLTEXT\"] = 21] = \"D2D_FILLTEXT\";\n    D2DType[D2DType[\"D2D_IMAGEDATA\"] = 22] = \"D2D_IMAGEDATA\";\n    D2DType[D2DType[\"D2D_PUTIMAGEDATA\"] = 23] = \"D2D_PUTIMAGEDATA\";\n    D2DType[D2DType[\"D2D_BEZIERTO\"] = 24] = \"D2D_BEZIERTO\";\n    D2DType[D2DType[\"D2D_MEASURETEXT\"] = 25] = \"D2D_MEASURETEXT\";\n    D2DType[D2DType[\"D2D_SAVE\"] = 26] = \"D2D_SAVE\";\n    D2DType[D2DType[\"D2D_RESTORE\"] = 27] = \"D2D_RESTORE\";\n    D2DType[D2DType[\"D2D_CREATERADIALGRADIENT\"] = 28] = \"D2D_CREATERADIALGRADIENT\";\n    D2DType[D2DType[\"D2D_SETCOLORSTOP\"] = 29] = \"D2D_SETCOLORSTOP\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLEGRADIENT\"] = 30] = \"D2D_SETFILLSTYLEGRADIENT\";\n    D2DType[D2DType[\"D2D_RELEASEID\"] = 31] = \"D2D_RELEASEID\";\n    D2DType[D2DType[\"D2D_CREATELINEARGRADIENT\"] = 32] = \"D2D_CREATELINEARGRADIENT\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLE\"] = 33] = \"D2D_SETFILLSTYLE\";\n    D2DType[D2DType[\"D2D_SETSTROKESTYLE\"] = 34] = \"D2D_SETSTROKESTYLE\";\n    D2DType[D2DType[\"D2D_CLOSEPATH\"] = 35] = \"D2D_CLOSEPATH\";\n    D2DType[D2DType[\"D2D_RESET\"] = 36] = \"D2D_RESET\";\n    D2DType[D2DType[\"D2D_CLEARRECT\"] = 37] = \"D2D_CLEARRECT\";\n    D2DType[D2DType[\"D2D_SCALE\"] = 38] = \"D2D_SCALE\";\n    D2DType[D2DType[\"D2D_TRANSLATE\"] = 39] = \"D2D_TRANSLATE\";\n    D2DType[D2DType[\"D2D_ROTATE\"] = 40] = \"D2D_ROTATE\";\n    D2DType[D2DType[\"D2D_GETTRANSFORM\"] = 41] = \"D2D_GETTRANSFORM\";\n    D2DType[D2DType[\"D2D_SETTRANSFORM\"] = 42] = \"D2D_SETTRANSFORM\";\n    D2DType[D2DType[\"D2D_RESETTRANSFORM\"] = 43] = \"D2D_RESETTRANSFORM\";\n    D2DType[D2DType[\"D2D_STROKETEXT\"] = 44] = \"D2D_STROKETEXT\";\n    D2DType[D2DType[\"D2D_ROUNDRECT\"] = 45] = \"D2D_ROUNDRECT\";\n    D2DType[D2DType[\"D2D_ELLIPSE\"] = 46] = \"D2D_ELLIPSE\";\n    D2DType[D2DType[\"D2D_QUADRATICCURVETO\"] = 47] = \"D2D_QUADRATICCURVETO\";\n    D2DType[D2DType[\"D2D_SETLINEDASH\"] = 48] = \"D2D_SETLINEDASH\";\n    D2DType[D2DType[\"D2D_GETLINEDASH\"] = 49] = \"D2D_GETLINEDASH\";\n    D2DType[D2DType[\"D2D_ARCTO\"] = 50] = \"D2D_ARCTO\";\n    D2DType[D2DType[\"D2D_GETLINEDASHLENGTH\"] = 51] = \"D2D_GETLINEDASHLENGTH\";\n})($496ef95f52233740$var$D2DType || ($496ef95f52233740$var$D2DType = {}));\nclass $496ef95f52233740$export$e1daeed5216ed90a {\n    ctx;\n    id;\n    element;\n    props;\n    cmdCompleteSignal;\n    canvasKeys;\n    isAsyncMod;\n    precomputedObjects;\n    constructor(element){\n        this.isAsyncMod = false; // set to true if getProxyParams called\n        this.precomputedObjects = {};\n        if (!element.getContext) throw new Error(\"attempted to create new twrCanvas with an element that is not a valid HTMLCanvasElement\");\n        this.element = element;\n        const c = element.getContext(\"2d\");\n        if (!c) throw new Error(\"canvas 2D context not found in twrCanvasConstructor\");\n        this.ctx = c;\n        // these two lines are for backwards compatibility with prior version of twr-wasm\n        c.font = \"16 px Courier New\";\n        c.textBaseline = \"top\";\n        this.props = {\n            canvasHeight: element.height,\n            canvasWidth: element.width,\n            type: (0, $99d2301965139f24$export$5d8b86200307417d).CANVAS2D\n        };\n        this.id = (0, $6a274cb2c782baea$export$401f32ea04a2dc08).registerConsole(this);\n    }\n    // these are the parameters needed to create a twrConsoleCanvasProxy, paired to us\n    getProxyParams() {\n        this.cmdCompleteSignal = new (0, $d97fe2e0130c8ea6$export$e37a7b7b851b97f3)();\n        this.canvasKeys = new (0, $997394d69310721e$export$a01cca24f011573a)(); // tsconfig, lib must be set to 2017 or higher\n        this.isAsyncMod = true;\n        return [\n            \"twrConsoleCanvasProxy\",\n            this.id,\n            this.props,\n            this.cmdCompleteSignal.sharedArray,\n            this.canvasKeys.sharedArray\n        ];\n    }\n    getProp(name) {\n        return this.props[name];\n    }\n    // process messages sent from twrConsoleCanvasProxy\n    // these are used to \"remote procedure call\" from the worker thread to the JS Main thread\n    processMessage(msgType, data, callingModule) {\n        const [id, ...params] = data;\n        if (id != this.id) throw new Error(\"internal error\"); // should never happen\n        switch(msgType){\n            case \"canvas2d-drawseq\":\n                {\n                    const [ds] = params;\n                    this.drawSeq(ds, callingModule);\n                    break;\n                }\n            default:\n                return false;\n        }\n        return true;\n    }\n    /* see draw2d.h for structs that match */ drawSeq(ds, owner) {\n        //console.log(\"twr::Canvas enter drawSeq\");\n        if (!this.ctx) return;\n        const insHdrSize = 16;\n        let currentInsHdr = owner.getLong(ds); /* ds->start */ \n        const lastInsHdr = owner.getLong(ds + 4); /* ds->last */ \n        let currentInsParams = currentInsHdr + insHdrSize;\n        //console.log(\"instruction start, last \",ins.toString(16), lastins.toString(16));\n        let nextInsHdr;\n        //let insCount=0;\n        while(true){\n            //insCount++;\n            const type = owner.getLong(currentInsHdr + 4); /* hdr->type */ \n            switch(type){\n                case $496ef95f52233740$var$D2DType.D2D_FILLRECT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const w = owner.getDouble(currentInsParams + 16);\n                        const h = owner.getDouble(currentInsParams + 24);\n                        this.ctx.fillRect(x, y, w, h);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_STROKERECT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const w = owner.getDouble(currentInsParams + 16);\n                        const h = owner.getDouble(currentInsParams + 24);\n                        this.ctx.strokeRect(x, y, w, h);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_FILLCODEPOINT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const c = owner.getLong(currentInsParams + 16);\n                        let txt = String.fromCodePoint(c);\n                        this.ctx.fillText(txt, x, y);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_FILLTEXT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const codePage = owner.getLong(currentInsParams + 20);\n                        const strPointer = owner.getLong(currentInsParams + 16);\n                        const str = owner.getString(strPointer, undefined, codePage);\n                        //console.log(\"filltext \",x,y,str)\n                        this.ctx.fillText(str, x, y);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_MEASURETEXT:\n                    {\n                        const codePage = owner.getLong(currentInsParams + 8);\n                        const str = owner.getString(owner.getLong(currentInsParams), undefined, codePage);\n                        const tmidx = owner.getLong(currentInsParams + 4);\n                        const tm = this.ctx.measureText(str);\n                        owner.setDouble(tmidx + 0, tm.actualBoundingBoxAscent);\n                        owner.setDouble(tmidx + 8, tm.actualBoundingBoxDescent);\n                        owner.setDouble(tmidx + 16, tm.actualBoundingBoxLeft);\n                        owner.setDouble(tmidx + 24, tm.actualBoundingBoxRight);\n                        owner.setDouble(tmidx + 32, tm.fontBoundingBoxAscent);\n                        owner.setDouble(tmidx + 40, tm.fontBoundingBoxDescent);\n                        owner.setDouble(tmidx + 48, tm.width);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_SETFONT:\n                    {\n                        const fontPointer = owner.getLong(currentInsParams);\n                        const str = owner.getString(fontPointer);\n                        this.ctx.font = str;\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_SETFILLSTYLERGBA:\n                    {\n                        const color = owner.getLong(currentInsParams);\n                        const cssColor = \"#\" + (\"00000000\" + color.toString(16)).slice(-8);\n                        this.ctx.fillStyle = cssColor;\n                    //console.log(\"fillstyle: \", this.ctx.fillStyle, \":\", cssColor,\":\", color)\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_SETSTROKESTYLERGBA:\n                    {\n                        const color = owner.getLong(currentInsParams);\n                        const cssColor = \"#\" + (\"00000000\" + color.toString(16)).slice(-8);\n                        this.ctx.strokeStyle = cssColor;\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_SETFILLSTYLE:\n                    {\n                        const cssColorPointer = owner.getLong(currentInsParams);\n                        const cssColor = owner.getString(cssColorPointer);\n                        this.ctx.fillStyle = cssColor;\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_SETSTROKESTYLE:\n                    {\n                        const cssColorPointer = owner.getLong(currentInsParams);\n                        const cssColor = owner.getString(cssColorPointer);\n                        this.ctx.strokeStyle = cssColor;\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_SETLINEWIDTH:\n                    {\n                        const width = owner.getDouble(currentInsParams);\n                        this.ctx.lineWidth = width;\n                    //console.log(\"twrCanvas D2D_SETLINEWIDTH: \", this.ctx.lineWidth);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_MOVETO:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        this.ctx.moveTo(x, y);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_LINETO:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        this.ctx.lineTo(x, y);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_BEZIERTO:\n                    {\n                        const cp1x = owner.getDouble(currentInsParams);\n                        const cp1y = owner.getDouble(currentInsParams + 8);\n                        const cp2x = owner.getDouble(currentInsParams + 16);\n                        const cp2y = owner.getDouble(currentInsParams + 24);\n                        const x = owner.getDouble(currentInsParams + 32);\n                        const y = owner.getDouble(currentInsParams + 40);\n                        this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_BEGINPATH:\n                    this.ctx.beginPath();\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_FILL:\n                    this.ctx.fill();\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_SAVE:\n                    this.ctx.save();\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_RESTORE:\n                    this.ctx.restore();\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_STROKE:\n                    this.ctx.stroke();\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_ARC:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const radius = owner.getDouble(currentInsParams + 16);\n                        const startAngle = owner.getDouble(currentInsParams + 24);\n                        const endAngle = owner.getDouble(currentInsParams + 32);\n                        const counterClockwise = owner.getLong(currentInsParams + 40) != 0;\n                        this.ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_IMAGEDATA:\n                    {\n                        const start = owner.getLong(currentInsParams);\n                        const length = owner.getLong(currentInsParams + 4);\n                        const width = owner.getLong(currentInsParams + 8);\n                        const height = owner.getLong(currentInsParams + 12);\n                        const id = owner.getLong(currentInsParams + 16);\n                        if (id in this.precomputedObjects) console.log(\"warning: D2D_IMAGEDATA ID already exists.\");\n                        if (this.isAsyncMod) this.precomputedObjects[id] = {\n                            mem8: new Uint8Array(owner.memory.buffer, start, length),\n                            width: width,\n                            height: height\n                        };\n                        else {\n                            const z = new Uint8ClampedArray(owner.memory.buffer, start, length);\n                            this.precomputedObjects[id] = new ImageData(z, width, height);\n                        }\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_CREATERADIALGRADIENT:\n                    {\n                        const x0 = owner.getDouble(currentInsParams);\n                        const y0 = owner.getDouble(currentInsParams + 8);\n                        const radius0 = owner.getDouble(currentInsParams + 16);\n                        const x1 = owner.getDouble(currentInsParams + 24);\n                        const y1 = owner.getDouble(currentInsParams + 32);\n                        const radius1 = owner.getDouble(currentInsParams + 40);\n                        const id = owner.getLong(currentInsParams + 48);\n                        let gradient = this.ctx.createRadialGradient(x0, y0, radius0, x1, y1, radius1);\n                        if (id in this.precomputedObjects) console.log(\"warning: D2D_CREATERADIALGRADIENT ID already exists.\");\n                        this.precomputedObjects[id] = gradient;\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_CREATELINEARGRADIENT:\n                    {\n                        const x0 = owner.getDouble(currentInsParams);\n                        const y0 = owner.getDouble(currentInsParams + 8);\n                        const x1 = owner.getDouble(currentInsParams + 16);\n                        const y1 = owner.getDouble(currentInsParams + 24);\n                        const id = owner.getLong(currentInsParams + 32);\n                        let gradient = this.ctx.createLinearGradient(x0, y0, x1, y1);\n                        if (id in this.precomputedObjects) console.log(\"warning: D2D_CREATELINEARGRADIENT ID already exists.\");\n                        this.precomputedObjects[id] = gradient;\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_SETCOLORSTOP:\n                    {\n                        const id = owner.getLong(currentInsParams);\n                        const pos = owner.getLong(currentInsParams + 4);\n                        const cssColorPointer = owner.getLong(currentInsParams + 8);\n                        const cssColor = owner.getString(cssColorPointer);\n                        if (!(id in this.precomputedObjects)) throw new Error(\"D2D_SETCOLORSTOP with invalid ID: \" + id);\n                        const gradient = this.precomputedObjects[id];\n                        gradient.addColorStop(pos, cssColor);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_SETFILLSTYLEGRADIENT:\n                    {\n                        const id = owner.getLong(currentInsParams);\n                        if (!(id in this.precomputedObjects)) throw new Error(\"D2D_SETFILLSTYLEGRADIENT with invalid ID: \" + id);\n                        const gradient = this.precomputedObjects[id];\n                        this.ctx.fillStyle = gradient;\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_RELEASEID:\n                    {\n                        const id = owner.getLong(currentInsParams);\n                        if (this.precomputedObjects[id]) delete this.precomputedObjects[id];\n                        else console.log(\"warning: D2D_RELEASEID with undefined ID \", id);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_PUTIMAGEDATA:\n                    {\n                        const id = owner.getLong(currentInsParams);\n                        const dx = owner.getLong(currentInsParams + 4);\n                        const dy = owner.getLong(currentInsParams + 8);\n                        const dirtyX = owner.getLong(currentInsParams + 12);\n                        const dirtyY = owner.getLong(currentInsParams + 16);\n                        const dirtyWidth = owner.getLong(currentInsParams + 20);\n                        const dirtyHeight = owner.getLong(currentInsParams + 24);\n                        if (!(id in this.precomputedObjects)) throw new Error(\"D2D_PUTIMAGEDATA with invalid ID: \" + id);\n                        //console.log(\"D2D_PUTIMAGEDATA\",start, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight, this.imageData[start]);\n                        let imgData;\n                        if (this.isAsyncMod) {\n                            //console.log(\"D2D_PUTIMAGEDATA wasmModuleAsync\");\n                            const z = this.precomputedObjects[id]; // Uint8Array\n                            const ca = Uint8ClampedArray.from(z.mem8); // shallow copy\n                            imgData = new ImageData(ca, z.width, z.height);\n                        } else imgData = this.precomputedObjects[id];\n                        if (dirtyWidth == 0 && dirtyHeight == 0) this.ctx.putImageData(imgData, dx, dy);\n                        else this.ctx.putImageData(imgData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_CLOSEPATH:\n                    this.ctx.closePath();\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_RESET:\n                    this.ctx.reset();\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_CLEARRECT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const w = owner.getDouble(currentInsParams + 16);\n                        const h = owner.getDouble(currentInsParams + 24);\n                        this.ctx.clearRect(x, y, w, h);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_SCALE:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        this.ctx.scale(x, y);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_TRANSLATE:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        this.ctx.translate(x, y);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_ROTATE:\n                    {\n                        const angle = owner.getDouble(currentInsParams);\n                        this.ctx.rotate(angle);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_GETTRANSFORM:\n                    {\n                        const matrix_ptr = owner.getLong(currentInsParams);\n                        const transform = this.ctx.getTransform();\n                        owner.setDouble(matrix_ptr + 0, transform.a);\n                        owner.setDouble(matrix_ptr + 8, transform.b);\n                        owner.setDouble(matrix_ptr + 16, transform.c);\n                        owner.setDouble(matrix_ptr + 24, transform.d);\n                        owner.setDouble(matrix_ptr + 32, transform.e);\n                        owner.setDouble(matrix_ptr + 40, transform.f);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_SETTRANSFORM:\n                    {\n                        const a = owner.getDouble(currentInsParams);\n                        const b = owner.getDouble(currentInsParams + 8);\n                        const c = owner.getDouble(currentInsParams + 16);\n                        const d = owner.getDouble(currentInsParams + 24);\n                        const e = owner.getDouble(currentInsParams + 32);\n                        const f = owner.getDouble(currentInsParams + 40);\n                        this.ctx.setTransform(a, b, c, d, e, f);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_RESETTRANSFORM:\n                    this.ctx.resetTransform();\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_STROKETEXT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const codePage = owner.getLong(currentInsParams + 20);\n                        const strPointer = owner.getLong(currentInsParams + 16);\n                        const str = owner.getString(strPointer, undefined, codePage);\n                        this.ctx.strokeText(str, x, y);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_ROUNDRECT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const width = owner.getDouble(currentInsParams + 16);\n                        const height = owner.getDouble(currentInsParams + 24);\n                        const radii = owner.getDouble(currentInsParams + 32);\n                        this.ctx.roundRect(x, y, width, height, radii);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_ELLIPSE:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const radiusX = owner.getDouble(currentInsParams + 16);\n                        const radiusY = owner.getDouble(currentInsParams + 24);\n                        const rotation = owner.getDouble(currentInsParams + 32);\n                        const startAngle = owner.getDouble(currentInsParams + 40);\n                        const endAngle = owner.getDouble(currentInsParams + 48);\n                        const counterClockwise = owner.getLong(currentInsParams + 56) != 0;\n                        this.ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterClockwise);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_QUADRATICCURVETO:\n                    {\n                        const cpx = owner.getDouble(currentInsParams);\n                        const cpy = owner.getDouble(currentInsParams + 8);\n                        const x = owner.getDouble(currentInsParams + 16);\n                        const y = owner.getDouble(currentInsParams + 24);\n                        this.ctx.quadraticCurveTo(cpx, cpy, x, y);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_SETLINEDASH:\n                    {\n                        const segment_len = owner.getLong(currentInsParams);\n                        const seg_ptr = owner.getLong(currentInsParams + 4);\n                        let segments = [];\n                        for(let i = 0; i < segment_len; i++)segments[i] = owner.getDouble(seg_ptr + i * 8);\n                        this.ctx.setLineDash(segments);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_GETLINEDASH:\n                    {\n                        const segments = this.ctx.getLineDash();\n                        const buffer_length = owner.getLong(currentInsParams);\n                        const buffer_ptr = owner.getLong(currentInsParams + 4);\n                        const segment_length_ptr = currentInsParams + 8;\n                        owner.setLong(segment_length_ptr, segments.length);\n                        if (segments.length > 0) {\n                            for(let i = 0; i < Math.min(segments.length, buffer_length); i++)owner.setDouble(buffer_ptr + i * 8, segments[i]);\n                            if (segments.length > buffer_length) console.log(\"warning: D2D_GETLINEDASH exceeded given max_length, truncating excess\");\n                        }\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_ARCTO:\n                    {\n                        const x1 = owner.getDouble(currentInsParams);\n                        const y1 = owner.getDouble(currentInsParams + 8);\n                        const x2 = owner.getDouble(currentInsParams + 16);\n                        const y2 = owner.getDouble(currentInsParams + 24);\n                        const radius = owner.getDouble(currentInsParams + 32);\n                        this.ctx.arcTo(x1, y1, x2, y2, radius);\n                    }\n                    break;\n                case $496ef95f52233740$var$D2DType.D2D_GETLINEDASHLENGTH:\n                    owner.setLong(currentInsParams, this.ctx.getLineDash().length);\n                    break;\n                default:\n                    throw new Error(\"unimplemented or unknown Sequence Type in drawSeq: \" + type);\n            }\n            nextInsHdr = owner.getLong(currentInsHdr); /* hdr->next */ \n            if (nextInsHdr == 0) {\n                if (currentInsHdr != lastInsHdr) throw new Error(\"assert type error in twrcanvas, ins!=lastins\");\n                break;\n            }\n            currentInsHdr = nextInsHdr;\n            currentInsParams = currentInsHdr + insHdrSize;\n        }\n        if (this.cmdCompleteSignal) this.cmdCompleteSignal.signal();\n    //console.log(\"Canvas.drawSeq() completed  with instruction count of \", insCount);\n    }\n}\nclass $496ef95f52233740$export$97cec2c338f46b48 {\n    canvasKeys;\n    drawCompleteSignal;\n    props;\n    id;\n    constructor(params){\n        const [className, id, props, signalBuffer, canvasKeysBuffer] = params;\n        this.drawCompleteSignal = new (0, $d97fe2e0130c8ea6$export$e37a7b7b851b97f3)(signalBuffer);\n        this.canvasKeys = new (0, $997394d69310721e$export$a01cca24f011573a)(canvasKeysBuffer);\n        this.props = props;\n        this.id = id;\n    //console.log(\"Create New twrCanvasProxy: \",this.props)\n    }\n    charIn() {\n        //ctx.commit(); not avail in chrome\n        //postMessage([\"debug\", 'x']);\n        return this.canvasKeys.readWait(); // wait for a key, then read it\n    }\n    inkey() {\n        if (this.canvasKeys.isEmpty()) return 0;\n        else return this.charIn();\n    }\n    // note that this implementation does not allow a property to change post creation of an instance of this class\n    getProp(propName) {\n        return this.props[propName];\n    }\n    drawSeq(ds) {\n        this.drawCompleteSignal.reset();\n        postMessage([\n            \"canvas2d-drawseq\",\n            [\n                this.id,\n                ds\n            ]\n        ]);\n        this.drawCompleteSignal.wait();\n    }\n}\n\n\n\n\n\nclass $f04c956722c3945f$export$e501d006d4cbf5f7 {\n    logline = \"\";\n    element = undefined;\n    id;\n    cpTranslate;\n    constructor(){\n        this.id = (0, $6a274cb2c782baea$export$401f32ea04a2dc08).registerConsole(this);\n        this.cpTranslate = new (0, $07ff08a59ba75008$export$c7de3f2686797480)();\n    }\n    charOut(ch, codePage) {\n        const char = this.cpTranslate.convert(ch, codePage);\n        if (char == 10 || char == 0x03) {\n            console.log(this.logline); // ideally without a linefeed, but there is no way to not have a LF with console.log API.\n            this.logline = \"\";\n        } else {\n            this.logline = this.logline + String.fromCodePoint(char);\n            if (this.logline.length >= 300) {\n                console.log(this.logline);\n                this.logline = \"\";\n            }\n        }\n    }\n    getProp(propName) {\n        if (propName === \"type\") return (0, $99d2301965139f24$export$5d8b86200307417d).CHARWRITE;\n        console.log(\"twrConsoleDebug.getProp passed unknown property name: \", propName);\n        return 0;\n    }\n    getProxyParams() {\n        return [\n            \"twrConsoleDebugProxy\",\n            this.id\n        ];\n    }\n    keyDown(ev) {\n        throw new Error(\"twrConsoleDebug does not support character input\");\n    }\n    processMessage(msgType, data, callingModule) {\n        const [id, ...params] = data;\n        if (id != this.id) throw new Error(\"internal error\"); // should never happen\n        switch(msgType){\n            case \"debug-charout\":\n                {\n                    const [ch, codePage] = params;\n                    this.charOut(ch, codePage);\n                }\n                break;\n            case \"debug-putstr\":\n                {\n                    const [str] = params;\n                    this.putStr(str);\n                }\n                break;\n            default:\n                return false;\n        }\n        return true;\n    }\n    putStr(str) {\n        for(let i = 0; i < str.length; i++)this.charOut(str.codePointAt(i) || 0, (0, $07ff08a59ba75008$export$ddea6250b326d061));\n    }\n}\nclass $f04c956722c3945f$export$bcb1e5070a093206 {\n    id;\n    constructor(params){\n        this.id = params[1];\n    }\n    charIn() {\n        return 0;\n    }\n    setFocus() {}\n    charOut(ch, codePoint) {\n        postMessage([\n            \"debug-charout\",\n            [\n                this.id,\n                ch,\n                codePoint\n            ]\n        ]);\n    }\n    putStr(str) {\n        postMessage([\n            \"debug-putstr\",\n            [\n                this.id,\n                str\n            ]\n        ]);\n    }\n    getProp(propName) {\n        if (propName === \"type\") return (0, $99d2301965139f24$export$5d8b86200307417d).CHARWRITE;\n        console.log(\"twrConsoleDebugProxy.getProp passed unknown property name: \", propName);\n        return 0;\n    }\n} // ************************************************************************\n // debugLog doesn't currently wait for the message to log, it returns immediately.\n // I could move this to be in the twrWaitingCalls class\n\n\n\n\n\n\nconst $e8e3453ed3aa6b92$var$TRS80_GRAPHIC_MARKER = 0xE000;\nconst $e8e3453ed3aa6b92$var$TRS80_GRAPHIC_MARKER_MASK = 0xFF00;\nconst $e8e3453ed3aa6b92$var$TRS80_GRAPHIC_CHAR_MASK = 0x003F; // would be 0xC0 if we included the graphics marker bit 0x80\nclass $e8e3453ed3aa6b92$export$3217cba298dc07f7 {\n    element;\n    id;\n    ctx;\n    keys;\n    returnValue;\n    props;\n    size;\n    cellWidth;\n    cellHeight;\n    cellW1;\n    cellW2;\n    cellH1;\n    cellH2;\n    cellH3;\n    isCursorVisible;\n    videoMem;\n    foreColorMem;\n    backColorMem;\n    cpTranslate;\n    constructor(canvasElement, params = {}){\n        const { foreColor: foreColor = \"white\", backColor: backColor = \"black\", fontSize: fontSize = 16, widthInChars: widthInChars = 80, heightInChars: heightInChars = 25 } = params;\n        this.element = canvasElement;\n        // canvasElement is where we will draw the terminal\n        if (!canvasElement.getContext) throw new Error(\"canvasElement.getContext invalid\");\n        let c = canvasElement.getContext(\"2d\");\n        if (!c) throw new Error(\"canvasElement.getContext('2d') failed\");\n        c.font = fontSize.toString() + \"px Courier New\";\n        c.textBaseline = \"top\";\n        const sampleText = \"          \";\n        //const sampleText=String.fromCharCode(2593).repeat(6);   // this shaded block is typically full width in a font\n        const tm = c.measureText(sampleText);\n        const charWidth = Math.ceil(tm.width / sampleText.length); // ceil rounds up (eg .9 -> 1)\n        let fM = c.measureText(\"X\");\n        const charHeight = Math.ceil(fM.fontBoundingBoxAscent + fM.fontBoundingBoxDescent);\n        canvasElement.width = charWidth * widthInChars;\n        canvasElement.height = charHeight * heightInChars;\n        const canvasHeight = canvasElement.height;\n        const canvasWidth = canvasElement.width;\n        //console.log(\"this.props.canvasHeight, this.props.canvasWidth\",this.props.canvasHeight,this.props.canvasWidth);\n        // reset after dims changed.  Not sure if ctx is needed to reset, but others do\n        let c2 = canvasElement.getContext(\"2d\");\n        if (!c2) throw new Error(\"canvas 2D context not found in twrCanvas.constructor (2nd time)\");\n        this.ctx = c2;\n        this.ctx.font = fontSize.toString() + \"px Courier New\";\n        this.ctx.textBaseline = \"top\";\n        c2.fillStyle = backColor;\n        const backColorAsRGB = Number(\"0x\" + c2.fillStyle.slice(1));\n        c2.fillStyle = foreColor;\n        const foreColorAsRGB = Number(\"0x\" + c2.fillStyle.slice(1));\n        const cursorPos = 0;\n        const type = (0, $99d2301965139f24$export$5d8b86200307417d).CHARWRITE | (0, $99d2301965139f24$export$5d8b86200307417d).CHARREAD | (0, $99d2301965139f24$export$5d8b86200307417d).ADDRESSABLE_DISPLAY;\n        this.props = {\n            type: type,\n            cursorPos: cursorPos,\n            foreColorAsRGB: foreColorAsRGB,\n            backColorAsRGB: backColorAsRGB,\n            fontSize: fontSize,\n            widthInChars: widthInChars,\n            heightInChars: heightInChars,\n            canvasHeight: canvasHeight,\n            canvasWidth: canvasWidth,\n            charWidth: charWidth,\n            charHeight: charHeight\n        };\n        this.isCursorVisible = false;\n        this.size = this.props.widthInChars * this.props.heightInChars;\n        this.videoMem = new Array(this.size);\n        this.foreColorMem = new Array(this.size);\n        this.backColorMem = new Array(this.size);\n        this.cellWidth = this.props.charWidth;\n        this.cellHeight = this.props.charHeight;\n        if (this.cellWidth <= 0) throw new Error(\"invalid cellWidth\");\n        if (this.cellHeight <= 0) throw new Error(\"invalid cellHeight\");\n        // Calc each cell separately to avoid rounding errors\n        this.cellW1 = Math.floor(this.cellWidth / 2);\n        this.cellW2 = this.cellWidth - this.cellW1;\n        this.cellH1 = Math.floor(this.cellHeight / 3);\n        this.cellH2 = this.cellH1;\n        this.cellH3 = this.cellHeight - this.cellH1 - this.cellH2;\n        this.cls();\n        this.cpTranslate = new (0, $07ff08a59ba75008$export$c7de3f2686797480)();\n        this.id = (0, $6a274cb2c782baea$export$401f32ea04a2dc08).registerConsole(this);\n    }\n    // ProxyParams are used as the constructor options to create the Proxy class as returned by getProxyClassName, \n    // in the twrModAsyncProxy WebWorker thread\n    getProxyParams() {\n        if (this.returnValue || this.keys) throw new Error(\"internal error -- getProxyParams unexpectedly called twice.\");\n        // these are used to communicate with twrConsoleTerminalProxy (if it exists)\n        // tsconfig, lib must be set to 2017 or higher for SharedArrayBuffer usage\n        this.returnValue = new (0, $997394d69310721e$export$a01cca24f011573a)();\n        this.keys = new (0, $997394d69310721e$export$a01cca24f011573a)();\n        return [\n            \"twrConsoleTerminalProxy\",\n            this.id,\n            this.returnValue.sharedArray,\n            this.keys.sharedArray\n        ];\n    }\n    getProp(propName) {\n        return this.props[propName];\n    }\n    keyDown(ev) {\n        (0, $99d2301965139f24$export$d081dc64f99d208b)(this, ev);\n    }\n    // these messages are sent by twrConsoleTerminalProxy to cause functions to execute in the JS Main Thread\n    processMessage(msgType, data) {\n        const [id, ...params] = data;\n        if (id != this.id) throw new Error(\"internal error\"); // should never happen\n        switch(msgType){\n            case \"term-getprop\":\n                const [propName] = params;\n                const propVal = this.getProp(propName);\n                this.returnValue.write(propVal);\n                break;\n            case \"term-point\":\n                {\n                    const [x, y] = params;\n                    const r = this.point(x, y);\n                    this.returnValue.write(r ? 1 : 0); // wait for result, then read it\n                }\n                break;\n            case \"term-charout\":\n                {\n                    const [ch, codePage] = params;\n                    this.charOut(ch, codePage);\n                }\n                break;\n            case \"term-putstr\":\n                {\n                    const [str] = params;\n                    this.putStr(str);\n                }\n                break;\n            case \"term-cls\":\n                this.cls();\n                break;\n            case \"term-setrange\":\n                {\n                    const [start, values] = params;\n                    this.setRange(start, values);\n                }\n                break;\n            case \"term-setc32\":\n                {\n                    const [location, char] = params;\n                    this.setC32(location, char);\n                }\n                break;\n            case \"term-setreset\":\n                {\n                    const [x, y, isset] = params;\n                    this.setReset(x, y, isset);\n                }\n                break;\n            case \"term-setcursor\":\n                {\n                    const [pos] = params;\n                    this.setCursor(pos);\n                }\n                break;\n            case \"term-setcursorxy\":\n                {\n                    const [x, y] = params;\n                    this.setCursorXY(x, y);\n                }\n                break;\n            case \"term-setcolors\":\n                {\n                    const [foreground, background] = params;\n                    this.setColors(foreground, background);\n                }\n                break;\n            case \"term-focus\":\n                this.element.focus();\n                break;\n            default:\n                return false;\n        }\n        return true;\n    }\n    RGB_TO_RGBA(x) {\n        return x << 8 | 0xFF; // JavaScript uses 32-bit signed integers for bitwise operations, which means the leftmost bit is the sign bit. \n    }\n    eraseLine() {\n        for(let i = this.props.cursorPos; i < Math.floor(this.props.cursorPos / this.props.widthInChars) * this.props.widthInChars + this.props.widthInChars; i++)this.setC32(i, 32);\n    }\n    charOut(c, codePage) {\n        if (c == 13 || c == 10) {\n            if (this.isCursorVisible) this.setC32(this.props.cursorPos, 32);\n            this.props.cursorPos = Math.floor(this.props.cursorPos / this.props.widthInChars);\n            this.props.cursorPos = this.props.cursorPos * this.props.widthInChars;\n            this.props.cursorPos = this.props.cursorPos + this.props.widthInChars;\n            /* if return put us on a new line that isn't a scroll, erase the line */ if (this.props.cursorPos < this.size) this.eraseLine();\n        } else if (c == 8) {\n            if (this.props.cursorPos > 0) {\n                if (this.isCursorVisible) this.setC32(this.props.cursorPos, 32);\n                this.props.cursorPos--;\n                this.setC32(this.props.cursorPos, 32);\n            }\n        } else if (c == 0xE) this.isCursorVisible = true;\n        else if (c == 0xF) {\n            this.setC32(this.props.cursorPos, 32);\n            this.isCursorVisible = false;\n        } else if (c == 24) {\n            if (this.props.cursorPos > 0) this.props.cursorPos--;\n        } else if (c == 25) {\n            if (this.props.cursorPos < this.size - 1) this.props.cursorPos++;\n        } else if (c == 26) {\n            if (this.props.cursorPos < this.props.widthInChars * (this.props.heightInChars - 1)) this.props.cursorPos += this.props.widthInChars;\n        } else if (c == 27) {\n            if (this.props.cursorPos >= this.props.widthInChars) this.props.cursorPos -= this.props.widthInChars;\n        } else if (c == 28) this.props.cursorPos = 0;\n        else if (c == 29) this.props.cursorPos = this.props.cursorPos / this.props.widthInChars * this.props.widthInChars;\n        else if (c == 30) this.eraseLine();\n        else if (c == 31) for(let i = this.props.cursorPos; i < this.size; i++)this.setC32(i, 32);\n        else {\n            const c32 = this.cpTranslate.convert(c, codePage);\n            if (c32 != 0) {\n                this.setC32(this.props.cursorPos, c32);\n                this.props.cursorPos++;\n            }\n        }\n        // Do we need to scroll?\n        if (this.props.cursorPos == this.size) {\n            this.props.cursorPos = this.props.widthInChars * (this.props.heightInChars - 1);\n            for(let i = 0; i < this.props.widthInChars * (this.props.heightInChars - 1); i++){\n                this.videoMem[i] = this.videoMem[i + this.props.widthInChars];\n                this.backColorMem[i] = this.backColorMem[i + this.props.widthInChars];\n                this.foreColorMem[i] = this.foreColorMem[i + this.props.widthInChars];\n            }\n            for(let i = 0; i < this.props.widthInChars; i++){\n                this.videoMem[this.size - i - 1] = 32;\n                this.backColorMem[this.size - i - 1] = this.props.backColorAsRGB;\n                this.foreColorMem[this.size - i - 1] = this.props.foreColorAsRGB;\n            }\n            this.drawRange(0, this.size - 1);\n        }\n        if (this.isCursorVisible) this.setC32(this.props.cursorPos, 9611); // 9611 is graphic block -- same cursor i use in class twrDiv\n        if (this.props.cursorPos >= this.size) throw new Error(\"twrTerm: assert: this.props.cursorPos >= this.size\");\n    }\n    //*************************************************\n    putStr(str) {\n        for(let i = 0; i < str.length; i++)this.charOut(str.codePointAt(i) || 0, (0, $07ff08a59ba75008$export$ddea6250b326d061));\n    }\n    //*************************************************\n    setC32(location, c32) {\n        if (!(location >= 0 && location < this.size)) throw new Error(\"Invalid location passed to setc32\");\n        this.videoMem[location] = c32;\n        this.backColorMem[location] = this.props.backColorAsRGB;\n        this.foreColorMem[location] = this.props.foreColorAsRGB;\n        // draw one before and one after to fix any character rendering overlap.  \n        // Can happen with anti-aliasing on graphic chars that fill the cell\n        let start = location - 1;\n        if (start < 0) start = 0;\n        let end = location + 1;\n        if (end >= this.size) end = this.size - 1;\n        this.drawRange(start, end);\n        // draw one line above and below as well to fix any character rendering overlap.  \n        // the block cursor typically can cause an issue\n        const startSave = start;\n        const endSave = end;\n        start = start - this.props.widthInChars;\n        end = end - this.props.widthInChars;\n        if (start < 0) start = 0;\n        if (end < 0) end = 0;\n        this.drawRange(start, end);\n        start = startSave + this.props.widthInChars;\n        end = endSave + this.props.widthInChars;\n        if (start >= this.size) start = this.size - 1;\n        if (end >= this.size) end = this.size - 1;\n        this.drawRange(start, end);\n    }\n    //*************************************************\n    cls() {\n        for(let i = 0; i < this.size; i++){\n            this.videoMem[i] = 32;\n            this.backColorMem[i] = this.props.backColorAsRGB;\n            this.foreColorMem[i] = this.props.foreColorAsRGB;\n        }\n        this.props.cursorPos = 0;\n        this.isCursorVisible = false;\n        this.drawRange(0, this.size - 1);\n    }\n    setFillStyleRGB(color) {\n        // const cssColor= \"#\"+(\"00000000\" + color.toString(16)).slice(-8);  RGBA\n        const cssColor = `#${color.toString(16).padStart(6, \"0\")}`;\n        this.ctx.fillStyle = cssColor;\n    }\n    drawTrs80Graphic(offset, val, fgc, bgc) {\n        let x, y;\n        x = offset % this.props.widthInChars * this.cellWidth;\n        y = Math.floor(offset / this.props.widthInChars) * this.cellHeight;\n        this.setFillStyleRGB(bgc);\n        this.ctx.fillRect(x, y, this.cellWidth, this.cellHeight);\n        if (val == 32) return;\n        this.setFillStyleRGB(fgc);\n        if (val & 1) this.ctx.fillRect(x, y, this.cellW1, this.cellH1);\n        y = y + this.cellH1;\n        if (val & 4) this.ctx.fillRect(x, y, this.cellW1, this.cellH2);\n        y = y + this.cellH2;\n        if (val & 16) this.ctx.fillRect(x, y, this.cellW1, this.cellH3);\n        x = x + this.cellW1;\n        if (val & 32) this.ctx.fillRect(x, y, this.cellW2, this.cellH3);\n        y = y - this.cellH2;\n        if (val & 8) this.ctx.fillRect(x, y, this.cellW2, this.cellH2);\n        y = y - this.cellH1;\n        if (val & 2) this.ctx.fillRect(x, y, this.cellW2, this.cellH1);\n    }\n    //**************************************************\n    drawCell(offset, value, fgc, bgc) {\n        if ((value & $e8e3453ed3aa6b92$var$TRS80_GRAPHIC_MARKER_MASK) == $e8e3453ed3aa6b92$var$TRS80_GRAPHIC_MARKER || value == 32) this.drawTrs80Graphic(offset, value & $e8e3453ed3aa6b92$var$TRS80_GRAPHIC_CHAR_MASK, fgc, bgc);\n        else {\n            let x, y;\n            x = offset % this.props.widthInChars * this.cellWidth;\n            y = Math.floor(offset / this.props.widthInChars) * this.cellHeight;\n            this.setFillStyleRGB(bgc);\n            this.ctx.fillRect(x, y, this.cellWidth, this.cellHeight);\n            if (value != 32) {\n                this.setFillStyleRGB(fgc);\n                const txt = String.fromCodePoint(value);\n                this.ctx.fillText(txt, x, y);\n            }\n        }\n    }\n    //*************************************************\n    // !!TODO add ability to setRange colors\n    // !! should this take a bytearray?\n    // !! need to add \"getRange\" to match\n    setRange(start, values) {\n        let k = 0;\n        for(let i = start; i < start + values.length; i++)this.videoMem[i] = values[k++];\n        this.drawRange(start, start + values.length - 1);\n    }\n    drawRange(start, end) {\n        for(let i = start; i <= end; i++)this.drawCell(i, this.videoMem[i], this.foreColorMem[i], this.backColorMem[i]);\n    }\n    /*************************************************/ setReset(x, y, isset) {\n        const loc = Math.floor(x / 2) + this.props.widthInChars * Math.floor(y / 3);\n        const cellx = x % 2;\n        const celly = y % 3;\n        if (x < 0 || x > this.props.widthInChars * 2) throw new Error(\"setReset: invalid x value\");\n        if (y < 0 || y > this.props.heightInChars * 3) throw new Error(\"setReset: invalid y value\");\n        if (!((this.videoMem[loc] & $e8e3453ed3aa6b92$var$TRS80_GRAPHIC_MARKER_MASK) == $e8e3453ed3aa6b92$var$TRS80_GRAPHIC_MARKER)) {\n            this.videoMem[loc] = $e8e3453ed3aa6b92$var$TRS80_GRAPHIC_MARKER; /* set to a cleared graphics value */ \n            this.backColorMem[loc] = this.props.backColorAsRGB;\n            this.foreColorMem[loc] = this.props.foreColorAsRGB;\n        }\n        if (isset) this.videoMem[loc] |= 1 << celly * 2 + cellx;\n        else this.videoMem[loc] &= ~(1 << celly * 2 + cellx);\n        this.drawRange(loc, loc);\n    }\n    //*************************************************\n    point(x, y) {\n        const loc = Math.floor(x / 2) + this.props.widthInChars * Math.floor(y / 3);\n        const cellx = x % 2;\n        const celly = y % 3;\n        if (x < 0 || x > this.props.widthInChars * 2) throw new Error(\"Point: invalid x value\");\n        if (y < 0 || y > this.props.heightInChars * 3) throw new Error(\"Point: invalid y value\");\n        if (!((this.videoMem[loc] & $e8e3453ed3aa6b92$var$TRS80_GRAPHIC_MARKER_MASK) == $e8e3453ed3aa6b92$var$TRS80_GRAPHIC_MARKER)) return false; /* not a graphic cell, so false */ \n        if (this.videoMem[loc] & 1 << celly * 2 + cellx) return true;\n        else return false;\n    }\n    //*************************************************\n    setCursor(location) {\n        if (location < 0 || location >= this.size) throw new Error(\"setCursor: invalid location: \" + location);\n        this.props.cursorPos = location;\n    }\n    //*************************************************\n    setCursorXY(x, y) {\n        if (x < 0 || y < 0 || this.props.widthInChars * y + x >= this.size) throw new Error(\"setCursorXY: invalid parameter(s)\");\n        this.setCursor(this.props.widthInChars * y + x);\n    }\n    //*************************************************\n    setColors(foreground, background) {\n        this.props.foreColorAsRGB = foreground;\n        this.props.backColorAsRGB = background;\n    }\n}\nclass $e8e3453ed3aa6b92$export$6dc37146168f9b6c {\n    keys;\n    returnValue;\n    id;\n    constructor(params){\n        const [className, id, returnBuffer, keysBuffer] = params;\n        this.keys = new (0, $997394d69310721e$export$a01cca24f011573a)(keysBuffer);\n        this.returnValue = new (0, $997394d69310721e$export$a01cca24f011573a)(returnBuffer);\n        this.id = id;\n    }\n    getProp(propName) {\n        postMessage([\n            \"term-getprop\",\n            [\n                this.id,\n                propName\n            ]\n        ]);\n        return this.returnValue.readWait(); // wait for result, then read it\n    }\n    charIn() {\n        return this.keys.readWait(); // wait for a key, then read it\n    }\n    point(x, y) {\n        postMessage([\n            \"term-point\",\n            [\n                this.id,\n                x,\n                y\n            ]\n        ]);\n        return this.returnValue.readWait() != 0; // wait for result, then read it\n    }\n    charOut(ch, codePoint) {\n        postMessage([\n            \"term-charout\",\n            [\n                this.id,\n                ch,\n                codePoint\n            ]\n        ]);\n    }\n    putStr(str) {\n        postMessage([\n            \"term-putstr\",\n            [\n                this.id,\n                str\n            ]\n        ]);\n    }\n    cls() {\n        postMessage([\n            \"term-cls\",\n            [\n                this.id\n            ]\n        ]);\n    }\n    setRange(start, values) {\n        postMessage([\n            \"term-setrange\",\n            [\n                this.id,\n                start,\n                values\n            ]\n        ]);\n    }\n    setC32(location, char) {\n        postMessage([\n            \"term-setc32\",\n            [\n                this.id,\n                location,\n                char\n            ]\n        ]);\n    }\n    setReset(x, y, isset) {\n        postMessage([\n            \"term-setreset\",\n            [\n                this.id,\n                x,\n                y,\n                isset\n            ]\n        ]);\n    }\n    setCursor(pos) {\n        postMessage([\n            \"term-setcursor\",\n            [\n                this.id,\n                pos\n            ]\n        ]);\n    }\n    setCursorXY(x, y) {\n        postMessage([\n            \"term-setcursorxy\",\n            [\n                this.id,\n                x,\n                y\n            ]\n        ]);\n    }\n    setColors(foreground, background) {\n        postMessage([\n            \"term-setcolors\",\n            [\n                this.id,\n                foreground,\n                background\n            ]\n        ]);\n    }\n    setFocus() {\n        postMessage([\n            \"term-focus\",\n            [\n                this.id\n            ]\n        ]);\n    }\n}\n\n\n\nlet $2e39aae7c890164c$var$mod;\nself.onmessage = function(e) {\n    //console.log('twrworker.js: message received from main script: '+e.data);\n    if (e.data[0] == \"startup\") {\n        const params = e.data[1];\n        //console.log(\"Worker startup params:\",params);\n        $2e39aae7c890164c$var$mod = new $2e39aae7c890164c$export$a5f3f3f0bd96bb23(params.allProxyParams);\n        $2e39aae7c890164c$var$mod.loadWasm(params.urlToLoad).then(()=>{\n            postMessage([\n                \"startupOkay\"\n            ]);\n        }).catch((ex)=>{\n            console.log(\".catch: \", ex);\n            postMessage([\n                \"startupFail\",\n                ex\n            ]);\n        });\n    } else if (e.data[0] == \"callC\") $2e39aae7c890164c$var$mod.callCImpl(e.data[1], e.data[2]).then((rc)=>{\n        postMessage([\n            \"callCOkay\",\n            rc\n        ]);\n    }).catch((ex)=>{\n        console.log(\"exception in callC in 'twrmodasyncproxy.js': \\n\", e.data[1], e.data[2]);\n        console.log(ex);\n        postMessage([\n            \"callCFail\",\n            ex\n        ]);\n    });\n    else console.log(\"twrmodasyncproxy.js: unknown message: \" + e);\n};\nclass $2e39aae7c890164c$export$a5f3f3f0bd96bb23 extends (0, $650c04823a04b22b$export$c83a0a3bffe07399) {\n    malloc;\n    imports;\n    ioNamesToID;\n    cpTranslate;\n    getProxyInstance(params) {\n        const className = params[0];\n        switch(className){\n            case \"twrConsoleDivProxy\":\n                return new (0, $c484b2e8c67a7340$export$e4a97cb991521e57)(params);\n            case \"twrConsoleTerminalProxy\":\n                return new (0, $e8e3453ed3aa6b92$export$6dc37146168f9b6c)(params);\n            case \"twrConsoleDebugProxy\":\n                return new (0, $f04c956722c3945f$export$bcb1e5070a093206)(params);\n            case \"twrConsoleCanvasProxy\":\n                return new (0, $496ef95f52233740$export$97cec2c338f46b48)(params);\n            default:\n                throw new Error(\"Unknown class name passed to getProxyClassConstructor: \" + className);\n        }\n    }\n    constructor(allProxyParams){\n        super();\n        this.isAsyncProxy = true;\n        this.malloc = (size)=>{\n            throw new Error(\"error - un-init malloc called\");\n        };\n        this.cpTranslate = new (0, $07ff08a59ba75008$export$c7de3f2686797480)();\n        this.ioNamesToID = allProxyParams.ioNamesToID;\n        // create IConsoleProxy versions of each IConsole\n        for(let i = 0; i < allProxyParams.conProxyParams.length; i++){\n            const params = allProxyParams.conProxyParams[i];\n            const con = this.getProxyInstance(params);\n            (0, $6a274cb2c782baea$export$c966f466478010bf).registerConsoleProxy(con);\n        }\n        const waitingCallsProxy = new (0, $7c86b727c15072df$export$78d2a4633fe89379)(allProxyParams.waitingCallsProxyParams);\n        const conProxyCall = (funcName, jsid, ...args)=>{\n            const con = (0, $6a274cb2c782baea$export$c966f466478010bf).getConsoleProxy(jsid);\n            const f = con[funcName];\n            if (!f) throw new Error(`Likely using an incorrect console type. jsid=${jsid}, funcName=${funcName}`);\n            return f.call(con, ...args);\n        };\n        const conSetRange = (jsid, chars, start, len)=>{\n            let values = [];\n            for(let i = start; i < start + len; i++)values.push(this.getLong(i));\n            conProxyCall(\"setRange\", jsid, start, values);\n        };\n        const conPutStr = (jsid, chars, codePage)=>{\n            conProxyCall(\"putStr\", jsid, this.getString(chars), codePage);\n        };\n        const conGetProp = (jsid, pn)=>{\n            const propName = this.getString(pn);\n            return conProxyCall(\"getProp\", jsid, propName);\n        };\n        const conDrawSeq = (jsid, ds)=>{\n            conProxyCall(\"drawSeq\", jsid, ds, this);\n        };\n        const twrGetConIDFromNameImpl = (nameIdx)=>{\n            const name = this.getString(nameIdx);\n            const id = this.ioNamesToID[name];\n            if (id) return id;\n            else return -1;\n        };\n        this.imports = {\n            twrTimeEpoch: (0, $25e0032167928e0e$export$a952b8f8c62754b8),\n            twrTimeTmLocal: (0, $07ff08a59ba75008$export$a0bf9983b7d1ed7c).bind(this),\n            twrUserLconv: (0, $07ff08a59ba75008$export$714291919e374cc0).bind(this),\n            twrUserLanguage: (0, $07ff08a59ba75008$export$99a2816c432302a9).bind(this),\n            twrRegExpTest1252: (0, $07ff08a59ba75008$export$6e12283a61625fd2).bind(this),\n            twrToLower1252: (0, $07ff08a59ba75008$export$1619a0be8731b76a).bind(this),\n            twrToUpper1252: (0, $07ff08a59ba75008$export$b8cd0608a44dce64).bind(this),\n            twrStrcoll: (0, $07ff08a59ba75008$export$2663d7470da86e92).bind(this),\n            twrUnicodeCodePointToCodePage: (0, $07ff08a59ba75008$export$b1748e2af4950b56).bind(this),\n            twrCodePageToUnicodeCodePoint: this.cpTranslate.convert.bind(this.cpTranslate),\n            twrGetDtnames: (0, $07ff08a59ba75008$export$6e74b5e725f469d6).bind(this),\n            twrGetConIDFromName: twrGetConIDFromNameImpl,\n            twrSleep: waitingCallsProxy.sleep.bind(waitingCallsProxy),\n            twrConCharOut: conProxyCall.bind(null, \"charOut\"),\n            twrConCharIn: conProxyCall.bind(null, \"charIn\"),\n            twrSetFocus: conProxyCall.bind(null, \"setFocus\"),\n            twrConGetProp: conGetProp,\n            twrConCls: conProxyCall.bind(null, \"cls\"),\n            twrConSetC32: conProxyCall.bind(null, \"setC32\"),\n            twrConSetReset: conProxyCall.bind(null, \"setReset\"),\n            twrConPoint: conProxyCall.bind(null, \"point\"),\n            twrConSetCursor: conProxyCall.bind(null, \"setCursor\"),\n            twrConSetColors: conProxyCall.bind(null, \"setColors\"),\n            twrConSetRange: conSetRange,\n            twrConPutStr: conPutStr,\n            twrConDrawSeq: conDrawSeq,\n            twrSin: Math.sin,\n            twrCos: Math.cos,\n            twrTan: Math.tan,\n            twrFAbs: Math.abs,\n            twrACos: Math.acos,\n            twrASin: Math.asin,\n            twrATan: Math.atan,\n            twrExp: Math.exp,\n            twrFloor: Math.floor,\n            twrCeil: Math.ceil,\n            twrFMod: function(x, y) {\n                return x % y;\n            },\n            twrLog: Math.log,\n            twrPow: Math.pow,\n            twrSqrt: Math.sqrt,\n            twrTrunc: Math.trunc,\n            twrDtoa: this.floatUtil.dtoa.bind(this.floatUtil),\n            twrToFixed: this.floatUtil.toFixed.bind(this.floatUtil),\n            twrToExponential: this.floatUtil.toExponential.bind(this.floatUtil),\n            twrAtod: this.floatUtil.atod.bind(this.floatUtil),\n            twrFcvtS: this.floatUtil.fcvtS.bind(this.floatUtil)\n        };\n    }\n    async loadWasm(pathToLoad) {\n        return super.loadWasm(pathToLoad, this.imports, this.ioNamesToID);\n    }\n}\n\n})();\n//# sourceMappingURL=twrmodasyncproxy.c3081bc6.js.map\n","import { twrWasmModuleBase } from \"./twrmodbase.js\";\nimport { twrTimeEpochImpl } from \"./twrdate.js\";\nimport { twrTimeTmLocalImpl, twrUserLconvImpl, twrUserLanguageImpl, twrRegExpTest1252Impl, twrToLower1252Impl, twrToUpper1252Impl } from \"./twrlocale.js\";\nimport { twrStrcollImpl, twrUnicodeCodePointToCodePageImpl, twrCodePageToUnicodeCodePoint, twrGetDtnamesImpl } from \"./twrlocale.js\";\nimport { twrConsoleDivProxy } from \"./twrcondiv.js\";\nimport { twrWaitingCallsProxy } from \"./twrwaitingcalls.js\";\nimport { twrConsoleCanvasProxy } from \"./twrcanvas.js\";\nimport { twrConsoleDebugProxy } from \"./twrcondebug.js\";\nimport { twrConsoleTerminalProxy } from \"./twrconterm.js\";\nimport { twrConsoleProxyRegistry } from \"./twrconreg.js\";\nlet mod;\nself.onmessage = function (e) {\n    //console.log('twrworker.js: message received from main script: '+e.data);\n    if (e.data[0] == 'startup') {\n        const params = e.data[1];\n        //console.log(\"Worker startup params:\",params);\n        mod = new twrWasmModuleAsyncProxy(params.allProxyParams);\n        mod.loadWasm(params.urlToLoad).then(() => {\n            postMessage([\"startupOkay\"]);\n        }).catch((ex) => {\n            console.log(\".catch: \", ex);\n            postMessage([\"startupFail\", ex]);\n        });\n    }\n    else if (e.data[0] == 'callC') {\n        mod.callCImpl(e.data[1], e.data[2]).then((rc) => {\n            postMessage([\"callCOkay\", rc]);\n        }).catch(ex => {\n            console.log(\"exception in callC in 'twrmodasyncproxy.js': \\n\", e.data[1], e.data[2]);\n            console.log(ex);\n            postMessage([\"callCFail\", ex]);\n        });\n    }\n    else {\n        console.log(\"twrmodasyncproxy.js: unknown message: \" + e);\n    }\n};\n// ************************************************************************\nexport class twrWasmModuleAsyncProxy extends twrWasmModuleBase {\n    malloc;\n    imports;\n    ioNamesToID; // ioName to IConsole.id\n    cpTranslate;\n    getProxyInstance(params) {\n        const className = params[0];\n        switch (className) {\n            case \"twrConsoleDivProxy\":\n                return new twrConsoleDivProxy(params);\n            case \"twrConsoleTerminalProxy\":\n                return new twrConsoleTerminalProxy(params);\n            case \"twrConsoleDebugProxy\":\n                return new twrConsoleDebugProxy(params);\n            case \"twrConsoleCanvasProxy\":\n                return new twrConsoleCanvasProxy(params);\n            default:\n                throw new Error(\"Unknown class name passed to getProxyClassConstructor: \" + className);\n        }\n    }\n    constructor(allProxyParams) {\n        super();\n        this.isAsyncProxy = true;\n        this.malloc = (size) => { throw new Error(\"error - un-init malloc called\"); };\n        this.cpTranslate = new twrCodePageToUnicodeCodePoint();\n        this.ioNamesToID = allProxyParams.ioNamesToID;\n        // create IConsoleProxy versions of each IConsole\n        for (let i = 0; i < allProxyParams.conProxyParams.length; i++) {\n            const params = allProxyParams.conProxyParams[i];\n            const con = this.getProxyInstance(params);\n            twrConsoleProxyRegistry.registerConsoleProxy(con);\n        }\n        const waitingCallsProxy = new twrWaitingCallsProxy(allProxyParams.waitingCallsProxyParams);\n        const conProxyCall = (funcName, jsid, ...args) => {\n            const con = twrConsoleProxyRegistry.getConsoleProxy(jsid);\n            const f = con[funcName];\n            if (!f)\n                throw new Error(`Likely using an incorrect console type. jsid=${jsid}, funcName=${funcName}`);\n            return f.call(con, ...args);\n        };\n        const conSetRange = (jsid, chars, start, len) => {\n            let values = [];\n            for (let i = start; i < start + len; i++) {\n                values.push(this.getLong(i));\n            }\n            conProxyCall(\"setRange\", jsid, start, values);\n        };\n        const conPutStr = (jsid, chars, codePage) => {\n            conProxyCall(\"putStr\", jsid, this.getString(chars), codePage);\n        };\n        const conGetProp = (jsid, pn) => {\n            const propName = this.getString(pn);\n            return conProxyCall(\"getProp\", jsid, propName);\n        };\n        const conDrawSeq = (jsid, ds) => {\n            conProxyCall(\"drawSeq\", jsid, ds, this);\n        };\n        const twrGetConIDFromNameImpl = (nameIdx) => {\n            const name = this.getString(nameIdx);\n            const id = this.ioNamesToID[name];\n            if (id)\n                return id;\n            else\n                return -1;\n        };\n        this.imports = {\n            twrTimeEpoch: twrTimeEpochImpl,\n            twrTimeTmLocal: twrTimeTmLocalImpl.bind(this),\n            twrUserLconv: twrUserLconvImpl.bind(this),\n            twrUserLanguage: twrUserLanguageImpl.bind(this),\n            twrRegExpTest1252: twrRegExpTest1252Impl.bind(this),\n            twrToLower1252: twrToLower1252Impl.bind(this),\n            twrToUpper1252: twrToUpper1252Impl.bind(this),\n            twrStrcoll: twrStrcollImpl.bind(this),\n            twrUnicodeCodePointToCodePage: twrUnicodeCodePointToCodePageImpl.bind(this),\n            twrCodePageToUnicodeCodePoint: this.cpTranslate.convert.bind(this.cpTranslate),\n            twrGetDtnames: twrGetDtnamesImpl.bind(this),\n            twrGetConIDFromName: twrGetConIDFromNameImpl,\n            twrSleep: waitingCallsProxy.sleep.bind(waitingCallsProxy),\n            twrConCharOut: conProxyCall.bind(null, \"charOut\"),\n            twrConCharIn: conProxyCall.bind(null, \"charIn\"),\n            twrSetFocus: conProxyCall.bind(null, \"setFocus\"),\n            twrConGetProp: conGetProp,\n            twrConCls: conProxyCall.bind(null, \"cls\"),\n            twrConSetC32: conProxyCall.bind(null, \"setC32\"),\n            twrConSetReset: conProxyCall.bind(null, \"setReset\"),\n            twrConPoint: conProxyCall.bind(null, \"point\"),\n            twrConSetCursor: conProxyCall.bind(null, \"setCursor\"),\n            twrConSetColors: conProxyCall.bind(null, \"setColors\"),\n            twrConSetRange: conSetRange,\n            twrConPutStr: conPutStr,\n            twrConDrawSeq: conDrawSeq,\n            twrSin: Math.sin,\n            twrCos: Math.cos,\n            twrTan: Math.tan,\n            twrFAbs: Math.abs,\n            twrACos: Math.acos,\n            twrASin: Math.asin,\n            twrATan: Math.atan,\n            twrExp: Math.exp,\n            twrFloor: Math.floor,\n            twrCeil: Math.ceil,\n            twrFMod: function (x, y) { return x % y; },\n            twrLog: Math.log,\n            twrPow: Math.pow,\n            twrSqrt: Math.sqrt,\n            twrTrunc: Math.trunc,\n            twrDtoa: this.floatUtil.dtoa.bind(this.floatUtil),\n            twrToFixed: this.floatUtil.toFixed.bind(this.floatUtil),\n            twrToExponential: this.floatUtil.toExponential.bind(this.floatUtil),\n            twrAtod: this.floatUtil.atod.bind(this.floatUtil),\n            twrFcvtS: this.floatUtil.fcvtS.bind(this.floatUtil)\n        };\n    }\n    async loadWasm(pathToLoad) {\n        return super.loadWasm(pathToLoad, this.imports, this.ioNamesToID);\n    }\n}\n//# sourceMappingURL=twrmodasyncproxy.js.map","import {TModAsyncProxyStartupMsg} from \"./twrmodasync.js\"\nimport {twrWasmModuleBase} from \"./twrmodbase.js\"\nimport {twrTimeEpochImpl} from \"./twrdate.js\"\nimport {twrTimeTmLocalImpl, twrUserLconvImpl, twrUserLanguageImpl, twrRegExpTest1252Impl,twrToLower1252Impl, twrToUpper1252Impl} from \"./twrlocale.js\"\nimport {twrStrcollImpl, twrUnicodeCodePointToCodePageImpl, twrCodePageToUnicodeCodePoint, twrGetDtnamesImpl} from \"./twrlocale.js\"\nimport {twrConsoleDivProxy} from \"./twrcondiv.js\";\nimport {twrWaitingCallsProxy, TWaitingCallsProxyParams} from \"./twrwaitingcalls.js\";\nimport {IConsoleProxy, TConsoleProxyParams} from \"./twrcon.js\"\nimport {twrConsoleCanvasProxy} from \"./twrcanvas.js\";\nimport {twrConsoleDebugProxy} from \"./twrcondebug.js\"\nimport {twrConsoleTerminalProxy} from \"./twrconterm.js\"\nimport {twrConsoleProxyRegistry} from \"./twrconreg.js\"\n\nexport interface IAllProxyParams {\n\tconProxyParams: TConsoleProxyParams[],  // everything needed to create matching IConsoleProxy for each IConsole and twrConsoleProxyRegistry\n\tioNamesToID: {[key:string]: number},  // name to id mappings for this module\n\twaitingCallsProxyParams:TWaitingCallsProxyParams,\n}\n\nlet mod:twrWasmModuleAsyncProxy;\n\nself.onmessage = function(e) {\n    //console.log('twrworker.js: message received from main script: '+e.data);\n\n    if (e.data[0]=='startup') {\n        const params:TModAsyncProxyStartupMsg=e.data[1];\n        //console.log(\"Worker startup params:\",params);\n        mod=new twrWasmModuleAsyncProxy(params.allProxyParams);\n\n        mod.loadWasm(params.urlToLoad).then( ()=> {\n            postMessage([\"startupOkay\"]);\n        }).catch( (ex)=> {\n            console.log(\".catch: \", ex);\n            postMessage([\"startupFail\", ex]);\n        });\n    }\n    else if (e.data[0]=='callC') {\n         mod.callCImpl(e.data[1], e.data[2]).then( (rc)=> {\n            postMessage([\"callCOkay\", rc]);\n        }).catch(ex => {\n            console.log(\"exception in callC in 'twrmodasyncproxy.js': \\n\", e.data[1], e.data[2]);\n            console.log(ex);\n            postMessage([\"callCFail\", ex]);\n        });\n    }\n    else {\n        console.log(\"twrmodasyncproxy.js: unknown message: \"+e);\n    }\n}\n\n// ************************************************************************\n\nexport class twrWasmModuleAsyncProxy extends twrWasmModuleBase {\n   malloc:(size:number)=>Promise<number>;\n   imports:WebAssembly.ModuleImports;\n\tioNamesToID: {[key:string]: number};   // ioName to IConsole.id\n   cpTranslate:twrCodePageToUnicodeCodePoint;\n\n\tprivate getProxyInstance(params:TConsoleProxyParams): IConsoleProxy {\n\n\t\tconst className=params[0];\n\t\tswitch (className) {\n\t\t\tcase \"twrConsoleDivProxy\":\n\t\t\t\t return new twrConsoleDivProxy(params);\n\n\t\t\tcase \"twrConsoleTerminalProxy\":\n\t\t\t\treturn new twrConsoleTerminalProxy(params);\n\n\t\t\tcase \"twrConsoleDebugProxy\":\n\t\t\t\treturn new twrConsoleDebugProxy(params);\n\n         case \"twrConsoleCanvasProxy\":\n            return new twrConsoleCanvasProxy(params);\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unknown class name passed to getProxyClassConstructor: \"+className);\n\t\t}\n\t}\n\n   constructor(allProxyParams:IAllProxyParams) {\n      super();\n      this.isAsyncProxy=true;\n      this.malloc=(size:number)=>{throw new Error(\"error - un-init malloc called\")};\n\t\tthis.cpTranslate=new twrCodePageToUnicodeCodePoint();\n\n\t\tthis.ioNamesToID=allProxyParams.ioNamesToID;\n\n\t\t// create IConsoleProxy versions of each IConsole\n\t\tfor (let i=0; i<allProxyParams.conProxyParams.length; i++) {\n\t\t\tconst params=allProxyParams.conProxyParams[i];\n\t\t\tconst con:IConsoleProxy = this.getProxyInstance(params);\n\t\t\ttwrConsoleProxyRegistry.registerConsoleProxy(con)\n\t\t}\n\t\t\t\n      const waitingCallsProxy = new twrWaitingCallsProxy(allProxyParams.waitingCallsProxyParams);\n\n      const conProxyCall = (funcName: keyof IConsoleProxy, jsid:number, ...args: any[]):any => {\n\t\t\tconst con=twrConsoleProxyRegistry.getConsoleProxy(jsid);\n\t\t\tconst f=con[funcName] as (...args: any[]) => any;\n         if (!f) throw new Error(`Likely using an incorrect console type. jsid=${jsid}, funcName=${funcName}`);\n\t\t\treturn f.call(con, ...args);\n      }\n\n      const conSetRange = (jsid:number, chars:number, start:number, len:number) => {\n         let values=[];\n         for (let i=start; i<start+len; i++) {\n            values.push(this.getLong(i));\n         }\n         conProxyCall(\"setRange\", jsid, start, values);\n      }\n\n      const conPutStr = (jsid:number, chars:number, codePage:number) => {\n         conProxyCall(\"putStr\", jsid, this.getString(chars), codePage);\n      }\n\n      const conGetProp = (jsid:number, pn:number) => {\n         const propName=this.getString(pn);\n         return conProxyCall(\"getProp\", jsid, propName);\n      }\n\n      const conDrawSeq = (jsid:number, ds:number) => {\n         conProxyCall(\"drawSeq\", jsid, ds, this);\n      }\n\n\t\tconst twrGetConIDFromNameImpl = (nameIdx:number):number => {\n\t\t\tconst name=this.getString(nameIdx);\n\t\t\tconst id=this.ioNamesToID[name];\n\t\t\tif (id)\n\t\t\t\treturn id;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n      this.imports={\n         twrTimeEpoch:twrTimeEpochImpl,\n         twrTimeTmLocal:twrTimeTmLocalImpl.bind(this),\n         twrUserLconv:twrUserLconvImpl.bind(this),\n         twrUserLanguage:twrUserLanguageImpl.bind(this),\n         twrRegExpTest1252:twrRegExpTest1252Impl.bind(this),\n         twrToLower1252:twrToLower1252Impl.bind(this),\n         twrToUpper1252:twrToUpper1252Impl.bind(this),\n         twrStrcoll:twrStrcollImpl.bind(this),\n         twrUnicodeCodePointToCodePage:twrUnicodeCodePointToCodePageImpl.bind(this),\n         twrCodePageToUnicodeCodePoint:this.cpTranslate.convert.bind(this.cpTranslate),\n         twrGetDtnames:twrGetDtnamesImpl.bind(this),\n\t\t\ttwrGetConIDFromName: twrGetConIDFromNameImpl,\n\n         twrSleep:waitingCallsProxy.sleep.bind(waitingCallsProxy),\n\n         twrConCharOut:conProxyCall.bind(null, \"charOut\"),\n         twrConCharIn:conProxyCall.bind(null, \"charIn\"),\n         twrSetFocus:conProxyCall.bind(null, \"setFocus\"),\n\n         twrConGetProp:conGetProp,\n         twrConCls:conProxyCall.bind(null, \"cls\"),\n         twrConSetC32:conProxyCall.bind(null, \"setC32\"),\n         twrConSetReset:conProxyCall.bind(null, \"setReset\"),\n         twrConPoint:conProxyCall.bind(null, \"point\"),\n         twrConSetCursor:conProxyCall.bind(null, \"setCursor\"),\n         twrConSetColors:conProxyCall.bind(null, \"setColors\"),\n         twrConSetRange:conSetRange,\n         twrConPutStr:conPutStr,\n\n         twrConDrawSeq:conDrawSeq,\n\n         twrSin:Math.sin,\n         twrCos:Math.cos,\n         twrTan: Math.tan,\n         twrFAbs: Math.abs,\n         twrACos: Math.acos,\n         twrASin: Math.asin,\n         twrATan: Math.atan,\n         twrExp: Math.exp,\n         twrFloor: Math.floor,\n         twrCeil: Math.ceil,\n         twrFMod: function(x:number, y:number) {return x%y},\n         twrLog: Math.log,\n         twrPow: Math.pow,\n         twrSqrt: Math.sqrt,\n         twrTrunc: Math.trunc,\n\n         twrDtoa: this.floatUtil.dtoa.bind(this.floatUtil),\n         twrToFixed: this.floatUtil.toFixed.bind(this.floatUtil),\n         twrToExponential: this.floatUtil.toExponential.bind(this.floatUtil),\n         twrAtod: this.floatUtil.atod.bind(this.floatUtil),\n         twrFcvtS: this.floatUtil.fcvtS.bind(this.floatUtil)\n      }\n   }\n\n\tasync loadWasm(pathToLoad:string) {\n      return super.loadWasm(pathToLoad, this.imports, this.ioNamesToID);\n   }\n}\n\n\n","import { twrFloatUtil } from \"./twrfloat.js\";\nimport { codePageUTF8, codePage1252, codePageASCII, to1252, toASCII } from \"./twrlocale.js\";\n/*********************************************************************/\n/*********************************************************************/\n/*********************************************************************/\nexport class twrWasmModuleBase {\n    memory;\n    mem8;\n    mem32;\n    memD;\n    exports;\n    isAsyncProxy = false;\n    floatUtil;\n    constructor() {\n        this.mem8 = new Uint8Array(); // avoid type errors\n        this.mem32 = new Uint32Array(); // avoid type errors\n        this.memD = new Float64Array(); // avoid type errors\n        this.floatUtil = new twrFloatUtil(this);\n        //console.log(\"size of mem8 after constructor\",this.mem8.length);\n    }\n    /*********************************************************************/\n    /*********************************************************************/\n    // overridden by twrWasmModuleAsync\n    async loadWasm(pathToLoad, imports, ioNamesToID) {\n        //console.log(\"fileToLoad\",fileToLoad)\n        let response;\n        try {\n            response = await fetch(pathToLoad);\n        }\n        catch (err) {\n            console.log('loadWasm() failed to fetch: ' + pathToLoad);\n            throw err;\n        }\n        if (!response.ok)\n            throw new Error(\"fetch response error on file '\" + pathToLoad + \"'\\n\" + response.statusText);\n        try {\n            let wasmBytes = await response.arrayBuffer();\n            let instance = await WebAssembly.instantiate(wasmBytes, { env: imports });\n            this.exports = instance.instance.exports;\n            if (!this.exports)\n                throw new Error(\"Unexpected error - undefined instance.exports\");\n            if (this.memory)\n                throw new Error(\"unexpected error -- this.memory already set\");\n            this.memory = this.exports.memory;\n            if (!this.memory)\n                throw new Error(\"Unexpected error - undefined exports.memory\");\n            this.mem8 = new Uint8Array(this.memory.buffer);\n            this.mem32 = new Uint32Array(this.memory.buffer);\n            this.memD = new Float64Array(this.memory.buffer);\n            // SharedArrayBuffer required for twrWasmModuleAsync/twrWasmModuleAsyncProxy\n            // instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error\n            // (don't check for instanceof SharedArrayBuffer, since it can cause an runtime error when SharedArrayBuffer does not exist)\n            if (this.isAsyncProxy) {\n                if (this.memory.buffer instanceof ArrayBuffer)\n                    console.log(\"twrWasmModuleAsync requires shared Memory. Add wasm-ld --shared-memory --no-check-features (see docs)\");\n                postMessage([\"setmemory\", this.memory]);\n            }\n            else {\n                // here if twrWasmModule because twrWasmModuleAsync overrides this function, and twrWasmModuleAsyncProxy was handled above\n                if (!(this.memory.buffer instanceof ArrayBuffer))\n                    console.log(\"twrWasmModule does not require shared Memory. Okay to remove wasm-ld --shared-memory --no-check-features\");\n            }\n            this.malloc = (size) => {\n                return new Promise(resolve => {\n                    const m = this.exports.malloc;\n                    resolve(m(size));\n                });\n            };\n            this.init(ioNamesToID);\n        }\n        catch (err) {\n            console.log('Wasm instantiate error: ' + err + (err.stack ? \"\\n\" + err.stack : ''));\n            throw err;\n        }\n    }\n    init(ioNamesToID) {\n        const twrInit = this.exports.twr_wasm_init;\n        twrInit(ioNamesToID.stdio, ioNamesToID.stderr, ioNamesToID.std2d == undefined ? -1 : ioNamesToID.std2d, this.mem8.length);\n    }\n    /*\n    * this is overridden by twrmodasync (although its worker side will call this version)\n    *\n    * callC takes an array where:\n    * the first entry is the name of the C function in the Wasm module to call (must be exported, typically via the --export clang flag)\n    * and the next entries are a variable number of arguments to pass to the C function, of type\n    * number - converted to int32 or float64 as appropriate\n    * string - converted to a an index (ptr) into a module Memory returned via stringToMem()\n    * URL - the file contents are loaded into module Memory via fetchAndPutURL(), and two C arguments are generated - index (pointer) to the memory, and length\n    * ArrayBuffer - the array is loaded into module memory via putArrayBuffer\n    */\n    async callC(params) {\n        const cparams = await this.preCallC(params);\n        let retval = await this.callCImpl(params[0], cparams);\n        await this.postCallC(cparams, params);\n        return retval;\n    }\n    async callCImpl(fname, cparams = []) {\n        if (!this.exports)\n            throw new Error(\"this.exports undefined\");\n        if (!this.exports[fname])\n            throw new Error(\"callC: function '\" + fname + \"' not in export table.  Use --export wasm-ld flag.\");\n        const f = this.exports[fname];\n        let cr = f(...cparams);\n        return cr;\n    }\n    // convert an array of arguments to numbers by stuffing contents into malloc'd Wasm memory\n    async preCallC(params) {\n        if (!(params.constructor === Array))\n            throw new Error(\"callC: params must be array, first arg is function name\");\n        if (params.length == 0)\n            throw new Error(\"callC: missing function name\");\n        let cparams = [];\n        let ci = 0;\n        for (let i = 1; i < params.length; i++) {\n            const p = params[i];\n            switch (typeof p) {\n                case 'number':\n                case 'bigint':\n                    cparams[ci++] = p;\n                    break;\n                case 'string':\n                    cparams[ci++] = await this.putString(p);\n                    break;\n                case 'object':\n                    if (p instanceof URL) {\n                        const r = await this.fetchAndPutURL(p);\n                        cparams[ci++] = r[0]; // mem index\n                        cparams[ci++] = r[1]; // len\n                        break;\n                    }\n                    else if (p instanceof ArrayBuffer) {\n                        const r = await this.putArrayBuffer(p);\n                        cparams[ci++] = r; // mem index\n                        break;\n                    }\n                default:\n                    throw new Error(\"callC: invalid object type passed in\");\n            }\n        }\n        return cparams;\n    }\n    // free the mallocs; copy array buffer data from malloc back to arraybuffer\n    async postCallC(cparams, params) {\n        let ci = 0;\n        for (let i = 1; i < params.length; i++) {\n            const p = params[i];\n            switch (typeof p) {\n                case 'number':\n                case 'bigint':\n                    ci++;\n                    break;\n                case 'string':\n                    await this.callCImpl('free', [cparams[ci]]);\n                    ci++;\n                    break;\n                case 'object':\n                    if (p instanceof URL) {\n                        await this.callCImpl('free', [cparams[ci]]);\n                        ci = ci + 2;\n                        break;\n                    }\n                    else if (p instanceof ArrayBuffer) {\n                        const u8 = new Uint8Array(p);\n                        const idx = cparams[ci];\n                        for (let j = 0; j < u8.length; j++)\n                            u8[j] = this.mem8[idx + j]; // mod.mem8 is a Uint8Array view of the module's WebAssembly Memory\n                        await this.callCImpl('free', [idx]);\n                        ci++;\n                        break;\n                    }\n                    else\n                        throw new Error(\"postCallC: internal error A\");\n                default:\n                    throw new Error(\"postCallC: internal error B\");\n            }\n        }\n        return cparams;\n    }\n    /*********************************************************************/\n    /*********************************************************************/\n    // convert a Javascript string into byte sequence that encodes the string using UTF8, or the requested codePage\n    stringToU8(sin, codePage = codePageUTF8) {\n        let ru8;\n        if (codePage == codePageUTF8) {\n            const encoder = new TextEncoder();\n            ru8 = encoder.encode(sin);\n        }\n        else if (codePage == codePage1252) {\n            ru8 = new Uint8Array(sin.length);\n            for (let i = 0; i < sin.length; i++) {\n                ru8[i] = to1252(sin[i]);\n            }\n        }\n        else if (codePage == codePageASCII) {\n            ru8 = new Uint8Array(sin.length);\n            for (let i = 0; i < sin.length; i++) {\n                const r = toASCII(sin[i]);\n                ru8[i] = r;\n            }\n        }\n        else {\n            throw new Error(\"unknown codePage: \" + codePage);\n        }\n        return ru8;\n    }\n    // copy a string into existing buffer in the webassembly module memory as utf8 (or specified codePage)\n    // result always null terminated\n    copyString(buffer, buffer_size, sin, codePage = codePageUTF8) {\n        if (buffer_size < 1)\n            throw new Error(\"copyString buffer_size must have length > 0 (room for terminating 0): \" + buffer_size);\n        const ru8 = this.stringToU8(sin, codePage);\n        let i;\n        for (i = 0; i < ru8.length && i < buffer_size - 1; i++)\n            this.mem8[buffer + i] = ru8[i];\n        this.mem8[buffer + i] = 0;\n    }\n    // allocate and copy a string into the webassembly module memory as utf8 (or the specified codePage)\n    async putString(sin, codePage = codePageUTF8) {\n        const ru8 = this.stringToU8(sin, codePage);\n        const strIndex = await this.malloc(ru8.length + 1);\n        this.mem8.set(ru8, strIndex);\n        this.mem8[strIndex + ru8.length] = 0;\n        return strIndex;\n    }\n    // allocate and copy a Uint8Array into Wasm mod memory\n    async putU8(u8a) {\n        let dest = await this.malloc(u8a.length);\n        this.mem8.set(u8a, dest);\n        return dest;\n    }\n    async putArrayBuffer(ab) {\n        const u8 = new Uint8Array(ab);\n        return this.putU8(u8);\n    }\n    // given a url, load its contents, and stuff into Wasm memory similar to Unint8Array\n    async fetchAndPutURL(fnin) {\n        if (!(typeof fnin === 'object' && fnin instanceof URL))\n            throw new Error(\"fetchAndPutURL param must be URL\");\n        try {\n            let response = await fetch(fnin);\n            let buffer = await response.arrayBuffer();\n            let src = new Uint8Array(buffer);\n            let dest = await this.putU8(src);\n            return [dest, src.length];\n        }\n        catch (err) {\n            console.log('fetchAndPutURL Error. URL: ' + fnin + '\\n' + err + (err.stack ? \"\\n\" + err.stack : ''));\n            throw err;\n        }\n    }\n    getLong(idx) {\n        const idx32 = Math.floor(idx / 4);\n        if (idx32 * 4 != idx)\n            throw new Error(\"getLong passed non long aligned address\");\n        if (idx32 < 0 || idx32 >= this.mem32.length)\n            throw new Error(\"invalid index passed to getLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\n        const long = this.mem32[idx32];\n        return long;\n    }\n    setLong(idx, value) {\n        const idx32 = Math.floor(idx / 4);\n        if (idx32 * 4 != idx)\n            throw new Error(\"setLong passed non long aligned address\");\n        if (idx32 < 0 || idx32 >= this.mem32.length - 1)\n            throw new Error(\"invalid index passed to setLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\n        this.mem32[idx32] = value;\n    }\n    getDouble(idx) {\n        const idx64 = Math.floor(idx / 8);\n        if (idx64 * 8 != idx)\n            throw new Error(\"getLong passed non Float64 aligned address\");\n        const long = this.memD[idx64];\n        return long;\n    }\n    setDouble(idx, value) {\n        const idx64 = Math.floor(idx / 8);\n        if (idx64 * 8 != idx)\n            throw new Error(\"setDouble passed non Float64 aligned address\");\n        this.memD[idx64] = value;\n    }\n    getShort(idx) {\n        if (idx < 0 || idx >= this.mem8.length)\n            throw new Error(\"invalid index passed to getShort: \" + idx);\n        const short = this.mem8[idx] + this.mem8[idx + 1] * 256;\n        return short;\n    }\n    // get a string out of module memory\n    // null terminated, up until max of (optional) len bytes\n    // len may be longer than the number of characters, if characters are utf-8 encoded\n    getString(strIndex, len, codePage = codePageUTF8) {\n        if (strIndex < 0 || strIndex >= this.mem8.length)\n            throw new Error(\"invalid strIndex passed to getString: \" + strIndex);\n        if (len) {\n            if (len < 0 || len + strIndex > this.mem8.length)\n                throw new Error(\"invalid len  passed to getString: \" + len);\n        }\n        else {\n            len = this.mem8.indexOf(0, strIndex);\n            if (len == -1)\n                throw new Error(\"string is not null terminated\");\n            len = len - strIndex;\n        }\n        let encodeFormat;\n        if (codePage == codePageUTF8)\n            encodeFormat = 'utf-8';\n        else if (codePage == codePage1252)\n            encodeFormat = 'windows-1252';\n        else\n            throw new Error(\"Unsupported codePage: \" + codePage);\n        const td = new TextDecoder(encodeFormat);\n        const u8todecode = new Uint8Array(this.mem8.buffer, strIndex, len);\n        // chrome throws exception when using TextDecoder on SharedArrayBuffer\n        // BUT, instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error, so don't check directly\n        if (this.mem8.buffer instanceof ArrayBuffer) {\n            const sout = td.decode(u8todecode);\n            return sout;\n        }\n        else { // must be SharedArrayBuffer\n            const regularArrayBuffer = new ArrayBuffer(len);\n            const regularUint8Array = new Uint8Array(regularArrayBuffer);\n            regularUint8Array.set(u8todecode);\n            const sout = td.decode(regularUint8Array);\n            return sout;\n        }\n    }\n    // get a byte array out of module memory when passed in index to [size, dataptr]\n    getU8Arr(idx) {\n        if (idx < 0 || idx >= this.mem8.length)\n            throw new Error(\"invalid index passed to getU8: \" + idx);\n        const rv = new Uint32Array((this.mem8.slice(idx, idx + 8)).buffer);\n        let size = rv[0];\n        let dataptr = rv[1];\n        if (dataptr < 0 || dataptr >= (this.mem8.length))\n            throw new Error(\"invalid idx.dataptr passed to getU8\");\n        if (size < 0 || size > (this.mem8.length - dataptr))\n            throw new Error(\"invalid idx.size passed to  getU8\");\n        const u8 = this.mem8.slice(dataptr, dataptr + size);\n        return u8;\n    }\n    // get a int32 array out of module memory when passed in index to [size, dataptr]\n    getU32Arr(idx) {\n        if (idx < 0 || idx >= this.mem8.length)\n            throw new Error(\"invalid index passed to getU32: \" + idx);\n        const rv = new Uint32Array((this.mem8.slice(idx, idx + 8)).buffer);\n        let size = rv[0];\n        let dataptr = rv[1];\n        if (dataptr < 0 || dataptr >= (this.mem8.length))\n            throw new Error(\"invalid idx.dataptr passed to getU32\");\n        if (size < 0 || size > (this.mem8.length - dataptr))\n            throw new Error(\"invalid idx.size passed to  getU32\");\n        if (size % 4 != 0)\n            throw new Error(\"idx.size is not an integer number of 32 bit words\");\n        const u32 = new Uint32Array((this.mem8.slice(dataptr, dataptr + size)).buffer);\n        return u32;\n    }\n}\n//# sourceMappingURL=twrmodbase.js.map","\nimport {twrFloatUtil} from \"./twrfloat.js\";\nimport {codePageUTF8, codePage1252, codePageASCII, to1252, toASCII} from \"./twrlocale.js\"\nimport {IConsole, IConsoleBase, IConsoleStream, IConsoleCanvas} from \"./twrcon.js\"\n\nexport interface IModOpts {\n\tstdio?: IConsoleStream&IConsoleBase,\n   d2dcanvas?: IConsoleCanvas&IConsoleBase,\n\tio?: {[key:string]: IConsole},\n\twindim?:[number, number],\n\tforecolor?:string,\n\tbackcolor?:string,\n\tfontsize?:number,\n\timports?:{},\n}\n\n/*********************************************************************/\n/*********************************************************************/\n/*********************************************************************/\n\nexport abstract class twrWasmModuleBase {\n\tmemory?:WebAssembly.Memory;\n\tmem8:Uint8Array;\n\tmem32:Uint32Array;\n\tmemD:Float64Array;\n\tabstract malloc:(size:number)=>Promise<number>;\n\texports?:WebAssembly.Exports;\n\tisAsyncProxy=false;\n\tfloatUtil:twrFloatUtil;\n\n\tconstructor() {\n\t\tthis.mem8=new Uint8Array();  \t// avoid type errors\n\t\tthis.mem32=new Uint32Array();  // avoid type errors\n\t\tthis.memD=new Float64Array();  // avoid type errors\n\t\tthis.floatUtil=new twrFloatUtil(this);\n\t\t//console.log(\"size of mem8 after constructor\",this.mem8.length);\n\t}\n\n\t/*********************************************************************/\n\t/*********************************************************************/\n\n\t// overridden by twrWasmModuleAsync\n\tasync loadWasm(pathToLoad:string, imports:WebAssembly.ModuleImports, ioNamesToID:{[key:string]:number}) {\n\t\t//console.log(\"fileToLoad\",fileToLoad)\n\n\t\tlet response;\n\t\ttry {\n\t\t\tresponse=await fetch(pathToLoad);\n\t\t} catch(err:any) {\n\t\t\tconsole.log('loadWasm() failed to fetch: '+pathToLoad);\n\t\t\tthrow err;\n\t\t}\n\t\t\n\t\tif (!response.ok) throw new Error(\"fetch response error on file '\"+pathToLoad+\"'\\n\"+response.statusText);\n\n\t\ttry {\n\t\t\tlet wasmBytes = await response.arrayBuffer();\n\n\t\t\tlet instance = await WebAssembly.instantiate(wasmBytes, {env: imports});\n\n\t\t\tthis.exports=instance.instance.exports;\n\t\t\tif (!this.exports) throw new Error(\"Unexpected error - undefined instance.exports\");\n\n\t\t\tif (this.memory) throw new Error (\"unexpected error -- this.memory already set\");\n\t\t\tthis.memory=this.exports.memory as WebAssembly.Memory;\n\t\t\tif (!this.memory) throw new Error(\"Unexpected error - undefined exports.memory\");\n\t\t\tthis.mem8 = new Uint8Array(this.memory.buffer);\n\t\t\tthis.mem32 = new Uint32Array(this.memory.buffer);\n\t\t\tthis.memD = new Float64Array(this.memory.buffer);\n\n\t\t\t// SharedArrayBuffer required for twrWasmModuleAsync/twrWasmModuleAsyncProxy\n\t\t\t// instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error\n\t\t\t// (don't check for instanceof SharedArrayBuffer, since it can cause an runtime error when SharedArrayBuffer does not exist)\n\t\t\tif (this.isAsyncProxy) {\n\t\t\t\tif (this.memory.buffer instanceof ArrayBuffer)\n\t\t\t\t\tconsole.log(\"twrWasmModuleAsync requires shared Memory. Add wasm-ld --shared-memory --no-check-features (see docs)\");\n\t\t\t\t\n\t\t\t\tpostMessage([\"setmemory\",this.memory]);\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\t// here if twrWasmModule because twrWasmModuleAsync overrides this function, and twrWasmModuleAsyncProxy was handled above\n\n\t\t\t\tif (!(this.memory.buffer instanceof ArrayBuffer))\n\t\t\t\t\tconsole.log(\"twrWasmModule does not require shared Memory. Okay to remove wasm-ld --shared-memory --no-check-features\");\n\t\t\t}\n\n\t\t\tthis.malloc=(size:number)=>{\n\t\t\t\treturn new Promise(resolve => {\n\t\t\t\t\tconst m=this.exports!.malloc as (size:number)=>number;\n\t\t\t\t\tresolve(m(size));\n\t\t\t\t});\n\t\t   };\n\n\t\t\tthis.init(ioNamesToID);\n\n\t\t} catch(err:any) {\n\t\t\tconsole.log('Wasm instantiate error: ' + err + (err.stack ? \"\\n\" + err.stack : ''));\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tprivate init(ioNamesToID:{[key:string]:number}) {\n\t\t\tconst twrInit=this.exports!.twr_wasm_init as CallableFunction;\n\t\t\ttwrInit(ioNamesToID.stdio, ioNamesToID.stderr, ioNamesToID.std2d==undefined?-1:ioNamesToID.std2d, this.mem8.length);\n\t}\n\n\t/* \n\t* this is overridden by twrmodasync (although its worker side will call this version)\n\t* \n\t* callC takes an array where:\n\t* the first entry is the name of the C function in the Wasm module to call (must be exported, typically via the --export clang flag)\n\t* and the next entries are a variable number of arguments to pass to the C function, of type\n\t* number - converted to int32 or float64 as appropriate\n\t* string - converted to a an index (ptr) into a module Memory returned via stringToMem()\n\t* URL - the file contents are loaded into module Memory via fetchAndPutURL(), and two C arguments are generated - index (pointer) to the memory, and length\n\t* ArrayBuffer - the array is loaded into module memory via putArrayBuffer\n    */\n\n\tasync callC(params:[string, ...(string|number|bigint|ArrayBuffer|URL)[]]) {\n\t\tconst cparams=await this.preCallC(params);\n\t\tlet retval = await this.callCImpl(params[0], cparams);\n\t\tawait this.postCallC(cparams, params);\n\t\treturn retval;\n\t}\n\n\tasync callCImpl(fname:string, cparams:(number|bigint)[]=[]) {\n\t\tif (!this.exports) throw new Error(\"this.exports undefined\");\n\t\tif (!this.exports[fname]) throw new Error(\"callC: function '\"+fname+\"' not in export table.  Use --export wasm-ld flag.\");\n\n\t\tconst f = this.exports[fname] as CallableFunction;\n\t\tlet cr=f(...cparams);\n\n\t\treturn cr;\n\t}\n\n\t// convert an array of arguments to numbers by stuffing contents into malloc'd Wasm memory\n\tasync preCallC(params:[string, ...(string|number|bigint|ArrayBuffer|URL)[]]) {\n\n\t\tif (!(params.constructor === Array)) throw new Error (\"callC: params must be array, first arg is function name\");\n\t\tif (params.length==0) throw new Error(\"callC: missing function name\");\n\n\t\tlet cparams:(number|bigint)[]=[];\n\t\tlet ci=0;\n\t\tfor (let i=1; i < params.length; i++) {\n\t\t\tconst p=params[i];\n\t\t\tswitch (typeof p) {\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'bigint':\n\t\t\t\t\tcparams[ci++]=p;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'string':\n\t\t\t\t\tcparams[ci++]=await this.putString(p);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'object':\n\t\t\t\t\tif (p instanceof URL) {\n\t\t\t\t\t\tconst r=await this.fetchAndPutURL(p);\n\t\t\t\t\t\tcparams[ci++]=r[0];  // mem index\n\t\t\t\t\t\tcparams[ci++]=r[1];   // len\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p instanceof ArrayBuffer) {\n\t\t\t\t\t\tconst r=await this.putArrayBuffer(p);\n\t\t\t\t\t\tcparams[ci++]=r;  // mem index\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error (\"callC: invalid object type passed in\");\n\t\t\t}\n\t\t}\n\n\t\treturn cparams;\n\t}\n\n\t// free the mallocs; copy array buffer data from malloc back to arraybuffer\n\tasync postCallC(cparams:(number|bigint)[], params:[string, ...(string|number|bigint|ArrayBuffer|URL)[]]) {\n\n\t\tlet ci=0;\n\t\tfor (let i=1; i < params.length; i++) {\n\t\t\tconst p=params[i];\n\t\t\tswitch (typeof p) {\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'bigint':\n\t\t\t\t\tci++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'string':\n\t\t\t\t\tawait this.callCImpl('free',[cparams[ci]])\n\t\t\t\t\tci++;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'object':\n\t\t\t\t\tif (p instanceof URL) {\n\t\t\t\t\t\tawait this.callCImpl('free',[cparams[ci]])\n\t\t\t\t\t\tci=ci+2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p instanceof ArrayBuffer) {\n\t\t\t\t\t\tconst u8=new Uint8Array(p);\n\t\t\t\t\t\tconst idx=cparams[ci] as number;\n\t\t\t\t\t\tfor (let j=0; j<u8.length; j++) \n\t\t\t\t\t\t\tu8[j]=this.mem8[idx+j];   // mod.mem8 is a Uint8Array view of the module's WebAssembly Memory\n\t\t\t\t\t\tawait this.callCImpl('free',[idx])\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t\tthrow new Error (\"postCallC: internal error A\");\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error (\"postCallC: internal error B\");\n\t\t\t}\n\t\t}\n\n\t\treturn cparams;\n\t}\n\n\t/*********************************************************************/\n\t/*********************************************************************/\n\n\t// convert a Javascript string into byte sequence that encodes the string using UTF8, or the requested codePage\n\tstringToU8(sin:string, codePage=codePageUTF8) {\n\n\t\tlet ru8:Uint8Array;\n\t\tif (codePage==codePageUTF8) {\n\t\t\tconst encoder = new TextEncoder();\n\t\t\tru8=encoder.encode(sin);\n\t\t}\n\t\telse if (codePage==codePage1252) {\n\t\t\tru8=new Uint8Array(sin.length);\n\t\t\tfor (let i = 0; i < sin.length; i++) {\n\t\t\t\tru8[i]=to1252(sin[i]);\n\t\t\t }\n\t\t}\n\t\telse if (codePage==codePageASCII) {\n\t\t\tru8=new Uint8Array(sin.length);\n\t\t\tfor (let i = 0; i < sin.length; i++) {\n\t\t\t\tconst r=toASCII(sin[i]);\n\t\t\t\tru8[i]=r;\n\t\t\t }\n\t\t}\n\t\telse {\n\t\t\tthrow new Error(\"unknown codePage: \"+codePage);\n\t\t}\n\n\t\treturn ru8;\n\t}\n\n\t// copy a string into existing buffer in the webassembly module memory as utf8 (or specified codePage)\n\t// result always null terminated\n\tcopyString(buffer:number, buffer_size:number, sin:string, codePage=codePageUTF8):void {\n\t\tif (buffer_size<1) throw new Error(\"copyString buffer_size must have length > 0 (room for terminating 0): \"+buffer_size);\n\t\t\n\t\tconst ru8=this.stringToU8(sin, codePage);\n\n\t\tlet i;\n\t\tfor (i=0; i<ru8.length && i<buffer_size-1; i++)\n\t\t\tthis.mem8[buffer+i]=ru8[i];\n\n\t\tthis.mem8[buffer+i]=0;\n\t}\n\n\t// allocate and copy a string into the webassembly module memory as utf8 (or the specified codePage)\n\tasync putString(sin:string, codePage=codePageUTF8) {\n\t\tconst ru8=this.stringToU8(sin, codePage);\n\t\tconst strIndex:number=await this.malloc(ru8.length+1);\n\t\tthis.mem8.set(ru8, strIndex);\n\t\tthis.mem8[strIndex+ru8.length]=0;\n\n\t\treturn strIndex;\n\t}\n\n\t// allocate and copy a Uint8Array into Wasm mod memory\n\tasync putU8(u8a:Uint8Array) {\n\t\tlet dest:number=await this.malloc(u8a.length); \n\t\tthis.mem8.set(u8a, dest);\n\t\treturn dest;\n\t}\n\n\tasync putArrayBuffer(ab:ArrayBuffer) {\n\t\tconst u8=new Uint8Array(ab);\n\t\treturn this.putU8(u8);\n\t}\n\n\t// given a url, load its contents, and stuff into Wasm memory similar to Unint8Array\n\tasync fetchAndPutURL(fnin:URL) {\n\n\t\tif (!(typeof fnin === 'object' && fnin instanceof URL))\n\t\t\tthrow new Error(\"fetchAndPutURL param must be URL\");\n\n\t\ttry {\n\t\t\tlet response=await fetch(fnin);\n\t\t\tlet buffer = await response.arrayBuffer();\n\t\t\tlet src = new Uint8Array(buffer);\n\t\t\tlet dest=await this.putU8(src);\n\t\t\treturn [dest, src.length];\n\t\t\t\n\t\t} catch(err:any) {\n\t\t\tconsole.log('fetchAndPutURL Error. URL: '+fnin+'\\n' + err + (err.stack ? \"\\n\" + err.stack : ''));\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tgetLong(idx:number): number {\n\t\tconst idx32=Math.floor(idx/4);\n\t\tif (idx32*4!=idx) throw new Error(\"getLong passed non long aligned address\")\n\t\tif (idx32<0 || idx32 >= this.mem32.length) throw new Error(\"invalid index passed to getLong: \"+idx+\", this.mem32.length: \"+this.mem32.length);\n\t\tconst long:number = this.mem32[idx32];\n\t\treturn long;\n\t}\n\t\n\tsetLong(idx:number, value:number) {\n        const idx32 = Math.floor(idx / 4);\n        if (idx32 * 4 != idx)\n            throw new Error(\"setLong passed non long aligned address\");\n        if (idx32 < 0 || idx32 >= this.mem32.length-1)\n            throw new Error(\"invalid index passed to setLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\n        this.mem32[idx32]=value;\n    }\n\n\tgetDouble(idx:number): number {\n\t\tconst idx64=Math.floor(idx/8);\n\t\tif (idx64*8!=idx) throw new Error(\"getLong passed non Float64 aligned address\")\n\t\tconst long:number = this.memD[idx64];\n\t\treturn long;\n\t}\n\n\tsetDouble(idx:number, value:number) {\n\t\tconst idx64=Math.floor(idx/8);\n\t\tif (idx64*8!=idx) throw new Error(\"setDouble passed non Float64 aligned address\")\n\t\tthis.memD[idx64]=value;\n\t}\n\n\tgetShort(idx:number): number {\n\t\tif (idx<0 || idx>= this.mem8.length) throw new Error(\"invalid index passed to getShort: \"+idx);\n\t\tconst short:number = this.mem8[idx]+this.mem8[idx+1]*256;\n\t\treturn short;\n\t}\n\n\t// get a string out of module memory\n\t// null terminated, up until max of (optional) len bytes\n\t// len may be longer than the number of characters, if characters are utf-8 encoded\n\tgetString(strIndex:number, len?:number, codePage=codePageUTF8): string {\n\t\tif (strIndex<0 || strIndex >= this.mem8.length) throw new Error(\"invalid strIndex passed to getString: \"+strIndex);\n\n\t\tif (len) {\n\t\t\tif (len<0 || len+strIndex > this.mem8.length) throw new Error(\"invalid len  passed to getString: \"+len);\n\t\t}\n\t\telse {\n\t\t\tlen = this.mem8.indexOf(0, strIndex);\n\t\t\tif (len==-1) throw new Error(\"string is not null terminated\");\n\t\t\tlen=len-strIndex;\n\t\t}\n\n\t\tlet encodeFormat;\n\t\tif (codePage==codePageUTF8) encodeFormat='utf-8';\n\t\telse if (codePage==codePage1252) encodeFormat='windows-1252';\n\t\telse throw new Error(\"Unsupported codePage: \"+codePage);\n\n\t\tconst td=new TextDecoder(encodeFormat);\n\t\tconst u8todecode=new Uint8Array(this.mem8.buffer, strIndex, len);\n\n // chrome throws exception when using TextDecoder on SharedArrayBuffer\n // BUT, instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error, so don't check directly\n\t\tif (this.mem8.buffer instanceof ArrayBuffer) { \n\t\t\tconst sout:string = td.decode(u8todecode);\n\t\t\treturn sout;\n\t\t}\n\t\telse {  // must be SharedArrayBuffer\n\t\t\tconst regularArrayBuffer = new ArrayBuffer(len);\n\t\t\tconst regularUint8Array = new Uint8Array(regularArrayBuffer);\n\t\t\tregularUint8Array.set(u8todecode);\n\t\t\tconst sout:string = td.decode(regularUint8Array);\n\t\t\treturn sout;\n\t\t}\n\t}\n\n\t// get a byte array out of module memory when passed in index to [size, dataptr]\n\tgetU8Arr(idx:number): Uint8Array {\n\t\tif (idx<0 || idx>= this.mem8.length) throw new Error(\"invalid index passed to getU8: \"+idx);\n\n\t\tconst rv = new Uint32Array( (this.mem8.slice(idx, idx+8)).buffer );\n\t\tlet size:number=rv[0];\n\t\tlet dataptr:number=rv[1];\n\n\t\tif (dataptr <0 || dataptr >= (this.mem8.length)) throw new Error(\"invalid idx.dataptr passed to getU8\")\n\t\tif (size <0 || size > (this.mem8.length-dataptr)) throw new Error(\"invalid idx.size passed to  getU8\")\n\n\t\tconst u8=this.mem8.slice(dataptr, dataptr+size);\n\t\treturn u8;\n\t}\n\n\t// get a int32 array out of module memory when passed in index to [size, dataptr]\n\tgetU32Arr(idx:number): Uint32Array {\n\t\tif (idx<0 || idx>= this.mem8.length) throw new Error(\"invalid index passed to getU32: \"+idx);\n\n\t\tconst rv = new Uint32Array( (this.mem8.slice(idx, idx+8)).buffer );\n\t\tlet size:number=rv[0];\n\t\tlet dataptr:number=rv[1];\n\n\t\tif (dataptr <0 || dataptr >= (this.mem8.length)) throw new Error(\"invalid idx.dataptr passed to getU32\")\n\t\tif (size <0 || size > (this.mem8.length-dataptr)) throw new Error(\"invalid idx.size passed to  getU32\")\n\n\t\tif (size%4!=0) throw new Error(\"idx.size is not an integer number of 32 bit words\");\n\n\t\tconst u32 = new Uint32Array( (this.mem8.slice(dataptr, dataptr+size)).buffer );\n\t\treturn u32;\n\t}\n}\n","export class twrFloatUtil {\n    mod;\n    constructor(mod) {\n        this.mod = mod;\n    }\n    atod(strptr, len) {\n        const str = this.mod.getString(strptr, len);\n        const upper = str.trimStart().toUpperCase();\n        if (upper == \"INF\" || upper == \"+INF\" || upper == \"INFINITY\" || upper == \"+INFINITY\")\n            return Number.POSITIVE_INFINITY;\n        else if (upper == \"-INF\" || upper == \"-INFINITY\")\n            return Number.NEGATIVE_INFINITY;\n        else {\n            // allow D for exponent -- old microsoft format they still support in _fctv and I support in my awbasic\n            // parseFloat will handle 'Infinity' and'-Infinity' literal\n            // parseFloat appears to be case sensitive when parsing 'Infinity'\n            // parseFloat ignores leading whitespace\n            // parseFloat() is more lenient than Number() because it ignores trailing invalid characters\n            const r = Number.parseFloat(str.replaceAll('D', 'e').replaceAll('d', 'e'));\n            return r;\n        }\n    }\n    dtoa(buffer, buffer_size, value, max_precision) {\n        if (max_precision == -1) {\n            const r = value.toString();\n            this.mod.copyString(buffer, buffer_size, r);\n        }\n        else {\n            let r = value.toString();\n            if (r.length > max_precision)\n                r = value.toPrecision(max_precision);\n            this.mod.copyString(buffer, buffer_size, r);\n        }\n    }\n    toFixed(buffer, buffer_size, value, decdigits) {\n        const r = value.toFixed(decdigits);\n        this.mod.copyString(buffer, buffer_size, r);\n    }\n    toExponential(buffer, buffer_size, value, decdigits) {\n        const r = value.toExponential(decdigits);\n        this.mod.copyString(buffer, buffer_size, r);\n    }\n    // emulates the MS C lib function _fcvt_s, but doesn't support all ranges of number.\n    // Number.toFixed() has a max size of 100 fractional digits,  and values must be less than 1e+21\n    // Negative exponents must be now smaller than 1e-99\n    // fully-function C version also int he source, but this is the version enabled by default\n    fcvtS(buffer, // char *\n    sizeInBytes, //size_t\n    value, // double\n    fracpart_numdigits, //int\n    dec, // int *\n    sign // int *\n    ) {\n        if (buffer == 0 || sign == 0 || dec == 0 || sizeInBytes < 1)\n            return 1;\n        let digits;\n        let decpos;\n        let s = 0; // default to positive\n        if (Number.isNaN(value)) { /* nan */\n            digits = \"1#QNAN00000000000000000000000000000\".slice(0, fracpart_numdigits + 1);\n            decpos = 1;\n        }\n        else if (!Number.isFinite(value)) { /* infinity */\n            digits = \"1#INF00000000000000000000000000000\".slice(0, fracpart_numdigits + 1);\n            decpos = 1;\n        }\n        else if (value == 0) {\n            digits = \"000000000000000000000000000000000000\".slice(0, fracpart_numdigits);\n            decpos = 0;\n        }\n        else {\n            if (value < 0) {\n                s = 1; // negative\n                value = Math.abs(value);\n            }\n            if (fracpart_numdigits > 100 || value > 1e+21 || value < 1e-99) {\n                this.mod.copyString(buffer, sizeInBytes, \"\");\n                this.mod.mem32[dec] = 0;\n                return 1;\n            }\n            const roundValStr = value.toFixed(fracpart_numdigits);\n            let [intPart = \"\", fracPart = \"\"] = roundValStr.split('.');\n            if (intPart == \"0\")\n                intPart = \"\";\n            if (intPart.length > 0) { // has integer part\n                decpos = intPart.length;\n                digits = intPart + fracPart;\n            }\n            else { // only a fraction\n                digits = fracPart.replace(/^0+/, \"\"); // remove leading zeros\n                decpos = digits.length - fracPart.length;\n            }\n        }\n        if (sizeInBytes - 1 < digits.length)\n            return 1;\n        this.mod.copyString(buffer, sizeInBytes, digits);\n        this.mod.setLong(dec, decpos);\n        this.mod.setLong(sign, s);\n        return 0;\n        /*\n        this version 'works' with larger numbers than using toFixed, but doesn't round correctly\n\n        let decpos=0;\n        let digits:string;\n        if (value!=0) decpos=Math.floor(Math.log10(value))+1;\n    \n        if (decpos>0) { // has integer part\n            const intlen=Math.max(decpos, 0);\n            console.log(\"intlen=\",intlen, \"decpos=\",decpos);\n            const [nonExponent, exponent=0] = value.toPrecision(intlen+fracpart_numdigits).split('e');\n            digits=nonExponent.replace('.', '');\n            digits=digits.replace(/^0+/,\"\");  // remove leading zeros\n        }\n        else { // only a fraction\n            const intpart=Math.trunc(value);\n            const fracpart=value-intpart;\n            const prec=fracpart_numdigits- (-decpos);\n            console.log(\"prec=\",prec);\n            if (prec<1) {\n                digits=\"\";\n            }\n            else {\n                const [nonExponent, exponent=0] = fracpart.toPrecision(prec).split('e');\n                digits=nonExponent.replace('.', '');\n                digits=digits.replace(/^0+/,\"\");\n            }\n        }\n\n        console.log(\"fcvtS value\",value,\"fracpart_numdigits\",fracpart_numdigits);\n        console.log('digits=',digits);\n        console.log('dec=',decpos);\n        console.log(\"sign=\",s);\n    */\n    }\n}\n//# sourceMappingURL=twrfloat.js.map","\nimport {twrWasmModuleBase} from \"./twrmodbase.js\"\n\nexport class twrFloatUtil {\n    mod: twrWasmModuleBase;\n\n    constructor(mod: twrWasmModuleBase) {\n        this.mod=mod;\n    }\n\n    atod(strptr:number, len:number):number {\n        const str=this.mod.getString(strptr, len);\n\n        const upper=str.trimStart().toUpperCase();\n        if (upper==\"INF\" || upper==\"+INF\" || upper==\"INFINITY\" || upper==\"+INFINITY\")\n            return Number.POSITIVE_INFINITY;\n        else if (upper==\"-INF\" || upper==\"-INFINITY\")\n            return Number.NEGATIVE_INFINITY\n        else {\n            // allow D for exponent -- old microsoft format they still support in _fctv and I support in my awbasic\n\t\t\t\t// parseFloat will handle 'Infinity' and'-Infinity' literal\n\t\t\t\t// parseFloat appears to be case sensitive when parsing 'Infinity'\n\t\t\t\t// parseFloat ignores leading whitespace\n\t\t\t\t// parseFloat() is more lenient than Number() because it ignores trailing invalid characters\n            const r=Number.parseFloat(str.replaceAll('D','e').replaceAll('d','e'));\n            return r;\n        }\n    }\n\n    dtoa(buffer:number, buffer_size:number, value:number, max_precision:number):void {\n        if (max_precision==-1) {\n            const r=value.toString();\n            this.mod.copyString(buffer, buffer_size, r);\n        }\n        else {\n            let r=value.toString();\n            if (r.length>max_precision)\n                r=value.toPrecision(max_precision);\n            this.mod.copyString(buffer, buffer_size, r);\n        }\n    }\n\n    toFixed(buffer:number, buffer_size:number, value:number, decdigits:number):void {\n        const r=value.toFixed(decdigits);\n        this.mod.copyString(buffer, buffer_size, r);\n    }\n\n    toExponential(buffer:number, buffer_size:number, value:number, decdigits:number):void {\n        const r=value.toExponential(decdigits);\n        this.mod.copyString(buffer, buffer_size, r);\n    }\n\n    // emulates the MS C lib function _fcvt_s, but doesn't support all ranges of number.\n    // Number.toFixed() has a max size of 100 fractional digits,  and values must be less than 1e+21\n    // Negative exponents must be now smaller than 1e-99\n    // fully-function C version also int he source, but this is the version enabled by default\n    fcvtS(\n        buffer:number,  // char *\n        sizeInBytes:number, //size_t\n        value:number,  // double\n        fracpart_numdigits:number,  //int\n        dec:number,  // int *\n        sign:number  // int *\n     ):number {\n\n        if (buffer==0 ||sign==0 || dec==0 || sizeInBytes<1) return 1;\n\n        let digits:string;\n        let decpos:number;\n        let s=0; // default to positive\n\n\n        if (Number.isNaN(value))  { /* nan */\n            digits=\"1#QNAN00000000000000000000000000000\".slice(0, fracpart_numdigits+1);\n            decpos=1;\n        }\n        else if (!Number.isFinite(value)) {    /* infinity */\n            digits=\"1#INF00000000000000000000000000000\".slice(0, fracpart_numdigits+1);\n            decpos=1;\n        }\n        else if (value==0) {  \n            digits=\"000000000000000000000000000000000000\".slice(0,fracpart_numdigits);\n            decpos=0;\n        }\n        \n        else {\n\n            if (value<0) {\n                s=1;  // negative\n                value=Math.abs(value);\n            }\n\n            if (fracpart_numdigits>100 || value > 1e+21 || value < 1e-99) {  \n                this.mod.copyString(buffer, sizeInBytes, \"\");\n                this.mod.mem32[dec]=0;\n                return 1;\n            }\n\n            const roundValStr=value.toFixed(fracpart_numdigits);\n            let [intPart=\"\", fracPart=\"\"] = roundValStr.split('.');\n            if (intPart==\"0\") intPart=\"\";\n\n            if (intPart.length>0) { // has integer part\n                decpos=intPart.length;\n                digits=intPart+fracPart;\n            }\n            else { // only a fraction\n                digits=fracPart.replace(/^0+/,\"\");  // remove leading zeros\n                decpos=digits.length-fracPart.length;\n            }\n        }\n\n        if (sizeInBytes-1 < digits.length) return 1; \n        this.mod.copyString(buffer, sizeInBytes, digits);\n        this.mod.setLong(dec, decpos);\n        this.mod.setLong(sign, s);\n\n        return 0;\n\n        /*\n        this version 'works' with larger numbers than using toFixed, but doesn't round correctly\n\n        let decpos=0;\n        let digits:string;\n        if (value!=0) decpos=Math.floor(Math.log10(value))+1;\n    \n        if (decpos>0) { // has integer part\n            const intlen=Math.max(decpos, 0);\n            console.log(\"intlen=\",intlen, \"decpos=\",decpos);\n            const [nonExponent, exponent=0] = value.toPrecision(intlen+fracpart_numdigits).split('e');\n            digits=nonExponent.replace('.', '');\n            digits=digits.replace(/^0+/,\"\");  // remove leading zeros\n        }\n        else { // only a fraction\n            const intpart=Math.trunc(value);\n            const fracpart=value-intpart;\n            const prec=fracpart_numdigits- (-decpos);\n            console.log(\"prec=\",prec);\n            if (prec<1) {\n                digits=\"\";\n            }\n            else {\n                const [nonExponent, exponent=0] = fracpart.toPrecision(prec).split('e');\n                digits=nonExponent.replace('.', '');\n                digits=digits.replace(/^0+/,\"\");\n            }\n        }\n\n        console.log(\"fcvtS value\",value,\"fracpart_numdigits\",fracpart_numdigits);\n        console.log('digits=',digits);\n        console.log('dec=',decpos);\n        console.log(\"sign=\",s);\n    */\n\n\n    }\n}","// these match C #defines in locale.h\nexport const codePageASCII = 0;\nexport const codePage1252 = 1252;\nexport const codePageUTF8 = 65001;\nexport const codePageUTF32 = 12000;\nexport class twrCodePageToUnicodeCodePoint {\n    decoderUTF8 = new TextDecoder('utf-8');\n    decoder1252 = new TextDecoder('windows-1252');\n    convert(c, codePage) {\n        let outstr;\n        if (codePage == codePageUTF8) {\n            outstr = this.decoderUTF8.decode(new Uint8Array([c]), { stream: true });\n        }\n        else if (codePage == codePage1252) {\n            outstr = this.decoder1252.decode(new Uint8Array([c]));\n        }\n        else if (codePage == codePageASCII) {\n            if (c > 127)\n                outstr = \"\";\n            else\n                outstr = String.fromCharCode(c);\n        }\n        else if (codePage == codePageUTF32) {\n            outstr = String.fromCodePoint(c);\n        }\n        else {\n            throw new Error(\"unsupported CodePage: \" + codePage);\n        }\n        return outstr.codePointAt(0) || 0;\n    }\n}\nconst cpTranslate = new twrCodePageToUnicodeCodePoint();\nexport function twrUnicodeCodePointToCodePageImpl(outstr, cp, codePage) {\n    return noasyncCopyString(this, outstr, String.fromCodePoint(cp), codePage);\n}\nexport function twrUserLanguageImpl() {\n    return noasyncPutString(this, navigator.language, codePageASCII);\n}\n// checks if the character c, when converted to a string, is matched by the passed in regexp string \n// utf-8 version not needed since this function is used for a single byte ('char'), \n// and non-ascii range utf-8 single byte are not valid\nexport function twrRegExpTest1252Impl(regexpStrIdx, c) {\n    const regexpStr = this.getString(regexpStrIdx);\n    const regexp = new RegExp(regexpStr, 'u');\n    const cstr = cpTranslate.decoder1252.decode(new Uint8Array([c]));\n    const r = regexp.test(cstr);\n    if (r)\n        return 1;\n    else\n        return 0;\n}\nexport function to1252(instr) {\n    if (instr.codePointAt(0) == 8239)\n        return 32; // turn narrow-no-break-space into space\n    // this first switch statment fixes what appears to be a bug in safari 15.6.1 (17613.3.9.1.16) (comparisons to the character string fail)\n    let cp = instr.codePointAt(0) || 0;\n    switch (cp) {\n        case 338: return 0x8C;\n        case 339: return 0x9C;\n        case 352: return 0x8A;\n        case 353: return 0x9A;\n        case 376: return 0x9F;\n        case 381: return 0x8E;\n        case 382: return 0x9E;\n        case 402: return 0x83;\n        case 710: return 0x88;\n    }\n    switch (instr.normalize()) {\n        case '€': return 0x80;\n        case '‚': return 0x82;\n        case 'ƒ': return 0x83;\n        case '„': return 0x84;\n        case '…': return 0x85;\n        case '†': return 0x86;\n        case '‡': return 0x87;\n        case 'ˆ': return 0x88;\n        case '‰': return 0x89;\n        case 'Š': return 0x8A;\n        case '‹': return 0x8B;\n        case 'Œ': return 0x8C;\n        case 'Ž': return 0x8E;\n        case '‘': return 0x91;\n        case '’': return 0x92;\n        case '“': return 0x93;\n        case '”': return 0x94;\n        case '•': return 0x95;\n        case '–': return 0x96;\n        case '—': return 0x97;\n        case '˜': return 0x98;\n        case '™': return 0x99;\n        case 'š': return 0x9A;\n        case '›': return 0x9B;\n        case 'œ': return 0x9C;\n        case 'ž': return 0x9E;\n        case 'Ÿ': return 0x9F;\n    }\n    if (cp > 255) {\n        console.log(\"twr-wasm.to1252(): unable to convert: \", instr, cp);\n        cp = 0;\n    }\n    return cp;\n}\nexport function toASCII(instr) {\n    if (instr == 'ƒ')\n        return 102; // lowercase 'f'\n    if (instr.codePointAt(0) == 8239)\n        return 32; // turn narrow-no-break-space into space\n    let cp = instr.codePointAt(0) || 0;\n    if (cp > 127)\n        return 63; // ASCII for \"?\"\n    return cp;\n}\n// utf-8 version not needed since this function is used for a single byte ('char'), \n// and non-ascii range utf-8 single byte are not valid\nexport function twrToLower1252Impl(c) {\n    const cstr = cpTranslate.decoder1252.decode(new Uint8Array([c]));\n    const regexp = new RegExp(\"^\\\\p{Letter}$\", 'u');\n    if (regexp.test(cstr)) {\n        const r = to1252(cstr.toLocaleLowerCase());\n        //console.log(\"twrToLower1252Impl: isLetter\", c, cstr, cstr.codePointAt(0), cstr.toLocaleLowerCase(), cstr.toLocaleLowerCase().codePointAt(0), r);\n        return r;\n    }\n    else {\n        //console.log(\"twrToLower1252Impl: isNOTLetter\", c, cstr, cstr.codePointAt(0));\n        return c;\n    }\n}\n//utf-8 version not needed since this function is used for a single byte ('char'), \n// and non-ascii range utf-8 single byte are not valid\nexport function twrToUpper1252Impl(c) {\n    const cstr = cpTranslate.decoder1252.decode(new Uint8Array([c]));\n    if (cstr.codePointAt(0) == 402)\n        return c; // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is ƒ\n    if (cstr.codePointAt(0) == 181)\n        return c; // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is µ\n    if (cstr.codePointAt(0) == 223)\n        return c; // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is ß'\n    if (cstr == \"µ\")\n        return c; // upper case version doesn't fit in 1252\n    if (cstr == 'ƒ')\n        return c; // upper case version doesn't fit in 1252\n    if (cstr == 'ß')\n        return c; // toLocaleUpperCase() will convert beta to SS\n    const regexp = new RegExp(\"^\\\\p{Letter}$\", 'u');\n    if (regexp.test(cstr)) {\n        return to1252(cstr.toLocaleUpperCase());\n    }\n    else {\n        return c;\n    }\n}\nexport function twrStrcollImpl(lhs, rhs, codePage) {\n    const lhStr = this.getString(lhs, undefined, codePage);\n    const rhStr = this.getString(rhs, undefined, codePage);\n    // c strcmp(): A positive integer if str1 is greater than str2.\n    // 1 if string 1 (lh) comes after string 2 (rh)\n    const collator = new Intl.Collator();\n    const r = collator.compare(lhStr, rhStr);\n    return r;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n//struct tm {\n//\tint\ttm_sec;\t\t/* seconds after the minute [0-60] */\n//\tint\ttm_min;\t\t/* minutes after the hour [0-59] */\n//\tint\ttm_hour;\t\t/* hours since midnight [0-23] */\n//\tint\ttm_mday;\t\t/* day of the month [1-31] */\n//\tint\ttm_mon;\t\t/* months since January [0-11] */\n//\tint\ttm_year;\t\t/* years since 1900 */\n//\tint\ttm_wday;\t\t/* days since Sunday [0-6] */\n//\tint\ttm_yday;\t\t/* days since January 1 [0-365] */\n//\tint\ttm_isdst;\t/* Daylight Saving Time flag */\n//\tlong\ttm_gmtoff;\t/* offset from UTC in seconds */\n//\tchar\t*tm_zone;\t/* timezone abbreviation */\n//};\n// fill in struct tm\n// epcohSecs as 32bit int will overflow January 19, 2038. \nexport function twrTimeTmLocalImpl(tmIdx, epochSecs) {\n    const d = new Date(epochSecs * 1000);\n    this.setLong(tmIdx, d.getSeconds());\n    this.setLong(tmIdx + 4, d.getMinutes());\n    this.setLong(tmIdx + 8, d.getHours());\n    this.setLong(tmIdx + 12, d.getDate());\n    this.setLong(tmIdx + 16, d.getMonth());\n    this.setLong(tmIdx + 20, d.getFullYear() - 1900);\n    this.setLong(tmIdx + 24, d.getDay());\n    this.setLong(tmIdx + 28, getDayOfYear(d));\n    this.setLong(tmIdx + 32, isDst());\n    this.setLong(tmIdx + 36, -d.getTimezoneOffset() * 60);\n    this.setLong(tmIdx + 40, noasyncPutString(this, getTZ(d), codePageASCII));\n}\nfunction getDayOfYear(date) {\n    const start = new Date(date.getFullYear(), 0, 1);\n    const diff = date.getTime() - start.getTime(); // Difference in milliseconds\n    const oneDay = 1000 * 60 * 60 * 24; // Number of milliseconds in one day\n    const day = Math.floor(diff / oneDay);\n    return day;\n}\nfunction isDst() {\n    const timeString = new Date().toLocaleTimeString('en-US', { timeZoneName: 'long' });\n    if (timeString.includes('Daylight')) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nfunction getTZ(date) {\n    const timeZone = date.toLocaleTimeString('en-US', { timeZoneName: 'short' }).split(' ').pop();\n    return timeZone ? timeZone : \"UTC\";\n}\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\nfunction setAndPutString(mod, idx, sin, codePage) {\n    const stridx = noasyncPutString(mod, sin, codePage);\n    mod.setLong(idx, stridx);\n}\n// JS string into the webassembly module memory.  \n// Does not verify outbuf length. \n// Encode the Wasm string using codePage\n// Does NOT zero terminate string\nfunction noasyncCopyString(mod, outbuf, sin, codePage) {\n    const ru8 = mod.stringToU8(sin, codePage);\n    mod.mem8.set(ru8, outbuf);\n    return ru8.length;\n}\n// allocate and copy a JS string into the webassembly module memory, encode the Wasm string using codePage\nfunction noasyncPutString(mod, sin, codePage) {\n    const ru8 = mod.stringToU8(sin, codePage);\n    const malloc = mod.exports.malloc;\n    const strIndex = malloc(ru8.length + 1);\n    mod.mem8.set(ru8, strIndex);\n    mod.mem8[strIndex + ru8.length] = 0;\n    return strIndex;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n//struct lconv {\n//\tchar\t*decimal_point;   \t\t0\n//\tchar\t*thousands_sep;\t\t\t4\n//\tchar\t*grouping;\t\t\t\t\t8\n//\tchar\t*int_curr_symbol;\t\t\t12\n//\tchar\t*currency_symbol;\t\t\t16\n//\tchar\t*mon_decimal_point;\t\t20\n//\tchar\t*mon_thousands_sep;\t\t24\n//\tchar\t*mon_grouping;\t\t\t\t28\n//\tchar\t*positive_sign;\t\t\t32\n//\tchar\t*negative_sign;\t\t\t36\n//\tchar\tint_frac_digits;\t\t\t40\n//\tchar\tfrac_digits;\t\t\t\t44\n//\tchar\tp_cs_precedes;\t\t\t\t48\n//\tchar\tp_sep_by_space;\t\t\t52\n//\tchar\tn_cs_precedes;\t\t\t\t56\n//\tchar\tn_sep_by_space;\t\t\t60\n//\tchar\tp_sign_posn;\t\t\t\t64\n//\tchar\tn_sign_posn;\t\t\t\t68\n//};\nexport function twrUserLconvImpl(lconvIdx, codePage) {\n    const locDec = getLocaleDecimalPoint();\n    const locSep = getLocaleThousandsSeparator();\n    setAndPutString(this, lconvIdx + 0, locDec, codePage);\n    setAndPutString(this, lconvIdx + 4, locSep, codePage);\n    setAndPutString(this, lconvIdx + 20, locDec, codePage);\n    setAndPutString(this, lconvIdx + 24, locSep, codePage);\n    setAndPutString(this, lconvIdx + 24, locSep, codePage);\n    setAndPutString(this, lconvIdx + 24, locSep, codePage);\n    setAndPutString(this, lconvIdx + 32, \"+\", codePage);\n    setAndPutString(this, lconvIdx + 36, \"-\", codePage);\n    setAndPutString(this, lconvIdx + 12, getLocalCurrencySymbol(), codePage);\n    setAndPutString(this, lconvIdx + 16, getLocalCurrencySymbol(), codePage);\n}\nfunction getLocaleDecimalPoint() {\n    const formatter = new Intl.NumberFormat();\n    //console.log(\"dec resolvedOptions\", formatter.resolvedOptions());\n    // Format a test number to find out the decimal point.\n    const formattedNumber = formatter.format(1.1);\n    //console.log(\"dec formattedNumber\", formattedNumber);\n    // Find the character between the numeric parts.\n    const decimalPoint = formattedNumber.replace(/[0-9]/g, '').charAt(0);\n    return decimalPoint;\n}\nfunction getLocaleThousandsSeparator() {\n    const formatter = new Intl.NumberFormat(undefined, {\n        minimumFractionDigits: 0 // Ensure no decimal part interferes\n    });\n    // Format a test number to include a thousands separator.\n    const formattedNumber = formatter.format(1000);\n    //console.log(\"sep formattedNumber\", formattedNumber);\n    // Extract the thousands separator by removing numeric characters and possible decimal points.\n    // This may need adjustment depending on whether other characters are present.\n    let thousandsSeparator = formattedNumber.replace(/[0-9]/g, '').charAt(0); // Assumes separator is the first character.\n    //console.log(\"sep code\",  thousandsSeparator.codePointAt(0));\n    return thousandsSeparator;\n}\n// this doesn't work, localeCurrency is not correct\nfunction getLocaleCurrencyDecimalPoint() {\n    // Create an initial NumberFormat object to detect the locale's currency\n    const tempFormatter = new Intl.NumberFormat(undefined, { style: 'currency', currency: 'USD' });\n    const localeCurrency = tempFormatter.resolvedOptions().currency;\n    const formatter = new Intl.NumberFormat(undefined, {\n        style: 'currency',\n        currency: localeCurrency\n    });\n    // Format a test number to find out the decimal point.\n    const formattedNumber = formatter.format(1.1);\n    // Find the character between the numeric parts.\n    // char(0) is the currency symbol\n    const decimalPoint = formattedNumber.replace(/[0-9]/g, '').charAt(1);\n    return decimalPoint;\n}\nfunction getLocalCurrencySymbol() {\n    switch (navigator.language) {\n        case \"en-US\":\n        case \"en-CA\":\n        case \"fr-CA\":\n        case \"en-AU\":\n        case \"es-MX\":\n        case \"es-AR\":\n        case \"es-CL\":\n        case \"es-CO\":\n        case \"es-EC\":\n        case \"en-GY\":\n        case \"nl-SR\":\n        case \"es-UY\":\n        case \"en-BZ\":\n        case \"es-SV\":\n        case \"es-PA\":\n            return \"$\";\n        case \"es-BO\":\n        case \"es-VE\":\n            return \"Bs.\";\n        case \"es-PY\":\n            return \"₲\";\n        case \"es-PE\":\n            return \"S/\";\n        case \"es-CR\":\n            return \"₡\";\n        case \"es-GT\":\n            return \"Q\";\n        case \"es-HN\":\n            return \"L\";\n        case \"es-NI\":\n            return \"C$\";\n        case \"en-GB\":\n            return \"£\";\n        case \"en-IE\":\n        case \"de-DE\":\n        case \"fr-FR\":\n        case \"de-AT\":\n        case \"nl-BE\":\n        case \"fr-BE\":\n        case \"el-CY\":\n        case \"et-EE\":\n        case \"fi-FI\":\n        case \"sv-FI\":\n        case \"el-GR\":\n        case \"it-IT\":\n        case \"lv-LV\":\n        case \"lt-LT\":\n        case \"fr-LU\":\n        case \"de-LU\":\n        case \"lb-LU\":\n        case \"mt-MT\":\n        case \"nl-NL\":\n        case \"pt-PT\":\n        case \"sk-SK\":\n        case \"sl-SI\":\n        case \"es-ES\":\n            return \"€\";\n        case \"ja-JP\":\n            return \"¥\";\n        case \"zh-CN\":\n            return \"¥\";\n        case \"de-CH\":\n        case \"fr-CH\":\n        case \"it-CH\":\n            return \"CHF\";\n        case \"sv-SE\":\n        case \"da-DK\":\n        case \"nb-NO\":\n            return \"kr\";\n        case \"ru-RU\":\n            return \"₽\";\n        case \"ko-KR\":\n            return \"₩\";\n        case \"en-IN\":\n            return \"₹\";\n        case \"pt-BR\":\n            return \"R$\";\n        case \"he-IL\":\n            return \"₪\";\n        case \"tr-TR\":\n            return \"₺\";\n        default:\n            return \"\";\n    }\n}\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/*\nstruct locale_dtnames {\n    const char* day[7];\n    const char* abday[7];\n    const char* month[12];\n    const char* abmonth[12];\n    const char* ampm[2];\n};\n*/\nexport function twrGetDtnamesImpl(codePage) {\n    const malloc = this.exports.malloc;\n    const dtnamesStructIdx = malloc(40 * 4);\n    for (let i = 0; i < 7; i++)\n        setAndPutString(this, dtnamesStructIdx + i * 4, getLocalizedDayName(i, 'long'), codePage);\n    for (let i = 0; i < 7; i++)\n        setAndPutString(this, dtnamesStructIdx + (i + 7) * 4, getLocalizedDayName(i, 'short'), codePage);\n    for (let i = 0; i < 12; i++)\n        setAndPutString(this, dtnamesStructIdx + (i + 14) * 4, getLocalizedMonthNames(i, 'long'), codePage);\n    for (let i = 0; i < 12; i++)\n        setAndPutString(this, dtnamesStructIdx + (i + 14 + 12) * 4, getLocalizedMonthNames(i, 'short'), codePage);\n    setAndPutString(this, dtnamesStructIdx + (0 + 14 + 24) * 4, getLocalizedAM(), codePage);\n    setAndPutString(this, dtnamesStructIdx + (1 + 14 + 24) * 4, getLocalizedPM(), codePage);\n    return dtnamesStructIdx;\n}\nfunction getLocalizedDayName(n, weekdayType) {\n    // Create a Date object for the desired day of the week\n    const date = new Date();\n    date.setDate(date.getDate() - date.getDay() + n);\n    // Create an Intl.DateTimeFormat object with the desired locale and options\n    const formatter = new Intl.DateTimeFormat(undefined, { weekday: weekdayType });\n    // Format the date to get the full day name\n    return formatter.format(date);\n}\nfunction getLocalizedMonthNames(n, monthType) {\n    const formatter = new Intl.DateTimeFormat(undefined, { month: monthType });\n    const date = new Date(2000, n, 1);\n    return formatter.format(date);\n}\nfunction getLocalizedAM() {\n    // Create a Date object for a time in the morning\n    const morningDate = new Date(2000, 0, 1, 9, 0, 0);\n    // Create an Intl.DateTimeFormat object with the desired locale and options\n    const formatter = new Intl.DateTimeFormat(undefined, {\n        hour: 'numeric',\n        hour12: true\n    });\n    // Format the date and get the parts\n    const formattedParts = formatter.formatToParts(morningDate);\n    // Find the part of the formatted string that corresponds to the day period (AM/PM)\n    const dayPeriodPart = formattedParts.find(part => part.type === 'dayPeriod');\n    return dayPeriodPart ? dayPeriodPart.value : '';\n}\nfunction getLocalizedPM() {\n    // Create a Date object for a time in the afternoon\n    const afternoonDate = new Date(2000, 0, 1, 15, 0, 0);\n    // Create an Intl.DateTimeFormat object with the desired locale and options\n    const formatter = new Intl.DateTimeFormat(undefined, {\n        hour: 'numeric',\n        hour12: true\n    });\n    // Format the date and get the parts\n    const formattedParts = formatter.formatToParts(afternoonDate);\n    // Find the part of the formatted string that corresponds to the day period (AM/PM)\n    const dayPeriodPart = formattedParts.find(part => part.type === 'dayPeriod');\n    return dayPeriodPart ? dayPeriodPart.value : '';\n}\n//# sourceMappingURL=twrlocale.js.map","import {twrWasmModuleBase} from \"./twrmodbase.js\"\n\n\n// these match C #defines in locale.h\nexport const codePageASCII=0;\nexport const codePage1252=1252;\nexport const codePageUTF8=65001;\nexport const codePageUTF32=12000;\n\nexport class twrCodePageToUnicodeCodePoint {\n\tdecoderUTF8 = new TextDecoder('utf-8');\n\tdecoder1252 = new TextDecoder('windows-1252');\n\n\tconvert(c:number, codePage:number) {\n\t\tlet outstr:string;\n\t\tif (codePage==codePageUTF8) {\n\t\t\toutstr=this.decoderUTF8.decode(new Uint8Array([c]), {stream: true});\n\t\t}\n\t\telse if (codePage==codePage1252) {\n\t\t\toutstr = this.decoder1252.decode(new Uint8Array([c]));\n\t\t}\n\t\telse if (codePage==codePageASCII) {\n\t\t\tif (c>127) outstr=\"\";\n\t\t\telse outstr=String.fromCharCode(c);\n\t\t}\n\t\telse if (codePage==codePageUTF32) {\n\t\t\toutstr=String.fromCodePoint(c);\n\t\t}\n\t\telse {\n\t\t\tthrow new Error(\"unsupported CodePage: \"+codePage)\n\t\t}\n\n\t\treturn outstr.codePointAt(0) || 0;\n\t}\n}\n\nconst cpTranslate = new twrCodePageToUnicodeCodePoint();\n\nexport function twrUnicodeCodePointToCodePageImpl(this: twrWasmModuleBase, outstr:number, cp:number, codePage:number) {\n\treturn noasyncCopyString(this, outstr, String.fromCodePoint(cp), codePage);\n}\n\nexport function twrUserLanguageImpl(this: twrWasmModuleBase) {\n\n\treturn noasyncPutString(this, navigator.language, codePageASCII);\n\n}\n\n// checks if the character c, when converted to a string, is matched by the passed in regexp string \n// utf-8 version not needed since this function is used for a single byte ('char'), \n// and non-ascii range utf-8 single byte are not valid\nexport function twrRegExpTest1252Impl(this: twrWasmModuleBase, regexpStrIdx:number, c:number) {\n\n\tconst regexpStr=this.getString(regexpStrIdx);\n\tconst regexp=new RegExp(regexpStr, 'u');\n\tconst cstr:string = cpTranslate.decoder1252.decode(new Uint8Array([c]));\n\tconst r=regexp.test(cstr);\n\tif (r) return 1; else return 0;\n\n}\n\nexport function to1252(instr:string) {\n\n\tif (instr.codePointAt(0)==8239) return 32;  // turn narrow-no-break-space into space\n\n\n\t// this first switch statment fixes what appears to be a bug in safari 15.6.1 (17613.3.9.1.16) (comparisons to the character string fail)\n\tlet cp=instr.codePointAt(0) || 0;\n\n\tswitch(cp) {\n\t\tcase 338: return 0x8C;\n\t\tcase 339: return 0x9C;\n\t\tcase 352: return 0x8A;\n\t\tcase 353: return 0x9A;\n\t\tcase 376: return 0x9F;\n\t\tcase 381: return 0x8E;\n\t\tcase 382: return 0x9E;\n\t\tcase 402: return 0x83;\n\t\tcase 710: return 0x88;\n\t}\n\n\tswitch (instr.normalize()) {\n\t   case '€': return 0x80;\n\t   case '‚': return 0x82;\n\t   case 'ƒ': return 0x83;\n\t   case '„': return 0x84;\n\t   case '…': return 0x85;\n\t   case '†': return 0x86;\n\t   case '‡': return 0x87;\n\t   case 'ˆ': return 0x88;\n\t   case '‰': return 0x89;\n\t   case 'Š': return 0x8A; \n\t\tcase '‹': return 0x8B;\n\t   case 'Œ': return 0x8C;\n\t   case 'Ž': return 0x8E;\n\t   case '‘': return 0x91;\n\t   case '’': return 0x92;\n\t   case '“': return 0x93;\n\t   case '”': return 0x94;\n\t   case '•': return 0x95;\n\t   case '–': return 0x96;\n\t   case '—': return 0x97;\n\t   case '˜': return 0x98;\n\t   case '™': return 0x99;\n\t   case 'š': return 0x9A;\n\t   case '›': return 0x9B;\n\t   case 'œ': return 0x9C;\n\t   case 'ž': return 0x9E;\n\t   case 'Ÿ': return 0x9F;\n\t}\n\t\n\tif (cp>255) {\n\t\tconsole.log(\"twr-wasm.to1252(): unable to convert: \", instr, cp);\n\t\tcp=0;\n\t}\n\n\treturn cp;\n}\n\nexport function toASCII(instr:string) {\n\tif (instr=='ƒ') return 102; // lowercase 'f'\n\tif (instr.codePointAt(0)==8239) return 32;  // turn narrow-no-break-space into space\n\n\tlet cp=instr.codePointAt(0) || 0;\n\tif (cp>127) return 63; // ASCII for \"?\"\n\treturn cp;\n}\n\n// utf-8 version not needed since this function is used for a single byte ('char'), \n// and non-ascii range utf-8 single byte are not valid\nexport function twrToLower1252Impl(this: twrWasmModuleBase, c:number) {\n\n\tconst cstr:string = cpTranslate.decoder1252.decode(new Uint8Array([c]));\n\tconst regexp=new RegExp(\"^\\\\p{Letter}$\", 'u');\n\tif (regexp.test(cstr)) {\n\t\tconst r = to1252(cstr.toLocaleLowerCase());\n\t\t//console.log(\"twrToLower1252Impl: isLetter\", c, cstr, cstr.codePointAt(0), cstr.toLocaleLowerCase(), cstr.toLocaleLowerCase().codePointAt(0), r);\n\t\treturn r;\n\t}\n\telse {\n\t\t//console.log(\"twrToLower1252Impl: isNOTLetter\", c, cstr, cstr.codePointAt(0));\n\t\treturn c;\n\t}\n\n}\n\n//utf-8 version not needed since this function is used for a single byte ('char'), \n// and non-ascii range utf-8 single byte are not valid\nexport function twrToUpper1252Impl(this: twrWasmModuleBase, c:number) {\n\n\tconst cstr:string = cpTranslate.decoder1252.decode(new Uint8Array([c]));\n\n\tif (cstr.codePointAt(0)==402) return c;  // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is ƒ\n\tif (cstr.codePointAt(0)==181) return c;  // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is µ\n\tif (cstr.codePointAt(0)==223) return c;  // appears to be safari Version 15.6.1 (17613.3.9.1.16) bug -- this is ß'\n\t\n\tif (cstr==\"µ\") return c;  // upper case version doesn't fit in 1252\n\tif (cstr=='ƒ') return c;  // upper case version doesn't fit in 1252\n\tif (cstr=='ß') return c;  // toLocaleUpperCase() will convert beta to SS\n\n\tconst regexp=new RegExp(\"^\\\\p{Letter}$\", 'u');\n\tif (regexp.test(cstr)) {\n\t\treturn to1252(cstr.toLocaleUpperCase());\n\t}\n\telse {\n\t\treturn c;\n\t}\n\n}\n\nexport function twrStrcollImpl(this: twrWasmModuleBase, lhs:number, rhs:number, codePage:number) {\n\tconst lhStr=this.getString(lhs, undefined, codePage);\n\tconst rhStr=this.getString(rhs, undefined, codePage);\n\n\t// c strcmp(): A positive integer if str1 is greater than str2.\n\t// 1 if string 1 (lh) comes after string 2 (rh)\n\tconst collator = new Intl.Collator();\n\tconst r = collator.compare(lhStr, rhStr);\n\n\treturn r;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n//struct tm {\n//\tint\ttm_sec;\t\t/* seconds after the minute [0-60] */\n//\tint\ttm_min;\t\t/* minutes after the hour [0-59] */\n//\tint\ttm_hour;\t\t/* hours since midnight [0-23] */\n//\tint\ttm_mday;\t\t/* day of the month [1-31] */\n//\tint\ttm_mon;\t\t/* months since January [0-11] */\n//\tint\ttm_year;\t\t/* years since 1900 */\n//\tint\ttm_wday;\t\t/* days since Sunday [0-6] */\n//\tint\ttm_yday;\t\t/* days since January 1 [0-365] */\n//\tint\ttm_isdst;\t/* Daylight Saving Time flag */\n//\tlong\ttm_gmtoff;\t/* offset from UTC in seconds */\n//\tchar\t*tm_zone;\t/* timezone abbreviation */\n//};\n\n// fill in struct tm\n// epcohSecs as 32bit int will overflow January 19, 2038. \nexport function twrTimeTmLocalImpl(this: twrWasmModuleBase, tmIdx:number, epochSecs:number) {\n\n\tconst d=new Date(epochSecs*1000);\n\tthis.setLong(tmIdx, d.getSeconds());\n\tthis.setLong(tmIdx+4, d.getMinutes());\n\tthis.setLong(tmIdx+8, d.getHours());\n\tthis.setLong(tmIdx+12, d.getDate());\n\tthis.setLong(tmIdx+16, d.getMonth());\n\tthis.setLong(tmIdx+20, d.getFullYear()-1900);\n\tthis.setLong(tmIdx+24, d.getDay());\n\tthis.setLong(tmIdx+28, getDayOfYear(d));\n\tthis.setLong(tmIdx+32, isDst());\n\tthis.setLong(tmIdx+36, \t-d.getTimezoneOffset()*60);\n\tthis.setLong(tmIdx+40, \tnoasyncPutString(this, getTZ(d), codePageASCII)); \n\n}\n\nfunction getDayOfYear(date:Date) {\n\tconst start = new Date(date.getFullYear(), 0, 1); \n\tconst diff = date.getTime() - start.getTime(); // Difference in milliseconds\n\tconst oneDay = 1000 * 60 * 60 * 24; // Number of milliseconds in one day\n\tconst day = Math.floor(diff / oneDay);\n\treturn day;\n}\n\nfunction isDst() {\n\tconst timeString = new Date().toLocaleTimeString('en-US', { timeZoneName: 'long' });\n\tif (timeString.includes('Daylight')) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nfunction getTZ(date:Date) {\n\tconst timeZone = date.toLocaleTimeString('en-US', {timeZoneName: 'short'}).split(' ').pop();\n\treturn timeZone?timeZone:\"UTC\";\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n\nfunction setAndPutString(mod: twrWasmModuleBase, idx:number, sin:string,  codePage:number) {\n\tconst stridx=noasyncPutString(mod, sin, codePage);\n\tmod.setLong(idx, stridx);\n}\n\n// JS string into the webassembly module memory.  \n// Does not verify outbuf length. \n// Encode the Wasm string using codePage\n// Does NOT zero terminate string\nfunction noasyncCopyString(mod: twrWasmModuleBase, outbuf:number, sin:string,  codePage:number) {\n\t\tconst ru8=mod.stringToU8(sin, codePage);\n\t\tmod.mem8.set(ru8, outbuf);\n\t\treturn ru8.length;\n}\n\n// allocate and copy a JS string into the webassembly module memory, encode the Wasm string using codePage\nfunction noasyncPutString(mod: twrWasmModuleBase, sin:string,  codePage:number) {\n\tconst ru8=mod.stringToU8(sin, codePage);\n\tconst malloc=mod.exports!.malloc as (size:number)=>number;\n\tconst strIndex:number=malloc(ru8.length+1);\n\tmod.mem8.set(ru8, strIndex);\n\tmod.mem8[strIndex+ru8.length]=0;\n\n\treturn strIndex;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n//struct lconv {\n//\tchar\t*decimal_point;   \t\t0\n//\tchar\t*thousands_sep;\t\t\t4\n//\tchar\t*grouping;\t\t\t\t\t8\n//\tchar\t*int_curr_symbol;\t\t\t12\n//\tchar\t*currency_symbol;\t\t\t16\n//\tchar\t*mon_decimal_point;\t\t20\n//\tchar\t*mon_thousands_sep;\t\t24\n//\tchar\t*mon_grouping;\t\t\t\t28\n//\tchar\t*positive_sign;\t\t\t32\n//\tchar\t*negative_sign;\t\t\t36\n//\tchar\tint_frac_digits;\t\t\t40\n//\tchar\tfrac_digits;\t\t\t\t44\n//\tchar\tp_cs_precedes;\t\t\t\t48\n//\tchar\tp_sep_by_space;\t\t\t52\n//\tchar\tn_cs_precedes;\t\t\t\t56\n//\tchar\tn_sep_by_space;\t\t\t60\n//\tchar\tp_sign_posn;\t\t\t\t64\n//\tchar\tn_sign_posn;\t\t\t\t68\n//};\n\nexport function twrUserLconvImpl(this: twrWasmModuleBase, lconvIdx:number, codePage:number) {\n\tconst locDec=getLocaleDecimalPoint();\n\tconst locSep=getLocaleThousandsSeparator();\n\tsetAndPutString(this, lconvIdx+0, locDec, codePage);\n\tsetAndPutString(this, lconvIdx+4, locSep, codePage);\n\tsetAndPutString(this, lconvIdx+20, locDec, codePage);\n\tsetAndPutString(this, lconvIdx+24, locSep, codePage);\n\tsetAndPutString(this, lconvIdx+24, locSep, codePage);\n\tsetAndPutString(this, lconvIdx+24, locSep, codePage);\n\tsetAndPutString(this, lconvIdx+32, \"+\", codePage);\n\tsetAndPutString(this, lconvIdx+36, \"-\", codePage);\n\tsetAndPutString(this, lconvIdx+12, getLocalCurrencySymbol(), codePage);\n\tsetAndPutString(this, lconvIdx+16, getLocalCurrencySymbol(), codePage);\n}\n\nfunction getLocaleDecimalPoint() {\n    const formatter = new Intl.NumberFormat();\n\n\t //console.log(\"dec resolvedOptions\", formatter.resolvedOptions());\n\n    // Format a test number to find out the decimal point.\n    const formattedNumber = formatter.format(1.1);\n\t //console.log(\"dec formattedNumber\", formattedNumber);\n\n    // Find the character between the numeric parts.\n    const decimalPoint = formattedNumber.replace(/[0-9]/g, '').charAt(0);\n\n    return decimalPoint;\n}\n\nfunction getLocaleThousandsSeparator() {\n\tconst formatter = new Intl.NumberFormat(undefined, {\n\t\t minimumFractionDigits: 0  // Ensure no decimal part interferes\n\t});\n\n\t// Format a test number to include a thousands separator.\n\tconst formattedNumber = formatter.format(1000);\n\t//console.log(\"sep formattedNumber\", formattedNumber);\n\n\t// Extract the thousands separator by removing numeric characters and possible decimal points.\n\t// This may need adjustment depending on whether other characters are present.\n\tlet thousandsSeparator = formattedNumber.replace(/[0-9]/g, '').charAt(0);  // Assumes separator is the first character.\n\t//console.log(\"sep code\",  thousandsSeparator.codePointAt(0));\n\treturn thousandsSeparator;\n}\n\n// this doesn't work, localeCurrency is not correct\nfunction getLocaleCurrencyDecimalPoint() {\n\t// Create an initial NumberFormat object to detect the locale's currency\n\tconst tempFormatter = new Intl.NumberFormat(undefined, { style: 'currency', currency: 'USD' });\n\tconst localeCurrency = tempFormatter.resolvedOptions().currency;\n\tconst formatter = new Intl.NumberFormat(undefined, {\n\t\tstyle: 'currency',\n\t\tcurrency: localeCurrency\n  });\n\t// Format a test number to find out the decimal point.\n\tconst formattedNumber = formatter.format(1.1);\n\n\t// Find the character between the numeric parts.\n\t// char(0) is the currency symbol\n\tconst decimalPoint = formattedNumber.replace(/[0-9]/g, '').charAt(1);\n\n\treturn decimalPoint;\n}\n\nfunction getLocalCurrencySymbol() {\n\tswitch (navigator.language) {\n\t\tcase \"en-US\":\n\t\tcase \"en-CA\":\n\t\tcase \"fr-CA\":\n\t\tcase \"en-AU\":\n\t\tcase \"es-MX\":\n\t\tcase \"es-AR\":\n\t\tcase \"es-CL\":\n\t\tcase \"es-CO\":\n\t\tcase \"es-EC\":\n\t\tcase \"en-GY\":\n\t\tcase \"nl-SR\":\n\t\tcase \"es-UY\":\n\t\tcase \"en-BZ\":\n\t\tcase \"es-SV\":\n\t\tcase \"es-PA\":\n\t\t\treturn \"$\";\n\n\t\tcase \"es-BO\":\n\t\tcase \"es-VE\":\n\t\t\treturn \"Bs.\";\n\n\t\tcase \"es-PY\":\n\t\t\treturn \"₲\";\n\n\t\tcase \"es-PE\":\n\t\t\treturn \"S/\";\n\n\t\tcase \"es-CR\":\n\t\t\treturn \"₡\";\n\n\t\tcase \"es-GT\":\n\t\t\treturn \"Q\";\t\t\n\t\t\t\t\n\t\tcase \"es-HN\":\n\t\t\treturn \"L\";\n\t\t\t\n\t\tcase \"es-NI\":\n\t\t\treturn \"C$\";\n\n\t\tcase \"en-GB\":\n\t\t\treturn \"£\"\n\n\t\tcase \"en-IE\":\n\t\tcase \"de-DE\":\n\t\tcase \"fr-FR\":\n\t\tcase \"de-AT\":\n\t\tcase \"nl-BE\":\n\t\tcase \"fr-BE\":\n\t\tcase \"el-CY\":\n\t\tcase \"et-EE\":\n\t\tcase \"fi-FI\":\n\t\tcase \"sv-FI\":\n\t\tcase \"el-GR\":\n\t\tcase \"it-IT\":\n\t\tcase \"lv-LV\":\n\t\tcase \"lt-LT\":\n\t\tcase \"fr-LU\":\n\t\tcase \"de-LU\":\n\t\tcase \"lb-LU\":\n\t\tcase \"mt-MT\":\n\t\tcase \"nl-NL\":\n\t\tcase \"pt-PT\":\n\t\tcase \"sk-SK\":\n\t\tcase \"sl-SI\":\n\t\tcase \"es-ES\":\n\t\t\treturn \"€\"\n\n\t\tcase \"ja-JP\":\n\t\t\treturn \"¥\"\n\n\t\tcase \"zh-CN\":\n\t\t\treturn \"¥\"\n\n\t\tcase \"de-CH\":\n\t\tcase \"fr-CH\":\n\t\tcase \"it-CH\":\n\t\t\treturn \"CHF\"\n\n\t\tcase \"sv-SE\":\n\t\tcase \"da-DK\":\n\t\tcase \"nb-NO\":\n\t\t\treturn \"kr\"\n\n\t\tcase \"ru-RU\":\n\t\t\treturn \"₽\"\n\n\t\tcase \"ko-KR\":\n\t\t\treturn \"₩\"\n\n\t\tcase \"en-IN\":\n\t\t\treturn \"₹\"\n\n\t\tcase \"pt-BR\":\n\t\treturn \"R$\"\n\n\t\tcase \"he-IL\":\n\t\treturn \"₪\"\n\n\t\tcase \"tr-TR\":\n\t\treturn \"₺\"\n\n\t\tdefault:\n\t\t\treturn \"\";\n\t}\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\nstruct locale_dtnames {\n\tconst char* day[7];\n\tconst char* abday[7];\n\tconst char* month[12];\n\tconst char* abmonth[12];\n\tconst char* ampm[2];\n};\n*/\n\nexport function twrGetDtnamesImpl(this: twrWasmModuleBase, codePage:number) {\n\n\tconst malloc=this.exports!.malloc as (size:number)=>number;\n\tconst dtnamesStructIdx:number=malloc(40*4);\n\tfor (let i=0; i<7; i++)\n\t\tsetAndPutString(this, dtnamesStructIdx+i*4, getLocalizedDayName(i, 'long'), codePage);\n\n\tfor (let i=0; i<7; i++)\n\t\tsetAndPutString(this, dtnamesStructIdx+(i+7)*4, getLocalizedDayName(i, 'short'), codePage);\n\n\tfor (let i=0; i<12; i++)\n\t\tsetAndPutString(this, dtnamesStructIdx+(i+14)*4, getLocalizedMonthNames(i, 'long'), codePage);\n\n\tfor (let i=0; i<12; i++)\n\t\tsetAndPutString(this, dtnamesStructIdx+(i+14+12)*4, getLocalizedMonthNames(i, 'short'), codePage);\n\n\tsetAndPutString(this, dtnamesStructIdx+(0+14+24)*4, getLocalizedAM(), codePage);\n\tsetAndPutString(this, dtnamesStructIdx+(1+14+24)*4, getLocalizedPM(), codePage);\n\n\treturn dtnamesStructIdx;\n}\n\nfunction getLocalizedDayName(n:number, weekdayType:'long'|'short') {\n\t// Create a Date object for the desired day of the week\n\tconst date = new Date();\n\tdate.setDate(date.getDate() - date.getDay() + n);\n\t\n\t// Create an Intl.DateTimeFormat object with the desired locale and options\n\tconst formatter = new Intl.DateTimeFormat(undefined, { weekday: weekdayType });\n\t\n\t// Format the date to get the full day name\n\treturn formatter.format(date);\n}\n\nfunction getLocalizedMonthNames(n:number, monthType:'long'|'short') {\n\tconst formatter = new Intl.DateTimeFormat(undefined, { month: monthType });\n\tconst date = new Date(2000, n, 1);\n\treturn formatter.format(date);\n}\n\nfunction getLocalizedAM() {\n\t// Create a Date object for a time in the morning\n\tconst morningDate = new Date(2000, 0, 1, 9, 0, 0);\n\n\t// Create an Intl.DateTimeFormat object with the desired locale and options\n\tconst formatter = new Intl.DateTimeFormat(undefined, {\n\t\t hour: 'numeric',\n\t\t hour12: true\n\t});\n\n\t// Format the date and get the parts\n\tconst formattedParts = formatter.formatToParts(morningDate);\n\n\t// Find the part of the formatted string that corresponds to the day period (AM/PM)\n\tconst dayPeriodPart = formattedParts.find(part => part.type === 'dayPeriod');\n\n\treturn dayPeriodPart ? dayPeriodPart.value : '';\n}\n\nfunction getLocalizedPM() {\n\t// Create a Date object for a time in the afternoon\n\tconst afternoonDate = new Date(2000, 0, 1, 15, 0, 0);\n\n\t// Create an Intl.DateTimeFormat object with the desired locale and options\n\tconst formatter = new Intl.DateTimeFormat(undefined, {\n\t\t hour: 'numeric',\n\t\t hour12: true\n\t});\n\n\t// Format the date and get the parts\n\tconst formattedParts = formatter.formatToParts(afternoonDate);\n\n\t// Find the part of the formatted string that corresponds to the day period (AM/PM)\n\tconst dayPeriodPart = formattedParts.find(part => part.type === 'dayPeriod');\n\n\treturn dayPeriodPart ? dayPeriodPart.value : '';\n}\n\n","// return ms since epoch as double\nexport function twrTimeEpochImpl() {\n    return Date.now();\n}\n//# sourceMappingURL=twrdate.js.map","// return ms since epoch as double\nexport function twrTimeEpochImpl() {\n\n    return Date.now();\n\n}\n\n","import { twrSharedCircularBuffer } from \"./twrcircular.js\";\nimport { twrCodePageToUnicodeCodePoint, codePageUTF32 } from \"./twrlocale.js\";\nimport { IOTypes, keyDown } from \"./twrcon.js\";\nimport { twrConsoleRegistry } from \"./twrconreg.js\";\nexport class twrConsoleDiv {\n    element;\n    id;\n    keys;\n    CURSOR = String.fromCharCode(9611); // ▋ see https://daniel-hug.github.io/characters/#k_70\n    cursorOn = false;\n    lastChar = 0;\n    extraBR = false;\n    cpTranslate;\n    constructor(element, params) {\n        this.element = element;\n        if (params) {\n            if (params.backColor)\n                this.element.style.backgroundColor = params.backColor;\n            if (params.foreColor)\n                this.element.style.color = params.foreColor;\n            if (params.fontSize)\n                this.element.style.font = params.fontSize.toString() + \"px arial\";\n        }\n        this.cpTranslate = new twrCodePageToUnicodeCodePoint();\n        this.id = twrConsoleRegistry.registerConsole(this);\n    }\n    isHtmlEntityAtEnd(str) {\n        const entityPattern = /&[^;]+;$/;\n        return entityPattern.test(str);\n    }\n    removeHtmlEntityAtEnd(str) {\n        const entityPattern = /&[^;]+;$/;\n        return str.replace(entityPattern, '');\n    }\n    /*\n     * add utf-8 or windows-1252 character to div.  Supports the following control codes:\n     * any of CRLF, CR (/r), or LF(/n)  will cause a new line\n     * 0x8 backspace\n     * 0xE cursor on\n     * 0xF cursor off\n    */\n    charOut(ch, codePage) {\n        if (!this.element)\n            throw new Error(\"internal error\");\n        //console.log(\"div::charout: \", ch, codePage);\n        if (this.extraBR) {\n            this.extraBR = false;\n            if (this.cursorOn)\n                this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n            this.element.innerHTML = this.element.innerHTML.slice(0, -4);\n            if (this.cursorOn)\n                this.element.innerHTML += this.CURSOR;\n        }\n        const chnum = this.cpTranslate.convert(ch, codePage);\n        if (chnum != 0) {\n            switch (chnum) {\n                case 10: // newline\n                case 13: // return\n                    if (ch == 10 && this.lastChar == 13)\n                        break; // detect CR LF and treat as single new line\n                    if (this.cursorOn)\n                        this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    this.element.innerHTML += \"<br><br>\"; //2nd break is a place holder for next line (fixes scroll issue at bottom)\n                    this.extraBR = true;\n                    if (this.cursorOn)\n                        this.element.innerHTML += this.CURSOR;\n                    //element.scrollIntoView();\n                    //element.scrollTop = element.scrollHeight;\n                    let p = this.element.getBoundingClientRect();\n                    window.scrollTo(0, p.height + 100);\n                    break;\n                case 8: // backspace\n                    if (this.cursorOn)\n                        this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    if (this.isHtmlEntityAtEnd(this.element.innerHTML))\n                        this.element.innerHTML = this.removeHtmlEntityAtEnd(this.element.innerHTML);\n                    else\n                        this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    if (this.cursorOn)\n                        this.element.innerHTML += this.CURSOR;\n                    break;\n                case 0xE: // cursor on\n                    if (!this.cursorOn) {\n                        this.cursorOn = true;\n                        this.element.innerHTML += this.CURSOR;\n                        this.element.focus();\n                    }\n                    break;\n                case 0xF: // cursor off\n                    if (this.cursorOn) {\n                        this.cursorOn = false;\n                        this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    }\n                    break;\n                default:\n                    if (this.cursorOn)\n                        this.element.innerHTML = this.element.innerHTML.slice(0, -1);\n                    let newchr = String.fromCodePoint(chnum);\n                    // in html, multiple spaces will be collapsed into one space.  This prevents that behavior.\n                    if (newchr == ' ')\n                        newchr = \"&nbsp;\";\n                    this.element.innerHTML += newchr;\n                    if (this.cursorOn)\n                        this.element.innerHTML += this.CURSOR;\n                    break;\n            }\n            this.lastChar = chnum;\n        }\n    }\n    getProp(propName) {\n        if (propName === \"type\")\n            return IOTypes.CHARWRITE | IOTypes.CHARREAD;\n        console.log(\"twrConsoleDiv.getProp passed unknown property name: \", propName);\n        return 0;\n    }\n    getProxyParams() {\n        this.keys = new twrSharedCircularBuffer(); // tsconfig, lib must be set to 2017 or higher\n        return [\"twrConsoleDivProxy\", this.id, this.keys.sharedArray];\n    }\n    keyDown(ev) {\n        keyDown(this, ev);\n    }\n    processMessage(msgType, data) {\n        const [id, ...params] = data;\n        if (id != this.id)\n            throw new Error(\"internal error\"); // should never happen\n        switch (msgType) {\n            case \"div-charout\":\n                {\n                    const [ch, codePage] = params;\n                    this.charOut(ch, codePage);\n                }\n                break;\n            case \"div-putstr\":\n                {\n                    const [str] = params;\n                    this.putStr(str);\n                }\n                break;\n            case \"div-focus\":\n                {\n                    this.element.focus();\n                }\n                break;\n            default:\n                return false;\n        }\n        return true;\n    }\n    putStr(str) {\n        for (let i = 0; i < str.length; i++)\n            this.charOut(str.codePointAt(i) || 0, codePageUTF32);\n    }\n}\nexport class twrConsoleDivProxy {\n    keys;\n    id;\n    constructor(params) {\n        const [className, id, keysBuffer] = params;\n        this.keys = new twrSharedCircularBuffer(keysBuffer);\n        this.id = id;\n    }\n    charIn() {\n        return this.keys.readWait(); // wait for a key, then read it\n    }\n    inkey() {\n        if (this.keys.isEmpty())\n            return 0;\n        else\n            return this.charIn();\n    }\n    charOut(ch, codePoint) {\n        postMessage([\"div-charout\", [this.id, ch, codePoint]]);\n    }\n    putStr(str) {\n        postMessage([\"div-putstr\", [this.id, str]]);\n    }\n    getProp(propName) {\n        if (propName === \"type\")\n            return IOTypes.CHARWRITE | IOTypes.CHARREAD;\n        console.log(\"twrConsoleDivProxy.getProp passed unknown property name: \", propName);\n        return 0;\n    }\n    setFocus() {\n        postMessage([\"div-focus\", [this.id]]);\n    }\n}\n//# sourceMappingURL=twrcondiv.js.map","import {twrSharedCircularBuffer} from \"./twrcircular.js\";\nimport {twrCodePageToUnicodeCodePoint, codePageUTF32} from \"./twrlocale.js\"\nimport {IConsoleDiv, IConsoleDivProxy, IConsoleDivParams, TConsoleDivProxyParams, IOTypes, keyDown} from \"./twrcon.js\"\nimport {twrConsoleRegistry} from \"./twrconreg.js\"\n\nexport class twrConsoleDiv implements IConsoleDiv {\n   element:HTMLDivElement;\n   id:number;\n   keys?:twrSharedCircularBuffer;\n   CURSOR=String.fromCharCode(9611);  // ▋ see https://daniel-hug.github.io/characters/#k_70\n   cursorOn:boolean=false;\n   lastChar:number=0;\n   extraBR:boolean=false;\n   cpTranslate:twrCodePageToUnicodeCodePoint;\n\n\n   constructor(element:HTMLDivElement,  params:IConsoleDivParams) {\n      this.element=element;\n\n      if (params) {\n         if (params.backColor) this.element.style.backgroundColor = params.backColor;\n         if (params.foreColor) this.element.style.color = params.foreColor;\n         if (params.fontSize) this.element.style.font=params.fontSize.toString()+\"px arial\";\n      }\n\n      this.cpTranslate=new twrCodePageToUnicodeCodePoint();\n      this.id=twrConsoleRegistry.registerConsole(this);\n   }\n\n   private isHtmlEntityAtEnd(str:string) {\n      const entityPattern = /&[^;]+;$/;\n      return entityPattern.test(str);\n   }\n\n  private removeHtmlEntityAtEnd(str:string) {\n   const entityPattern = /&[^;]+;$/;\n       return str.replace(entityPattern, '');\n   }\n\n/* \n * add utf-8 or windows-1252 character to div.  Supports the following control codes:\n * any of CRLF, CR (/r), or LF(/n)  will cause a new line\n * 0x8 backspace\n * 0xE cursor on \n * 0xF cursor off \n*/\n   charOut(ch:number, codePage:number) {\n\n      if (!this.element) throw new Error(\"internal error\");\n\n      //console.log(\"div::charout: \", ch, codePage);\n\n      if (this.extraBR) {\n         this.extraBR=false;\n         if (this.cursorOn) this.element.innerHTML=this.element.innerHTML.slice(0, -1);\n         this.element.innerHTML=this.element.innerHTML.slice(0, -4);\n         if (this.cursorOn) this.element.innerHTML +=  this.CURSOR;\n      }\n\n      const chnum=this.cpTranslate.convert(ch, codePage);\n      if (chnum!=0) {\n         switch (chnum) {\n            case 10:  // newline\n            case 13:  // return\n               if (ch==10 && this.lastChar==13) break;  // detect CR LF and treat as single new line\n               if (this.cursorOn) this.element.innerHTML=this.element.innerHTML.slice(0, -1);\n               this.element.innerHTML +=  \"<br><br>\";   //2nd break is a place holder for next line (fixes scroll issue at bottom)\n               this.extraBR=true;\n               if (this.cursorOn) this.element.innerHTML +=  this.CURSOR;\n               //element.scrollIntoView();\n               //element.scrollTop = element.scrollHeight;\n               let p = this.element.getBoundingClientRect();\n               window.scrollTo(0, p.height+100);\n               break;\n\n            case 8:  // backspace\n               if (this.cursorOn) this.element.innerHTML=this.element.innerHTML.slice(0, -1);\n               if (this.isHtmlEntityAtEnd(this.element.innerHTML)) \n                  this.element.innerHTML=this.removeHtmlEntityAtEnd(this.element.innerHTML);\n               else\n                  this.element.innerHTML=this.element.innerHTML.slice(0, -1);\n               if (this.cursorOn) this.element.innerHTML +=  this.CURSOR;\n               break;\n\n            case 0xE:   // cursor on\n               if (!this.cursorOn) {\n                  this.cursorOn=true;\n                  this.element.innerHTML +=  this.CURSOR;\n                  this.element.focus();\n               }\n               break;\n\n            case 0xF:   // cursor off\n               if (this.cursorOn) {\n                  this.cursorOn=false;\n                  this.element.innerHTML=this.element.innerHTML.slice(0, -1);\n               }\n               break;\n            default:\n               if (this.cursorOn) this.element.innerHTML=this.element.innerHTML.slice(0, -1);\n               let newchr=String.fromCodePoint(chnum);\n               // in html, multiple spaces will be collapsed into one space.  This prevents that behavior.\n               if (newchr==' ') newchr=\"&nbsp;\";\n               this.element.innerHTML += newchr;\n               if (this.cursorOn) this.element.innerHTML +=  this.CURSOR;\n               break;\n            }\n\n         this.lastChar=chnum;\n      }\n   }\n\n   getProp(propName: string):number {\n      if (propName===\"type\") return IOTypes.CHARWRITE|IOTypes.CHARREAD;\n      console.log(\"twrConsoleDiv.getProp passed unknown property name: \", propName)\n      return 0;\n   }\n\n   getProxyParams() : TConsoleDivProxyParams {\n      this.keys = new twrSharedCircularBuffer();  // tsconfig, lib must be set to 2017 or higher\n      return [\"twrConsoleDivProxy\", this.id, this.keys.sharedArray];\n   }\n\n   keyDown(ev:KeyboardEvent)  {\n      keyDown(this, ev);\n   }\n   \n\n   processMessage(msgType:string, data:[number, ...any[]]):boolean {\n      const [id, ...params] = data;\n      if (id!=this.id) throw new Error(\"internal error\");  // should never happen\n\n      switch (msgType) {\n         case \"div-charout\":\n         {\n            const [ch, codePage] =  params;\n            this.charOut(ch, codePage);\n         }\n            break;\n\n         case \"div-putstr\":\n         {\n            const [str] =  params;\n            this.putStr(str);\n         }\n            break;\n\n         case \"div-focus\":\n         {\n            this.element.focus();\n         }\n            break;\n\n         default:\n            return false;\n      }\n\n      return true;\n   }\n\n   putStr(str:string) {\n      for (let i=0; i < str.length; i++)\n         this.charOut(str.codePointAt(i)||0, codePageUTF32);\n   }\n}\n\n\nexport class twrConsoleDivProxy implements IConsoleDivProxy {\n    keys: twrSharedCircularBuffer;\n    id:number;\n\n    constructor(params:TConsoleDivProxyParams) {\n        const [className, id, keysBuffer] = params;\n        this.keys = new twrSharedCircularBuffer(keysBuffer);\n        this.id = id;\n    }\n\n    charIn() {  \n        return this.keys.readWait();  // wait for a key, then read it\n    }\n    \n    inkey() {\n        if (this.keys.isEmpty())\n            return 0;\n        else\n            return this.charIn();    \n    }\n\n   charOut(ch:number, codePoint:number) {\n      postMessage([\"div-charout\", [this.id, ch, codePoint]]);\n   }\n\n   putStr(str:string):void\n   {\n      postMessage([\"div-putstr\", [this.id, str]]);\n   }\n\n   getProp(propName: string) {\n      if (propName===\"type\") return IOTypes.CHARWRITE|IOTypes.CHARREAD;\n      console.log(\"twrConsoleDivProxy.getProp passed unknown property name: \", propName)\n      return 0;\n   }\n\n   setFocus() {\n      postMessage([\"div-focus\", [this.id]]);\n   }\n}\n\n","//\n// This class implements a circular buffer that the main javascript thread can write to, \n// and a blocking WebWorker thread can read from.  This allows keyboard characters to be transferred from the main JS thread to a WebWorker thread.\n// The WebWorker can use the readWait() function to sleep, w/o participating in the normal \n// async callback dispatch method.  This allows a C program that is a single blocking loop to receive input from the primary javascript thread.\n// readWait() is used used when io_getc32() or io_mbgetstr() is called from a C function.\n//\nconst RDIDX = 256;\nconst WRIDX = 257;\nconst LEN = 256;\n// A single thread can read and a separate single thread can write.  With these constraints Atomic operations are not needed.\n// the first 256 array entries are the circular buffer\n// the next two are used for the read and write index\n//!!!! I am using --enable-features=SharedArrayBuffer; see the SharedArrayBuffer docs for COR issues when going to a live web server\nexport class twrSharedCircularBuffer {\n    sharedArray;\n    buf;\n    constructor(sa) {\n        if (typeof window !== 'undefined') { // this check only works if window defined (not a worker thread)\n            if (!crossOriginIsolated && !(window.location.protocol === 'file:'))\n                throw new Error(\"twrSharedCircularBuffer constructor, crossOriginIsolated=\" + crossOriginIsolated + \". See SharedArrayBuffer docs.\");\n        }\n        if (sa)\n            this.sharedArray = sa;\n        else\n            this.sharedArray = new SharedArrayBuffer(258 * 4);\n        this.buf = new Int32Array(this.sharedArray);\n        this.buf[RDIDX] = 0;\n        this.buf[WRIDX] = 0;\n    }\n    write(n) {\n        let i = this.buf[WRIDX];\n        this.buf[i] = n;\n        i++;\n        if (i == LEN)\n            i = 0;\n        this.buf[WRIDX] = i;\n        Atomics.notify(this.buf, WRIDX);\n    }\n    read() {\n        if (!this.isEmpty()) {\n            let i = this.buf[RDIDX];\n            let n = this.buf[i];\n            i++;\n            this.buf[RDIDX] = i;\n            return n;\n        }\n        else\n            return -1;\n    }\n    readWait() {\n        if (this.isEmpty()) {\n            const rdptr = this.buf[RDIDX];\n            // verifies that a shared memory location still contains a given value and if so sleeps until notified.\n            Atomics.wait(this.buf, WRIDX, rdptr);\n        }\n        return this.read();\n    }\n    isEmpty() {\n        return this.buf[RDIDX] == this.buf[WRIDX];\n    }\n}\n//# sourceMappingURL=twrcircular.js.map","//\n// This class implements a circular buffer that the main javascript thread can write to, \n// and a blocking WebWorker thread can read from.  This allows keyboard characters to be transferred from the main JS thread to a WebWorker thread.\n// The WebWorker can use the readWait() function to sleep, w/o participating in the normal \n// async callback dispatch method.  This allows a C program that is a single blocking loop to receive input from the primary javascript thread.\n// readWait() is used used when io_getc32() or io_mbgetstr() is called from a C function.\n//\n\nconst RDIDX=256;\nconst WRIDX=257;\nconst LEN=256;\n\n// A single thread can read and a separate single thread can write.  With these constraints Atomic operations are not needed.\n// the first 256 array entries are the circular buffer\n// the next two are used for the read and write index\n\n//!!!! I am using --enable-features=SharedArrayBuffer; see the SharedArrayBuffer docs for COR issues when going to a live web server\n\nexport class twrSharedCircularBuffer {\n\tsharedArray:SharedArrayBuffer;\n\tbuf:Int32Array;\n \n\tconstructor (sa?:SharedArrayBuffer) {\n        if (typeof window !== 'undefined') {  // this check only works if window defined (not a worker thread)\n            if (!crossOriginIsolated && !(window.location.protocol === 'file:')) throw new Error(\"twrSharedCircularBuffer constructor, crossOriginIsolated=\"+crossOriginIsolated+\". See SharedArrayBuffer docs.\");\n        }\n        if (sa) this.sharedArray=sa;\n        else this.sharedArray=new SharedArrayBuffer(258*4);\n\t\tthis.buf=new Int32Array(this.sharedArray);\n        this.buf[RDIDX]=0;\n        this.buf[WRIDX]=0;\n\t}\n\n\twrite(n:number) {\n        let i=this.buf[WRIDX];\n        this.buf[i]=n;\n        i++;\n        if (i==LEN) i=0;\n        this.buf[WRIDX]=i;  \n        Atomics.notify(this.buf, WRIDX);   \n\t}\n\n\tread():number {\n        if (!this.isEmpty()) {\n            let i=this.buf[RDIDX];\n            let n=this.buf[i];\n            i++;\n            this.buf[RDIDX]=i;\n            return n;\n        }\n\t\telse\n            return -1;\n\t}\n\n    readWait():number {\n        if (this.isEmpty()) {\n            const rdptr=this.buf[RDIDX];\n            // verifies that a shared memory location still contains a given value and if so sleeps until notified.\n            Atomics.wait(this.buf, WRIDX, rdptr);\n        }\n        return this.read();\n\t}\n\n    isEmpty():boolean {\n        return this.buf[RDIDX]==this.buf[WRIDX];\n    }\n}\n","//TODO:\n//\tstruct IoDisplay: need to add a setc32 equiv for back/fore color\n// add io_get_type\n// i can't figure out how to have this param be a keyof instead of string, with separate params for Stream and Terminal:  getProp: (propName: string)=>number;\n// change printf, and other optimizations if they exist, to call io_putstr\n// implement or deprecate io_begin_draw \n// get rid of IoConsoleWindow, and just use IoConsole for everything?\n// add a typedef for struct IoConsole\n// remove from IModParams: imports:{[index:string]:Function},\n// implement \t//\tIModOpts.imports in twrWasmModuleInJSMain\n// add ability to determine if a console has the input focus\n// remove support for io:{[key:string]: IConsole};\n// add codepage as arg to charout.io_putc to make it more flexible and to align with how setc32 works in io_functions\n// add ability to set a max size for a div con, or to trim it.\n// add helloworld-b to index.html?\n// finish inkey\n// add io_setrange example/test case\n// get rid of this.io and just use ioIDtoNames?\n// must match IO_TYPEs in twr_io.h\nexport class IOTypes {\n    static CHARREAD = (1 << 0); // Stream In\n    static CHARWRITE = (1 << 1); // Stream Out\n    static ADDRESSABLE_DISPLAY = (1 << 2); // IoDisplay is enabled\n    static CANVAS2D = (1 << 3); // unimplemented yet\n    static EVENTS = (1 << 4); // unimplemented yet\n    // Private constructor to prevent instantiation\n    constructor() { }\n}\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\nfunction keyEventProcess(ev) {\n    if (!ev.isComposing && !ev.metaKey && ev.key != \"Control\" && ev.key != \"Alt\") {\n        //console.log(\"keyDownDiv: \",ev.key, ev.code, ev.key.codePointAt(0), ev);\n        if (ev.key.length == 1)\n            return ev.key.codePointAt(0);\n        else {\n            switch (ev.key) {\n                case 'Backspace': return 8;\n                case 'Enter': return 10;\n                case 'Escape': return 0x1B;\n                case 'Delete': return 0x7F;\n                case 'ArrowLeft': return 0x2190;\n                case 'ArrowUp': return 0x2191;\n                case 'ArrowRight': return 0x2192;\n                case 'ArrowDown': return 0x2193;\n            }\n            console.log(\"keyEventProcess SKIPPED: \", ev.key, ev.code, ev.key.codePointAt(0), ev);\n        }\n    }\n    else {\n        console.log(\"keyEventProcess SKIPPED-2: \", ev.key, ev.code, ev.key.codePointAt(0), ev);\n    }\n    return undefined;\n}\n// this is a utility function used by console classes, and should be called from HTML \"keydown\" event \nexport function keyDown(destinationCon, ev) {\n    if (!destinationCon.keys)\n        throw new Error(\"keyDown requires twrModuleAsync\");\n    else {\n        const r = keyEventProcess(ev);\n        if (r)\n            destinationCon.keys.write(r);\n    }\n}\n//# sourceMappingURL=twrcon.js.map","//TODO:\n//\tstruct IoDisplay: need to add a setc32 equiv for back/fore color\n// add io_get_type\n// i can't figure out how to have this param be a keyof instead of string, with separate params for Stream and Terminal:  getProp: (propName: string)=>number;\n// change printf, and other optimizations if they exist, to call io_putstr\n// implement or deprecate io_begin_draw \n// get rid of IoConsoleWindow, and just use IoConsole for everything?\n// add a typedef for struct IoConsole\n// remove from IModParams: imports:{[index:string]:Function},\n// implement \t//\tIModOpts.imports in twrWasmModuleInJSMain\n// add ability to determine if a console has the input focus\n// remove support for io:{[key:string]: IConsole};\n// add codepage as arg to charout.io_putc to make it more flexible and to align with how setc32 works in io_functions\n// add ability to set a max size for a div con, or to trim it.\n// add helloworld-b to index.html?\n// finish inkey\n// add io_setrange example/test case\n// get rid of this.io and just use ioIDtoNames?\n\nimport {twrSharedCircularBuffer} from \"./twrcircular.js\"\nimport {twrWasmModuleBase} from \"./twrmodbase.js\"\n\n// Params are passed to the console constructor\nexport interface IConsoleDivParams {\n   foreColor?: string,\n   backColor?: string,\n   fontSize?: number,\n}\n\nexport interface IConsoleTerminalParams extends IConsoleDivParams {\n   widthInChars?: number,\n   heightInChars?: number,\n}\n\n// Props of a console can be queried \nexport interface IOBaseProps {\n   type: number,   // a constant from class IOTypes\n   [key: string]: number;  // required because I access with a string. \n}\n\nexport interface IConsoleTerminalProps extends IOBaseProps {\n   cursorPos:number,\n   charWidth: number,\n   charHeight: number,\n   foreColorAsRGB: number,\n   backColorAsRGB: number,\n   widthInChars: number,\n   heightInChars: number,\n   fontSize: number,\n   canvasWidth:number,\n   canvasHeight:number\n}\n\nexport interface ICanvasProps extends IOBaseProps{\n   canvasWidth:number,\n   canvasHeight:number\n}\n\n// Interface for Consoles\nexport interface IConsoleBase {\n   getProp: (propName: string)=>number;\n   getProxyParams: ()=> TConsoleProxyParams;\n   processMessage(msgType:string, data:[number, ...any[]], callingModule:twrWasmModuleBase):boolean;\n\n\tid:number;   // returned by twrConsoleRegistry.registerConsole()\n   element?:HTMLElement;   // debug console does not have an element\n}\n\nexport interface IConsoleBaseProxy {\n   getProp: (propName: string)=>number;\n\tid:number;   // returned by twrConsoleRegistry.registerConsole()\n}\n\nexport interface IConsoleStream {\n   charOut: (c:number, codePage:number)=>void;\n   putStr: (str:string)=>void;\n\tkeyDown: (ev:KeyboardEvent)=>void;\n\n   keys?: twrSharedCircularBuffer;  // only created if getProxyParams is called \n}\n\nexport interface IConsoleStreamProxy {\n   charOut: (c:number, codePage:number)=>void;\n   putStr: (str:string)=>void;\n   charIn: ()=>number;\n\tsetFocus: ()=>void;\n}\n\nexport interface IConsoleAddressable {\n   cls: ()=>void;\n   setRange: (start:number, values:[])=>void;\n   setC32: (location:number, char:number)=>void;\n   setReset: (x:number, y:number, isset:boolean)=>void;\n   point: (x:number, y:number)=>boolean;\n   setCursor: (pos:number)=>void;\n   setCursorXY: (x:number, y:number)=>void;\n   setColors: (foreground:number, background:number)=>void;\n}\n\nexport interface IConsoleDrawable {\n    drawSeq: (ds:number, owner:twrWasmModuleBase)=>void,\n }\n\n export interface IConsoleDrawableProxy {\n   drawSeq: (ds:number)=>void,\n}\n\nexport interface IConsoleTerminal extends IConsoleBase, IConsoleStream, IConsoleAddressable {}\nexport interface IConsoleTerminalProxy extends IConsoleBaseProxy, IConsoleStreamProxy, IConsoleAddressable {}\n\nexport interface IConsoleDiv extends IConsoleBase, IConsoleStream {}\nexport interface IConsoleDivProxy extends IConsoleBaseProxy, IConsoleStreamProxy  {}\n\nexport interface IConsoleDebug extends IConsoleBase, IConsoleStream {}\nexport interface IConsoleDebugProxy extends IConsoleBaseProxy, IConsoleStreamProxy  {}\n\nexport interface IConsoleCanvas extends IConsoleBase, IConsoleDrawable {}\nexport interface IConsoleCanvasProxy extends IConsoleBaseProxy, IConsoleDrawableProxy {}\n\nexport interface IConsole extends IConsoleBase, Partial<IConsoleStream>, Partial<IConsoleAddressable>, Partial<IConsoleDrawable> {}\nexport interface IConsoleProxy extends IConsoleBaseProxy, Partial<IConsoleStreamProxy>, Partial<IConsoleAddressable>, Partial<IConsoleDrawableProxy> {}\n\n\n// ProxyParams are the info needed to instantiate the proxy version of a console\nexport type TConsoleDebugProxyParams = [\"twrConsoleDebugProxy\", number];\nexport type TConsoleDivProxyParams = [\"twrConsoleDivProxy\", number, SharedArrayBuffer];\nexport type TConsoleTerminalProxyParams = [\"twrConsoleTerminalProxy\", number, SharedArrayBuffer, SharedArrayBuffer];\nexport type TConsoleCanvasProxyParams = [\"twrConsoleCanvasProxy\", number, ICanvasProps, SharedArrayBuffer, SharedArrayBuffer];\nexport type TConsoleProxyParams = TConsoleTerminalProxyParams | TConsoleDivProxyParams | TConsoleDebugProxyParams | TConsoleCanvasProxyParams;\n\n// must match IO_TYPEs in twr_io.h\nexport class IOTypes {\n   static readonly  CHARREAD = (1<<0);  // Stream In\n   static readonly  CHARWRITE = (1<<1);  // Stream Out\n   static readonly  ADDRESSABLE_DISPLAY = (1<<2);  \t// IoDisplay is enabled\n   static readonly  CANVAS2D = (1<<3);   // unimplemented yet\n   static readonly  EVENTS = (1<<4);  // unimplemented yet\n\n  // Private constructor to prevent instantiation\n  private constructor() {}\n}\n\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n\nfunction keyEventProcess(ev:KeyboardEvent) {\n\tif ( !ev.isComposing  && !ev.metaKey && ev.key!=\"Control\" && ev.key!=\"Alt\" ) {\n\t\t//console.log(\"keyDownDiv: \",ev.key, ev.code, ev.key.codePointAt(0), ev);\n\t\tif (ev.key.length==1)\n\t\t\treturn ev.key.codePointAt(0);\n\t\telse {\n\t\t\tswitch(ev.key) {\n\t\t\t\tcase 'Backspace': return 8;\n\t\t\t\tcase 'Enter': \t\treturn 10;\n\t\t\t\tcase 'Escape': \treturn 0x1B;\n\t\t\t\tcase 'Delete': \treturn 0x7F;\n\t\t\t\tcase 'ArrowLeft':\treturn 0x2190;\n\t\t\t\tcase 'ArrowUp':\treturn 0x2191;\n\t\t\t\tcase 'ArrowRight':return 0x2192;\n\t\t\t\tcase 'ArrowDown':\treturn 0x2193;\n\t\t\t}\n\t\t\tconsole.log(\"keyEventProcess SKIPPED: \",ev.key, ev.code, ev.key.codePointAt(0), ev);\n\t\t}\n\t}\n\telse {\n\t\tconsole.log(\"keyEventProcess SKIPPED-2: \",ev.key, ev.code, ev.key.codePointAt(0), ev);\n\t}\n\n\treturn undefined;\n}\n\n// this is a utility function used by console classes, and should be called from HTML \"keydown\" event \nexport function keyDown(destinationCon:IConsole, ev:KeyboardEvent)  {\n\tif (!destinationCon.keys)\n\t\tthrow new Error(\"keyDown requires twrModuleAsync\");\n\telse {\n\t\tconst r=keyEventProcess(ev);\n\t\tif (r) destinationCon.keys.write(r);\n\t}\n}\n\n","// this is global in the JS main thread address space\n// all consoles are registered here\nexport class twrConsoleRegistry {\n    static consoles = [];\n    // create a pairing between an instance of type IConsole and an integer ID\n    static registerConsole(con) {\n        twrConsoleRegistry.consoles.push(con);\n        return twrConsoleRegistry.consoles.length - 1;\n    }\n    static getConsole(id) {\n        if (id < 0 || id >= twrConsoleRegistry.consoles.length)\n            throw new Error(\"Invalid console ID: \" + id);\n        return twrConsoleRegistry.consoles[id];\n    }\n    static getConsoleID(con) {\n        for (let i = 0; i < twrConsoleRegistry.consoles.length; i++)\n            if (twrConsoleRegistry.consoles[i] == con)\n                return i;\n        throw new Error(\"IConsole not in registry\");\n    }\n}\n// this is created in each twrWasmModuleAsyncProxy Worker thread\n// if there are multiple twrWasmModuleAsyncProxy instances, there will be multiple copies of this in each Worker\nexport class twrConsoleProxyRegistry {\n    static consoles = [];\n    // create a pairing between an instance of type IConsole and an integer ID\n    static registerConsoleProxy(con) {\n        twrConsoleProxyRegistry.consoles[con.id] = con;\n        return con.id;\n    }\n    static getConsoleProxy(id) {\n        if (id < 0 || id >= twrConsoleProxyRegistry.consoles.length)\n            throw new Error(\"Invalid console ID: \" + id);\n        return twrConsoleProxyRegistry.consoles[id];\n    }\n    static getConsoleID(con) {\n        for (let i = 0; i < twrConsoleProxyRegistry.consoles.length; i++)\n            if (twrConsoleProxyRegistry.consoles[i] == con)\n                return i;\n        throw new Error(\"IConsoleProxy not in registry\");\n    }\n}\n//# sourceMappingURL=twrconreg.js.map","\nimport {IConsole, IConsoleProxy} from \"./twrcon.js\"\n\n// this is global in the JS main thread address space\n// all consoles are registered here\nexport class twrConsoleRegistry {\n\n\tstatic consoles: IConsole[]=[];\n\n\t// create a pairing between an instance of type IConsole and an integer ID\n\tstatic registerConsole(con:IConsole) {\n\t\ttwrConsoleRegistry.consoles.push(con);\n\t\treturn twrConsoleRegistry.consoles.length-1;\n\t}\n\n\tstatic getConsole(id:number) {\n\t\tif (id<0 || id >= twrConsoleRegistry.consoles.length)\n\t\t\tthrow new Error(\"Invalid console ID: \"+id);\n\n\t\treturn twrConsoleRegistry.consoles[id];\n\t}\n\n\tstatic getConsoleID(con:IConsole) {\n\t\tfor (let i=0; i<twrConsoleRegistry.consoles.length; i++)\n\t\t\tif (twrConsoleRegistry.consoles[i]==con)\n\t\t\t\treturn i;\n\n\t\tthrow new Error(\"IConsole not in registry\");\n\t}\n\n}\n\n// this is created in each twrWasmModuleAsyncProxy Worker thread\n// if there are multiple twrWasmModuleAsyncProxy instances, there will be multiple copies of this in each Worker\nexport class twrConsoleProxyRegistry {\n\n\tstatic consoles: IConsoleProxy[]=[];\n\n\t// create a pairing between an instance of type IConsole and an integer ID\n\tstatic registerConsoleProxy(con:IConsoleProxy) {\n\t\ttwrConsoleProxyRegistry.consoles[con.id]=con;\n\t\treturn con.id;\n\t}\n\n\tstatic getConsoleProxy(id:number) {\n\t\tif (id<0 || id >= twrConsoleProxyRegistry.consoles.length)\n\t\t\tthrow new Error(\"Invalid console ID: \"+id);\n\n\t\treturn twrConsoleProxyRegistry.consoles[id];\n\t}\n\n\tstatic getConsoleID(con:IConsoleProxy) {\n\t\tfor (let i=0; i<twrConsoleProxyRegistry.consoles.length; i++)\n\t\t\tif (twrConsoleProxyRegistry.consoles[i]==con)\n\t\t\t\treturn i;\n\n\t\tthrow new Error(\"IConsoleProxy not in registry\");\n\t}\n\n}","import { twrSignal } from \"./twrsignal.js\";\n// This class is used in the  Main JS thread \nexport class twrWaitingCalls {\n    callCompleteSignal;\n    parameters;\n    constructor() {\n        this.callCompleteSignal = new twrSignal();\n        this.parameters = new Uint32Array(new SharedArrayBuffer(4));\n    }\n    startSleep(ms) {\n        setTimeout(() => {\n            this.callCompleteSignal.signal();\n        }, ms);\n    }\n    getProxyParams() {\n        return [this.callCompleteSignal.sharedArray, this.parameters.buffer];\n    }\n    processMessage(msgType, data) {\n        switch (msgType) {\n            case \"sleep\":\n                const [ms] = data;\n                this.startSleep(ms);\n                break;\n            default:\n                return false;\n        }\n        return true;\n    }\n}\n// This class is used in the worker thread \nexport class twrWaitingCallsProxy {\n    callCompleteSignal;\n    parameters;\n    constructor(params) {\n        this.callCompleteSignal = new twrSignal(params[0]);\n        this.parameters = new Uint32Array(params[1]);\n    }\n    sleep(ms) {\n        this.callCompleteSignal.reset();\n        postMessage([\"sleep\", [ms]]);\n        this.callCompleteSignal.wait();\n    }\n}\n//# sourceMappingURL=twrwaitingcalls.js.map","import { twrSignal } from \"./twrsignal.js\";\n\n// These classes are used to proxy a call across the worker thread - main thread boundary and wait for the result\n\nexport type TWaitingCallsProxyParams = [SharedArrayBuffer, SharedArrayBuffer];   // twrSignal, arguments \n\n// This class is used in the  Main JS thread \nexport class twrWaitingCalls {\n\tcallCompleteSignal:twrSignal;\n\tparameters:Uint32Array;\n\n\tconstructor() {\n\t\tthis.callCompleteSignal=new twrSignal();\n\t\tthis.parameters=new Uint32Array(new SharedArrayBuffer(4));\n\t}\n\n\tprivate startSleep(ms:number) {\n\n\t\tsetTimeout(()=>{\n\t\t\tthis.callCompleteSignal.signal();\n\t\t}, ms);\n\t\t\n\t}\n\n\tgetProxyParams():TWaitingCallsProxyParams {\n\t\treturn [this.callCompleteSignal.sharedArray, this.parameters.buffer as SharedArrayBuffer];\t\n\t}\n\n\tprocessMessage(msgType:string, data:any[]):boolean {\n\t\tswitch (msgType) {\n\t\t\tcase \"sleep\":\n\t\t\t\tconst [ms] =  data;\n\t\t\t\tthis.startSleep(ms);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n}\n\n// This class is used in the worker thread \nexport class twrWaitingCallsProxy {\n\tcallCompleteSignal:twrSignal;\n\tparameters:Uint32Array;\n\n\tconstructor(params:TWaitingCallsProxyParams) {\n\t\tthis.callCompleteSignal=new twrSignal(params[0]);\n\t\tthis.parameters=new Uint32Array(params[1]);\n\t}\n\n\tsleep(ms:number) {\n\t\tthis.callCompleteSignal.reset();\n\t\tpostMessage([\"sleep\", [ms]]);\n\t\tthis.callCompleteSignal.wait();\n\t}\n\n}\n","//\n// This class implements a simple signal/wait mechanism\n// It is used by the WebWorker thread to block/wait, and the main JS thread to signal when to unblock\n//\nvar twrSignalState;\n(function (twrSignalState) {\n    twrSignalState[twrSignalState[\"WAITING\"] = 0] = \"WAITING\";\n    twrSignalState[twrSignalState[\"SIGNALED\"] = 1] = \"SIGNALED\";\n})(twrSignalState || (twrSignalState = {}));\n;\nexport class twrSignal {\n    sharedArray;\n    buf;\n    constructor(sa) {\n        if (typeof window !== 'undefined') { // this check only works if window valid\n            if (!crossOriginIsolated && !(window.location.protocol === 'file:'))\n                throw new Error(\"twrSignal constructor, crossOriginIsolated=\" + crossOriginIsolated + \". See SharedArrayBuffer docs.\");\n        }\n        if (sa)\n            this.sharedArray = sa;\n        else\n            this.sharedArray = new SharedArrayBuffer(4);\n        this.buf = new Int32Array(this.sharedArray);\n        this.buf[0] = twrSignalState.WAITING;\n    }\n    signal() {\n        this.buf[0] = twrSignalState.SIGNALED;\n        //console.log(\"about to signal\");\n        Atomics.notify(this.buf, 0);\n    }\n    wait() {\n        if (this.buf[0] == twrSignalState.WAITING) {\n            //console.log(\"waiting...\");\n            Atomics.wait(this.buf, 0, twrSignalState.WAITING);\n            //console.log(\"released...\");\n        }\n    }\n    isSignaled() {\n        return this.buf[0] == twrSignalState.SIGNALED;\n    }\n    reset() {\n        this.buf[0] = twrSignalState.WAITING;\n    }\n}\n//# sourceMappingURL=twrsignal.js.map","//\n// This class implements a simple signal/wait mechanism\n// It is used by the WebWorker thread to block/wait, and the main JS thread to signal when to unblock\n//\n\nenum twrSignalState {\n    WAITING=0,\n    SIGNALED=1\n};\n\nexport class twrSignal {\n\tsharedArray:SharedArrayBuffer;\n\tbuf:Int32Array;\n\n \tconstructor (sa?:SharedArrayBuffer) {\n        if (typeof window !== 'undefined') { // this check only works if window valid\n            if (!crossOriginIsolated && !(window.location.protocol === 'file:')) \n                throw new Error(\"twrSignal constructor, crossOriginIsolated=\"+crossOriginIsolated+\". See SharedArrayBuffer docs.\");\n        }\n        if (sa) this.sharedArray=sa;\n        else this.sharedArray=new SharedArrayBuffer(4);\n\t\tthis.buf=new Int32Array(this.sharedArray);\n        this.buf[0]=twrSignalState.WAITING;\n\t}\n\n\tsignal() {\n        this.buf[0]=twrSignalState.SIGNALED;  \n        //console.log(\"about to signal\");\n        Atomics.notify(this.buf, 0);   \n\t}\n\n    wait() {\n        if (this.buf[0]==twrSignalState.WAITING) {\n            //console.log(\"waiting...\");\n            Atomics.wait(this.buf, 0, twrSignalState.WAITING);\n            //console.log(\"released...\");\n\n        }\n\t}\n    isSignaled():boolean {\n        return this.buf[0]==twrSignalState.SIGNALED;\n    }\n\n    reset() {\n        this.buf[0]=twrSignalState.WAITING;\n    }\n}\n","import { twrSharedCircularBuffer } from \"./twrcircular.js\";\nimport { twrSignal } from \"./twrsignal.js\";\nimport { IOTypes } from \"./twrcon.js\";\nimport { twrConsoleRegistry } from \"./twrconreg.js\";\nvar D2DType;\n(function (D2DType) {\n    D2DType[D2DType[\"D2D_FILLRECT\"] = 1] = \"D2D_FILLRECT\";\n    D2DType[D2DType[\"D2D_FILLCODEPOINT\"] = 5] = \"D2D_FILLCODEPOINT\";\n    D2DType[D2DType[\"D2D_SETLINEWIDTH\"] = 10] = \"D2D_SETLINEWIDTH\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLERGBA\"] = 11] = \"D2D_SETFILLSTYLERGBA\";\n    D2DType[D2DType[\"D2D_SETFONT\"] = 12] = \"D2D_SETFONT\";\n    D2DType[D2DType[\"D2D_BEGINPATH\"] = 13] = \"D2D_BEGINPATH\";\n    D2DType[D2DType[\"D2D_MOVETO\"] = 14] = \"D2D_MOVETO\";\n    D2DType[D2DType[\"D2D_LINETO\"] = 15] = \"D2D_LINETO\";\n    D2DType[D2DType[\"D2D_FILL\"] = 16] = \"D2D_FILL\";\n    D2DType[D2DType[\"D2D_STROKE\"] = 17] = \"D2D_STROKE\";\n    D2DType[D2DType[\"D2D_SETSTROKESTYLERGBA\"] = 18] = \"D2D_SETSTROKESTYLERGBA\";\n    D2DType[D2DType[\"D2D_ARC\"] = 19] = \"D2D_ARC\";\n    D2DType[D2DType[\"D2D_STROKERECT\"] = 20] = \"D2D_STROKERECT\";\n    D2DType[D2DType[\"D2D_FILLTEXT\"] = 21] = \"D2D_FILLTEXT\";\n    D2DType[D2DType[\"D2D_IMAGEDATA\"] = 22] = \"D2D_IMAGEDATA\";\n    D2DType[D2DType[\"D2D_PUTIMAGEDATA\"] = 23] = \"D2D_PUTIMAGEDATA\";\n    D2DType[D2DType[\"D2D_BEZIERTO\"] = 24] = \"D2D_BEZIERTO\";\n    D2DType[D2DType[\"D2D_MEASURETEXT\"] = 25] = \"D2D_MEASURETEXT\";\n    D2DType[D2DType[\"D2D_SAVE\"] = 26] = \"D2D_SAVE\";\n    D2DType[D2DType[\"D2D_RESTORE\"] = 27] = \"D2D_RESTORE\";\n    D2DType[D2DType[\"D2D_CREATERADIALGRADIENT\"] = 28] = \"D2D_CREATERADIALGRADIENT\";\n    D2DType[D2DType[\"D2D_SETCOLORSTOP\"] = 29] = \"D2D_SETCOLORSTOP\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLEGRADIENT\"] = 30] = \"D2D_SETFILLSTYLEGRADIENT\";\n    D2DType[D2DType[\"D2D_RELEASEID\"] = 31] = \"D2D_RELEASEID\";\n    D2DType[D2DType[\"D2D_CREATELINEARGRADIENT\"] = 32] = \"D2D_CREATELINEARGRADIENT\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLE\"] = 33] = \"D2D_SETFILLSTYLE\";\n    D2DType[D2DType[\"D2D_SETSTROKESTYLE\"] = 34] = \"D2D_SETSTROKESTYLE\";\n    D2DType[D2DType[\"D2D_CLOSEPATH\"] = 35] = \"D2D_CLOSEPATH\";\n    D2DType[D2DType[\"D2D_RESET\"] = 36] = \"D2D_RESET\";\n    D2DType[D2DType[\"D2D_CLEARRECT\"] = 37] = \"D2D_CLEARRECT\";\n    D2DType[D2DType[\"D2D_SCALE\"] = 38] = \"D2D_SCALE\";\n    D2DType[D2DType[\"D2D_TRANSLATE\"] = 39] = \"D2D_TRANSLATE\";\n    D2DType[D2DType[\"D2D_ROTATE\"] = 40] = \"D2D_ROTATE\";\n    D2DType[D2DType[\"D2D_GETTRANSFORM\"] = 41] = \"D2D_GETTRANSFORM\";\n    D2DType[D2DType[\"D2D_SETTRANSFORM\"] = 42] = \"D2D_SETTRANSFORM\";\n    D2DType[D2DType[\"D2D_RESETTRANSFORM\"] = 43] = \"D2D_RESETTRANSFORM\";\n    D2DType[D2DType[\"D2D_STROKETEXT\"] = 44] = \"D2D_STROKETEXT\";\n    D2DType[D2DType[\"D2D_ROUNDRECT\"] = 45] = \"D2D_ROUNDRECT\";\n    D2DType[D2DType[\"D2D_ELLIPSE\"] = 46] = \"D2D_ELLIPSE\";\n    D2DType[D2DType[\"D2D_QUADRATICCURVETO\"] = 47] = \"D2D_QUADRATICCURVETO\";\n    D2DType[D2DType[\"D2D_SETLINEDASH\"] = 48] = \"D2D_SETLINEDASH\";\n    D2DType[D2DType[\"D2D_GETLINEDASH\"] = 49] = \"D2D_GETLINEDASH\";\n    D2DType[D2DType[\"D2D_ARCTO\"] = 50] = \"D2D_ARCTO\";\n    D2DType[D2DType[\"D2D_GETLINEDASHLENGTH\"] = 51] = \"D2D_GETLINEDASHLENGTH\";\n})(D2DType || (D2DType = {}));\nexport class twrConsoleCanvas {\n    ctx;\n    id;\n    element;\n    props;\n    cmdCompleteSignal;\n    canvasKeys;\n    isAsyncMod;\n    precomputedObjects;\n    constructor(element) {\n        this.isAsyncMod = false; // set to true if getProxyParams called\n        this.precomputedObjects = {};\n        if (!element.getContext)\n            throw new Error(\"attempted to create new twrCanvas with an element that is not a valid HTMLCanvasElement\");\n        this.element = element;\n        const c = element.getContext(\"2d\");\n        if (!c)\n            throw new Error(\"canvas 2D context not found in twrCanvasConstructor\");\n        this.ctx = c;\n        // these two lines are for backwards compatibility with prior version of twr-wasm\n        c.font = \"16 px Courier New\";\n        c.textBaseline = \"top\";\n        this.props = { canvasHeight: element.height, canvasWidth: element.width, type: IOTypes.CANVAS2D };\n        this.id = twrConsoleRegistry.registerConsole(this);\n    }\n    // these are the parameters needed to create a twrConsoleCanvasProxy, paired to us\n    getProxyParams() {\n        this.cmdCompleteSignal = new twrSignal();\n        this.canvasKeys = new twrSharedCircularBuffer(); // tsconfig, lib must be set to 2017 or higher\n        this.isAsyncMod = true;\n        return [\"twrConsoleCanvasProxy\", this.id, this.props, this.cmdCompleteSignal.sharedArray, this.canvasKeys.sharedArray];\n    }\n    getProp(name) {\n        return this.props[name];\n    }\n    // process messages sent from twrConsoleCanvasProxy\n    // these are used to \"remote procedure call\" from the worker thread to the JS Main thread\n    processMessage(msgType, data, callingModule) {\n        const [id, ...params] = data;\n        if (id != this.id)\n            throw new Error(\"internal error\"); // should never happen\n        switch (msgType) {\n            case \"canvas2d-drawseq\":\n                {\n                    const [ds] = params;\n                    this.drawSeq(ds, callingModule);\n                    break;\n                }\n            default:\n                return false;\n        }\n        return true;\n    }\n    /* see draw2d.h for structs that match */\n    drawSeq(ds, owner) {\n        //console.log(\"twr::Canvas enter drawSeq\");\n        if (!this.ctx)\n            return;\n        const insHdrSize = 16;\n        let currentInsHdr = owner.getLong(ds); /* ds->start */\n        const lastInsHdr = owner.getLong(ds + 4); /* ds->last */\n        let currentInsParams = currentInsHdr + insHdrSize;\n        //console.log(\"instruction start, last \",ins.toString(16), lastins.toString(16));\n        let nextInsHdr;\n        //let insCount=0;\n        while (1) {\n            //insCount++;\n            const type = owner.getLong(currentInsHdr + 4); /* hdr->type */\n            if (0 /*type!=D2DType.D2D_FILLRECT*/) {\n                console.log(\"ins\", currentInsHdr);\n                console.log(\"hdr.next\", owner.mem8[currentInsHdr], owner.mem8[currentInsHdr + 1], owner.mem8[currentInsHdr + 2], owner.mem8[currentInsHdr + 3]);\n                console.log(\"hdr.type\", owner.mem8[currentInsHdr + 4], owner.mem8[currentInsHdr + 5]);\n                console.log(\"next 4 bytes\", owner.mem8[currentInsHdr + 6], owner.mem8[currentInsHdr + 7], owner.mem8[currentInsHdr + 8], owner.mem8[currentInsHdr + 9]);\n                console.log(\"and 4 more \", owner.mem8[currentInsHdr + 10], owner.mem8[currentInsHdr + 11], owner.mem8[currentInsHdr + 12], owner.mem8[currentInsHdr + 13]);\n                //console.log(\"ins, type, next is \", ins.toString(16), type.toString(16), next.toString(16));\n            }\n            switch (type) {\n                case D2DType.D2D_FILLRECT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const w = owner.getDouble(currentInsParams + 16);\n                        const h = owner.getDouble(currentInsParams + 24);\n                        this.ctx.fillRect(x, y, w, h);\n                    }\n                    break;\n                case D2DType.D2D_STROKERECT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const w = owner.getDouble(currentInsParams + 16);\n                        const h = owner.getDouble(currentInsParams + 24);\n                        this.ctx.strokeRect(x, y, w, h);\n                    }\n                    break;\n                case D2DType.D2D_FILLCODEPOINT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const c = owner.getLong(currentInsParams + 16);\n                        let txt = String.fromCodePoint(c);\n                        this.ctx.fillText(txt, x, y);\n                    }\n                    break;\n                case D2DType.D2D_FILLTEXT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const codePage = owner.getLong(currentInsParams + 20);\n                        const strPointer = owner.getLong(currentInsParams + 16);\n                        const str = owner.getString(strPointer, undefined, codePage);\n                        //console.log(\"filltext \",x,y,str)\n                        this.ctx.fillText(str, x, y);\n                    }\n                    break;\n                case D2DType.D2D_MEASURETEXT:\n                    {\n                        const codePage = owner.getLong(currentInsParams + 8);\n                        const str = owner.getString(owner.getLong(currentInsParams), undefined, codePage);\n                        const tmidx = owner.getLong(currentInsParams + 4);\n                        const tm = this.ctx.measureText(str);\n                        owner.setDouble(tmidx + 0, tm.actualBoundingBoxAscent);\n                        owner.setDouble(tmidx + 8, tm.actualBoundingBoxDescent);\n                        owner.setDouble(tmidx + 16, tm.actualBoundingBoxLeft);\n                        owner.setDouble(tmidx + 24, tm.actualBoundingBoxRight);\n                        owner.setDouble(tmidx + 32, tm.fontBoundingBoxAscent);\n                        owner.setDouble(tmidx + 40, tm.fontBoundingBoxDescent);\n                        owner.setDouble(tmidx + 48, tm.width);\n                    }\n                    break;\n                case D2DType.D2D_SETFONT:\n                    {\n                        const fontPointer = owner.getLong(currentInsParams);\n                        const str = owner.getString(fontPointer);\n                        this.ctx.font = str;\n                    }\n                    break;\n                case D2DType.D2D_SETFILLSTYLERGBA:\n                    {\n                        const color = owner.getLong(currentInsParams);\n                        const cssColor = \"#\" + (\"00000000\" + color.toString(16)).slice(-8);\n                        this.ctx.fillStyle = cssColor;\n                        //console.log(\"fillstyle: \", this.ctx.fillStyle, \":\", cssColor,\":\", color)\n                    }\n                    break;\n                case D2DType.D2D_SETSTROKESTYLERGBA:\n                    {\n                        const color = owner.getLong(currentInsParams);\n                        const cssColor = \"#\" + (\"00000000\" + color.toString(16)).slice(-8);\n                        this.ctx.strokeStyle = cssColor;\n                    }\n                    break;\n                case D2DType.D2D_SETFILLSTYLE:\n                    {\n                        const cssColorPointer = owner.getLong(currentInsParams);\n                        const cssColor = owner.getString(cssColorPointer);\n                        this.ctx.fillStyle = cssColor;\n                    }\n                    break;\n                case D2DType.D2D_SETSTROKESTYLE:\n                    {\n                        const cssColorPointer = owner.getLong(currentInsParams);\n                        const cssColor = owner.getString(cssColorPointer);\n                        this.ctx.strokeStyle = cssColor;\n                    }\n                    break;\n                case D2DType.D2D_SETLINEWIDTH:\n                    {\n                        const width = owner.getDouble(currentInsParams);\n                        this.ctx.lineWidth = width;\n                        //console.log(\"twrCanvas D2D_SETLINEWIDTH: \", this.ctx.lineWidth);\n                    }\n                    break;\n                case D2DType.D2D_MOVETO:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        this.ctx.moveTo(x, y);\n                    }\n                    break;\n                case D2DType.D2D_LINETO:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        this.ctx.lineTo(x, y);\n                    }\n                    break;\n                case D2DType.D2D_BEZIERTO:\n                    {\n                        const cp1x = owner.getDouble(currentInsParams);\n                        const cp1y = owner.getDouble(currentInsParams + 8);\n                        const cp2x = owner.getDouble(currentInsParams + 16);\n                        const cp2y = owner.getDouble(currentInsParams + 24);\n                        const x = owner.getDouble(currentInsParams + 32);\n                        const y = owner.getDouble(currentInsParams + 40);\n                        this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n                    }\n                    break;\n                case D2DType.D2D_BEGINPATH:\n                    {\n                        this.ctx.beginPath();\n                    }\n                    break;\n                case D2DType.D2D_FILL:\n                    {\n                        this.ctx.fill();\n                    }\n                    break;\n                case D2DType.D2D_SAVE:\n                    {\n                        this.ctx.save();\n                    }\n                    break;\n                case D2DType.D2D_RESTORE:\n                    {\n                        this.ctx.restore();\n                    }\n                    break;\n                case D2DType.D2D_STROKE:\n                    {\n                        this.ctx.stroke();\n                    }\n                    break;\n                case D2DType.D2D_ARC:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const radius = owner.getDouble(currentInsParams + 16);\n                        const startAngle = owner.getDouble(currentInsParams + 24);\n                        const endAngle = owner.getDouble(currentInsParams + 32);\n                        const counterClockwise = (owner.getLong(currentInsParams + 40) != 0);\n                        this.ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise);\n                    }\n                    break;\n                case D2DType.D2D_IMAGEDATA:\n                    {\n                        const start = owner.getLong(currentInsParams);\n                        const length = owner.getLong(currentInsParams + 4);\n                        const width = owner.getLong(currentInsParams + 8);\n                        const height = owner.getLong(currentInsParams + 12);\n                        const id = owner.getLong(currentInsParams + 16);\n                        if (id in this.precomputedObjects)\n                            console.log(\"warning: D2D_IMAGEDATA ID already exists.\");\n                        if (this.isAsyncMod) { // Uint8ClampedArray doesn't support shared memory\n                            this.precomputedObjects[id] = { mem8: new Uint8Array(owner.memory.buffer, start, length), width: width, height: height };\n                        }\n                        else {\n                            const z = new Uint8ClampedArray(owner.memory.buffer, start, length);\n                            this.precomputedObjects[id] = new ImageData(z, width, height);\n                        }\n                    }\n                    break;\n                case D2DType.D2D_CREATERADIALGRADIENT:\n                    {\n                        const x0 = owner.getDouble(currentInsParams);\n                        const y0 = owner.getDouble(currentInsParams + 8);\n                        const radius0 = owner.getDouble(currentInsParams + 16);\n                        const x1 = owner.getDouble(currentInsParams + 24);\n                        const y1 = owner.getDouble(currentInsParams + 32);\n                        const radius1 = owner.getDouble(currentInsParams + 40);\n                        const id = owner.getLong(currentInsParams + 48);\n                        let gradient = this.ctx.createRadialGradient(x0, y0, radius0, x1, y1, radius1);\n                        if (id in this.precomputedObjects)\n                            console.log(\"warning: D2D_CREATERADIALGRADIENT ID already exists.\");\n                        this.precomputedObjects[id] = gradient;\n                    }\n                    break;\n                case D2DType.D2D_CREATELINEARGRADIENT:\n                    {\n                        const x0 = owner.getDouble(currentInsParams);\n                        const y0 = owner.getDouble(currentInsParams + 8);\n                        const x1 = owner.getDouble(currentInsParams + 16);\n                        const y1 = owner.getDouble(currentInsParams + 24);\n                        const id = owner.getLong(currentInsParams + 32);\n                        let gradient = this.ctx.createLinearGradient(x0, y0, x1, y1);\n                        if (id in this.precomputedObjects)\n                            console.log(\"warning: D2D_CREATELINEARGRADIENT ID already exists.\");\n                        this.precomputedObjects[id] = gradient;\n                    }\n                    break;\n                case D2DType.D2D_SETCOLORSTOP:\n                    {\n                        const id = owner.getLong(currentInsParams);\n                        const pos = owner.getLong(currentInsParams + 4);\n                        const cssColorPointer = owner.getLong(currentInsParams + 8);\n                        const cssColor = owner.getString(cssColorPointer);\n                        if (!(id in this.precomputedObjects))\n                            throw new Error(\"D2D_SETCOLORSTOP with invalid ID: \" + id);\n                        const gradient = this.precomputedObjects[id];\n                        gradient.addColorStop(pos, cssColor);\n                    }\n                    break;\n                case D2DType.D2D_SETFILLSTYLEGRADIENT:\n                    {\n                        const id = owner.getLong(currentInsParams);\n                        if (!(id in this.precomputedObjects))\n                            throw new Error(\"D2D_SETFILLSTYLEGRADIENT with invalid ID: \" + id);\n                        const gradient = this.precomputedObjects[id];\n                        this.ctx.fillStyle = gradient;\n                    }\n                    break;\n                case D2DType.D2D_RELEASEID:\n                    {\n                        const id = owner.getLong(currentInsParams);\n                        if (this.precomputedObjects[id])\n                            delete this.precomputedObjects[id];\n                        else\n                            console.log(\"warning: D2D_RELEASEID with undefined ID \", id);\n                    }\n                    break;\n                case D2DType.D2D_PUTIMAGEDATA:\n                    {\n                        const id = owner.getLong(currentInsParams);\n                        const dx = owner.getLong(currentInsParams + 4);\n                        const dy = owner.getLong(currentInsParams + 8);\n                        const dirtyX = owner.getLong(currentInsParams + 12);\n                        const dirtyY = owner.getLong(currentInsParams + 16);\n                        const dirtyWidth = owner.getLong(currentInsParams + 20);\n                        const dirtyHeight = owner.getLong(currentInsParams + 24);\n                        if (!(id in this.precomputedObjects))\n                            throw new Error(\"D2D_PUTIMAGEDATA with invalid ID: \" + id);\n                        //console.log(\"D2D_PUTIMAGEDATA\",start, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight, this.imageData[start]);\n                        let imgData;\n                        if (this.isAsyncMod) { // Uint8ClampedArray doesn't support shared memory, so copy the memory\n                            //console.log(\"D2D_PUTIMAGEDATA wasmModuleAsync\");\n                            const z = this.precomputedObjects[id]; // Uint8Array\n                            const ca = Uint8ClampedArray.from(z.mem8); // shallow copy\n                            imgData = new ImageData(ca, z.width, z.height);\n                        }\n                        else {\n                            imgData = this.precomputedObjects[id];\n                        }\n                        if (dirtyWidth == 0 && dirtyHeight == 0) {\n                            this.ctx.putImageData(imgData, dx, dy);\n                        }\n                        else {\n                            this.ctx.putImageData(imgData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n                        }\n                    }\n                    break;\n                case D2DType.D2D_CLOSEPATH:\n                    {\n                        this.ctx.closePath();\n                    }\n                    break;\n                case D2DType.D2D_RESET:\n                    {\n                        this.ctx.reset();\n                    }\n                    break;\n                case D2DType.D2D_CLEARRECT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const w = owner.getDouble(currentInsParams + 16);\n                        const h = owner.getDouble(currentInsParams + 24);\n                        this.ctx.clearRect(x, y, w, h);\n                    }\n                    break;\n                case D2DType.D2D_SCALE:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        this.ctx.scale(x, y);\n                    }\n                    break;\n                case D2DType.D2D_TRANSLATE:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        this.ctx.translate(x, y);\n                    }\n                    break;\n                case D2DType.D2D_ROTATE:\n                    {\n                        const angle = owner.getDouble(currentInsParams);\n                        this.ctx.rotate(angle);\n                    }\n                    break;\n                case D2DType.D2D_GETTRANSFORM:\n                    {\n                        const matrix_ptr = owner.getLong(currentInsParams);\n                        const transform = this.ctx.getTransform();\n                        owner.setDouble(matrix_ptr + 0, transform.a);\n                        owner.setDouble(matrix_ptr + 8, transform.b);\n                        owner.setDouble(matrix_ptr + 16, transform.c);\n                        owner.setDouble(matrix_ptr + 24, transform.d);\n                        owner.setDouble(matrix_ptr + 32, transform.e);\n                        owner.setDouble(matrix_ptr + 40, transform.f);\n                    }\n                    break;\n                case D2DType.D2D_SETTRANSFORM:\n                    {\n                        const a = owner.getDouble(currentInsParams);\n                        const b = owner.getDouble(currentInsParams + 8);\n                        const c = owner.getDouble(currentInsParams + 16);\n                        const d = owner.getDouble(currentInsParams + 24);\n                        const e = owner.getDouble(currentInsParams + 32);\n                        const f = owner.getDouble(currentInsParams + 40);\n                        this.ctx.setTransform(a, b, c, d, e, f);\n                    }\n                    break;\n                case D2DType.D2D_RESETTRANSFORM:\n                    {\n                        this.ctx.resetTransform();\n                    }\n                    break;\n                case D2DType.D2D_STROKETEXT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const codePage = owner.getLong(currentInsParams + 20);\n                        const strPointer = owner.getLong(currentInsParams + 16);\n                        const str = owner.getString(strPointer, undefined, codePage);\n                        this.ctx.strokeText(str, x, y);\n                    }\n                    break;\n                case D2DType.D2D_ROUNDRECT:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const width = owner.getDouble(currentInsParams + 16);\n                        const height = owner.getDouble(currentInsParams + 24);\n                        const radii = owner.getDouble(currentInsParams + 32);\n                        this.ctx.roundRect(x, y, width, height, radii);\n                    }\n                    break;\n                case D2DType.D2D_ELLIPSE:\n                    {\n                        const x = owner.getDouble(currentInsParams);\n                        const y = owner.getDouble(currentInsParams + 8);\n                        const radiusX = owner.getDouble(currentInsParams + 16);\n                        const radiusY = owner.getDouble(currentInsParams + 24);\n                        const rotation = owner.getDouble(currentInsParams + 32);\n                        const startAngle = owner.getDouble(currentInsParams + 40);\n                        const endAngle = owner.getDouble(currentInsParams + 48);\n                        const counterClockwise = (owner.getLong(currentInsParams + 56) != 0);\n                        this.ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterClockwise);\n                    }\n                    break;\n                case D2DType.D2D_QUADRATICCURVETO:\n                    {\n                        const cpx = owner.getDouble(currentInsParams);\n                        const cpy = owner.getDouble(currentInsParams + 8);\n                        const x = owner.getDouble(currentInsParams + 16);\n                        const y = owner.getDouble(currentInsParams + 24);\n                        this.ctx.quadraticCurveTo(cpx, cpy, x, y);\n                    }\n                    break;\n                case D2DType.D2D_SETLINEDASH:\n                    {\n                        const segment_len = owner.getLong(currentInsParams);\n                        const seg_ptr = owner.getLong(currentInsParams + 4);\n                        let segments = [];\n                        for (let i = 0; i < segment_len; i++) {\n                            segments[i] = owner.getDouble(seg_ptr + i * 8);\n                        }\n                        this.ctx.setLineDash(segments);\n                    }\n                    break;\n                case D2DType.D2D_GETLINEDASH:\n                    {\n                        const segments = this.ctx.getLineDash();\n                        const buffer_length = owner.getLong(currentInsParams);\n                        const buffer_ptr = owner.getLong(currentInsParams + 4);\n                        const segment_length_ptr = currentInsParams + 8;\n                        owner.setLong(segment_length_ptr, segments.length);\n                        if (segments.length > 0) {\n                            for (let i = 0; i < Math.min(segments.length, buffer_length); i++) {\n                                owner.setDouble(buffer_ptr + i * 8, segments[i]);\n                            }\n                            if (segments.length > buffer_length) {\n                                console.log(\"warning: D2D_GETLINEDASH exceeded given max_length, truncating excess\");\n                            }\n                        }\n                    }\n                    break;\n                case D2DType.D2D_ARCTO:\n                    {\n                        const x1 = owner.getDouble(currentInsParams);\n                        const y1 = owner.getDouble(currentInsParams + 8);\n                        const x2 = owner.getDouble(currentInsParams + 16);\n                        const y2 = owner.getDouble(currentInsParams + 24);\n                        const radius = owner.getDouble(currentInsParams + 32);\n                        this.ctx.arcTo(x1, y1, x2, y2, radius);\n                    }\n                    break;\n                case D2DType.D2D_GETLINEDASHLENGTH:\n                    {\n                        owner.setLong(currentInsParams, this.ctx.getLineDash().length);\n                    }\n                    break;\n                default:\n                    throw new Error(\"unimplemented or unknown Sequence Type in drawSeq: \" + type);\n            }\n            nextInsHdr = owner.getLong(currentInsHdr); /* hdr->next */\n            if (nextInsHdr == 0) {\n                if (currentInsHdr != lastInsHdr)\n                    throw new Error(\"assert type error in twrcanvas, ins!=lastins\");\n                break;\n            }\n            currentInsHdr = nextInsHdr;\n            currentInsParams = currentInsHdr + insHdrSize;\n        }\n        if (this.cmdCompleteSignal)\n            this.cmdCompleteSignal.signal();\n        //console.log(\"Canvas.drawSeq() completed  with instruction count of \", insCount);\n    }\n}\nexport class twrConsoleCanvasProxy {\n    canvasKeys;\n    drawCompleteSignal;\n    props;\n    id;\n    constructor(params) {\n        const [className, id, props, signalBuffer, canvasKeysBuffer] = params;\n        this.drawCompleteSignal = new twrSignal(signalBuffer);\n        this.canvasKeys = new twrSharedCircularBuffer(canvasKeysBuffer);\n        this.props = props;\n        this.id = id;\n        //console.log(\"Create New twrCanvasProxy: \",this.props)\n    }\n    charIn() {\n        //ctx.commit(); not avail in chrome\n        //postMessage([\"debug\", 'x']);\n        return this.canvasKeys.readWait(); // wait for a key, then read it\n    }\n    inkey() {\n        if (this.canvasKeys.isEmpty())\n            return 0;\n        else\n            return this.charIn();\n    }\n    // note that this implementation does not allow a property to change post creation of an instance of this class\n    getProp(propName) {\n        return this.props[propName];\n    }\n    drawSeq(ds) {\n        this.drawCompleteSignal.reset();\n        postMessage([\"canvas2d-drawseq\", [this.id, ds]]);\n        this.drawCompleteSignal.wait();\n    }\n}\n//# sourceMappingURL=twrcanvas.js.map","import {twrWasmModuleBase} from \"./twrmodbase.js\"\nimport {twrSharedCircularBuffer} from \"./twrcircular.js\";\nimport {twrSignal} from \"./twrsignal.js\";\nimport {IConsoleCanvas, IConsoleCanvasProxy, ICanvasProps, TConsoleCanvasProxyParams, IOTypes} from \"./twrcon.js\";\nimport {twrConsoleRegistry} from \"./twrconreg.js\"\n\nenum D2DType {\n    D2D_FILLRECT=1,\n    D2D_FILLCODEPOINT=5,\n    D2D_SETLINEWIDTH=10,\n    D2D_SETFILLSTYLERGBA=11,\n    D2D_SETFONT=12,\n    D2D_BEGINPATH=13,\n    D2D_MOVETO=14,\n    D2D_LINETO=15,\n    D2D_FILL=16,\n    D2D_STROKE=17,\n    D2D_SETSTROKESTYLERGBA=18,\n    D2D_ARC=19,\n    D2D_STROKERECT=20,\n    D2D_FILLTEXT=21,\n    D2D_IMAGEDATA=22,\n    D2D_PUTIMAGEDATA=23,\n    D2D_BEZIERTO=24,\n    D2D_MEASURETEXT=25,\n    D2D_SAVE=26,\n    D2D_RESTORE=27,\n    D2D_CREATERADIALGRADIENT=28,\n    D2D_SETCOLORSTOP=29,\n    D2D_SETFILLSTYLEGRADIENT=30,\n    D2D_RELEASEID=31,\n    D2D_CREATELINEARGRADIENT=32,\n    D2D_SETFILLSTYLE=33,\n    D2D_SETSTROKESTYLE=34,\n    D2D_CLOSEPATH=35,\n    D2D_RESET=36,\n    D2D_CLEARRECT=37,\n    D2D_SCALE=38,\n    D2D_TRANSLATE=39,\n    D2D_ROTATE=40,\n    D2D_GETTRANSFORM = 41,\n    D2D_SETTRANSFORM = 42,\n    D2D_RESETTRANSFORM = 43,\n    D2D_STROKETEXT = 44,\n    D2D_ROUNDRECT = 45,\n    D2D_ELLIPSE = 46,\n    D2D_QUADRATICCURVETO = 47,\n    D2D_SETLINEDASH = 48,\n    D2D_GETLINEDASH = 49,\n    D2D_ARCTO = 50,\n    D2D_GETLINEDASHLENGTH = 51,\n}\n\nexport class twrConsoleCanvas implements IConsoleCanvas {\n   ctx:CanvasRenderingContext2D;\n   id:number;\n   element:HTMLCanvasElement\n   props:ICanvasProps;\n   cmdCompleteSignal?:twrSignal;\n   canvasKeys?: twrSharedCircularBuffer;\n   isAsyncMod:boolean;\n   precomputedObjects: {  [index: number]: \n      (ImageData | \n      {mem8:Uint8Array, width:number, height:number})  |\n      CanvasGradient\n   };\n\n   constructor(element:HTMLCanvasElement) {\n      this.isAsyncMod=false; // set to true if getProxyParams called\n\n      this.precomputedObjects={};\n\n      if (!element.getContext) throw new Error(\"attempted to create new twrCanvas with an element that is not a valid HTMLCanvasElement\");\n      this.element=element;\n\n      const c=element.getContext(\"2d\");\n      if (!c) throw new Error(\"canvas 2D context not found in twrCanvasConstructor\");\n      this.ctx=c;\n\n      // these two lines are for backwards compatibility with prior version of twr-wasm\n      c.font = \"16 px Courier New\";\n      c.textBaseline=\"top\";\n\n      this.props = {canvasHeight: element.height, canvasWidth: element.width, type: IOTypes.CANVAS2D}; \n      this.id=twrConsoleRegistry.registerConsole(this);\n   }\n\n   // these are the parameters needed to create a twrConsoleCanvasProxy, paired to us\n   getProxyParams() : TConsoleCanvasProxyParams {\n      this.cmdCompleteSignal=new twrSignal();\n      this.canvasKeys = new twrSharedCircularBuffer();  // tsconfig, lib must be set to 2017 or higher\n      this.isAsyncMod=true;\n      return [\"twrConsoleCanvasProxy\", this.id, this.props, this.cmdCompleteSignal.sharedArray, this.canvasKeys.sharedArray];\n   }\n\n    getProp(name:keyof ICanvasProps): number {\n      return this.props[name];\n   }\n\n   // process messages sent from twrConsoleCanvasProxy\n   // these are used to \"remote procedure call\" from the worker thread to the JS Main thread\n   processMessage(msgType:string, data:[number, ...any[]], callingModule:twrWasmModuleBase):boolean {\n      const [id, ...params] = data;\n      if (id!=this.id) throw new Error(\"internal error\");  // should never happen\n\n      switch (msgType) {\n         case \"canvas2d-drawseq\":\n         {\n            const [ds] =  params;\n            this.drawSeq(ds, callingModule);\n            break;\n         }\n\n         default:\n            return false;\n      }\n\n      return true;\n   }\n\n   /* see draw2d.h for structs that match */\n   drawSeq(ds:number, owner:twrWasmModuleBase) {\n      //console.log(\"twr::Canvas enter drawSeq\");\n      if (!this.ctx) return;\n        const insHdrSize = 16;\n        let currentInsHdr=owner.getLong(ds);  /* ds->start */\n        const lastInsHdr=owner.getLong(ds+4);  /* ds->last */\n        let currentInsParams = currentInsHdr + insHdrSize;\n        //console.log(\"instruction start, last \",ins.toString(16), lastins.toString(16));\n\n        let nextInsHdr:number;\n        //let insCount=0;\n        \n        while (1) {\n\n         //insCount++;\n\n            const type:D2DType=owner.getLong(currentInsHdr+4);    /* hdr->type */\n            if (0/*type!=D2DType.D2D_FILLRECT*/) {\n                console.log(\"ins\",currentInsHdr)\n                console.log(\"hdr.next\",owner.mem8[currentInsHdr],owner.mem8[currentInsHdr+1],owner.mem8[currentInsHdr+2],owner.mem8[currentInsHdr+3]);\n                console.log(\"hdr.type\",owner.mem8[currentInsHdr+4],owner.mem8[currentInsHdr+5]);\n                console.log(\"next 4 bytes\", owner.mem8[currentInsHdr+6],owner.mem8[currentInsHdr+7],owner.mem8[currentInsHdr+8],owner.mem8[currentInsHdr+9]);\n                console.log(\"and 4 more \", owner.mem8[currentInsHdr+10],owner.mem8[currentInsHdr+11],owner.mem8[currentInsHdr+12],owner.mem8[currentInsHdr+13]);\n                //console.log(\"ins, type, next is \", ins.toString(16), type.toString(16), next.toString(16));\n             }\n            switch (type) {\n                case D2DType.D2D_FILLRECT:\n                {\n                    const x=owner.getDouble(currentInsParams);\n                    const y=owner.getDouble(currentInsParams+8);\n                    const w=owner.getDouble(currentInsParams+16);\n                    const h=owner.getDouble(currentInsParams+24);\n                    this.ctx.fillRect(x, y, w, h);\n                }\n                    break;\n\n                case D2DType.D2D_STROKERECT:\n                {\n                    const x=owner.getDouble(currentInsParams);\n                    const y=owner.getDouble(currentInsParams+8);\n                    const w=owner.getDouble(currentInsParams+16);\n                    const h=owner.getDouble(currentInsParams+24);\n                    this.ctx.strokeRect(x, y, w, h);\n                }\n                    break;\n\n                case D2DType.D2D_FILLCODEPOINT:\n                {\n                    const x=owner.getDouble(currentInsParams);\n                    const y=owner.getDouble(currentInsParams+8);\n                    const c=owner.getLong(currentInsParams+16);\n                    let txt=String.fromCodePoint(c);\n                    this.ctx.fillText(txt, x, y);\n                }\n                    break;\n\n                \n                case D2DType.D2D_FILLTEXT:\n                {\n                    const x=owner.getDouble(currentInsParams);\n                    const y=owner.getDouble(currentInsParams+8);\n                    const codePage=owner.getLong(currentInsParams+20);\n                    const strPointer = owner.getLong(currentInsParams+16);\n                    const str=owner.getString(strPointer, undefined, codePage);\n\n                    //console.log(\"filltext \",x,y,str)\n    \n                    this.ctx.fillText(str, x, y);\n                }\n                    break;\n\n                case D2DType.D2D_MEASURETEXT:\n                {\n                    const codePage=owner.getLong(currentInsParams+8);\n                    const str=owner.getString(owner.getLong(currentInsParams), undefined, codePage);\n                    const tmidx=owner.getLong(currentInsParams+4);\n    \n                    const tm=this.ctx.measureText(str);\n                    owner.setDouble(tmidx+0, tm.actualBoundingBoxAscent);\n                    owner.setDouble(tmidx+8, tm.actualBoundingBoxDescent);\n                    owner.setDouble(tmidx+16, tm.actualBoundingBoxLeft);\n                    owner.setDouble(tmidx+24, tm.actualBoundingBoxRight);\n                    owner.setDouble(tmidx+32, tm.fontBoundingBoxAscent);\n                    owner.setDouble(tmidx+40, tm.fontBoundingBoxDescent);\n                    owner.setDouble(tmidx+48, tm.width);\n                }\n                    break;\n\n                case D2DType.D2D_SETFONT:\n                {\n                    const fontPointer = owner.getLong(currentInsParams);\n                    const str=owner.getString(fontPointer);\n                    this.ctx.font=str;\n                }\n                    break;\n\n                case D2DType.D2D_SETFILLSTYLERGBA:\n                {\n                    const color=owner.getLong(currentInsParams); \n                    const cssColor= \"#\"+(\"00000000\" + color.toString(16)).slice(-8);\n                    this.ctx.fillStyle = cssColor;\n                    //console.log(\"fillstyle: \", this.ctx.fillStyle, \":\", cssColor,\":\", color)\n                }\n                    break;\n\n                case D2DType.D2D_SETSTROKESTYLERGBA:\n                {\n                    const color=owner.getLong(currentInsParams); \n                    const cssColor= \"#\"+(\"00000000\" + color.toString(16)).slice(-8);\n                    this.ctx.strokeStyle = cssColor;\n                }\n                    break;\n\n                case D2DType.D2D_SETFILLSTYLE:\n                {\n                    const cssColorPointer = owner.getLong(currentInsParams);\n                    const cssColor= owner.getString(cssColorPointer);\n                    this.ctx.fillStyle = cssColor;\n                }\n                    break\n\n                case D2DType.D2D_SETSTROKESTYLE:\n                {\n                    const cssColorPointer = owner.getLong(currentInsParams);\n                    const cssColor= owner.getString(cssColorPointer);\n                    this.ctx.strokeStyle = cssColor;\n                }\n                    break\n\n                case D2DType.D2D_SETLINEWIDTH:\n                {\n                    const width=owner.getDouble(currentInsParams);  \n                    this.ctx.lineWidth=width;\n                    //console.log(\"twrCanvas D2D_SETLINEWIDTH: \", this.ctx.lineWidth);\n                }\n                    break;\n\n                case D2DType.D2D_MOVETO:\n                {\n                    const x=owner.getDouble(currentInsParams);\n                    const y=owner.getDouble(currentInsParams+8);\n                    this.ctx.moveTo(x, y);\n                }\n                    break;\n\n                case D2DType.D2D_LINETO:\n                {\n                    const x=owner.getDouble(currentInsParams);\n                    const y=owner.getDouble(currentInsParams+8);\n                    this.ctx.lineTo(x, y);\n                }\n                    break;\n\n                case D2DType.D2D_BEZIERTO:\n                {\n                    const cp1x=owner.getDouble(currentInsParams);\n                    const cp1y=owner.getDouble(currentInsParams+8);\n                    const cp2x=owner.getDouble(currentInsParams+16);\n                    const cp2y=owner.getDouble(currentInsParams+24);\n                    const x=owner.getDouble(currentInsParams+32);\n                    const y=owner.getDouble(currentInsParams+40);\n                    this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n                }\n                    break;\n\n            case D2DType.D2D_BEGINPATH:\n            {\n               this.ctx.beginPath();\n            }\n               break;\n\n            case D2DType.D2D_FILL:\n            {\n               this.ctx.fill();\n            }\n               break;\n\n            case D2DType.D2D_SAVE:\n            {\n               this.ctx.save();\n            }\n               break;\n\n            case D2DType.D2D_RESTORE:\n            {\n               this.ctx.restore();\n            }\n               break;\n\n            case D2DType.D2D_STROKE:\n            {\n               this.ctx.stroke();\n            }\n               break;\n\n                case D2DType.D2D_ARC:\n                {\n                    const x=owner.getDouble(currentInsParams);\n                    const y=owner.getDouble(currentInsParams+8);\n                    const radius=owner.getDouble(currentInsParams+16);\n                    const startAngle=owner.getDouble(currentInsParams+24);\n                    const endAngle=owner.getDouble(currentInsParams+32);\n                    const counterClockwise= (owner.getLong(currentInsParams+40)!=0);\n\n               this.ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise)\n            }\n               break;\n\n                case D2DType.D2D_IMAGEDATA:\n                {\n                    const start=owner.getLong(currentInsParams);\n                    const length=owner.getLong(currentInsParams+4);\n                    const width=owner.getLong(currentInsParams+8);\n                    const height=owner.getLong(currentInsParams+12);\n                    const id=owner.getLong(currentInsParams+16);\n\n               if ( id in this.precomputedObjects ) console.log(\"warning: D2D_IMAGEDATA ID already exists.\");\n\n            if (this.isAsyncMod) {  // Uint8ClampedArray doesn't support shared memory\n               this.precomputedObjects[id]={mem8: new Uint8Array(owner.memory!.buffer, start, length), width:width, height:height};\n            }\n            else {\n               const z = new Uint8ClampedArray(owner.memory!.buffer, start, length);\n               this.precomputedObjects[id]=new ImageData(z, width, height);\n            }\n            }\n               break;\n\n                case D2DType.D2D_CREATERADIALGRADIENT:\n                {\n                    const x0=owner.getDouble(currentInsParams);\n                    const y0=owner.getDouble(currentInsParams+8);\n                    const radius0=owner.getDouble(currentInsParams+16);\n                    const x1=owner.getDouble(currentInsParams+24);\n                    const y1=owner.getDouble(currentInsParams+32);\n                    const radius1=owner.getDouble(currentInsParams+40);\n                    const id= owner.getLong(currentInsParams+48);\n\n                  let gradient=this.ctx.createRadialGradient(x0, y0, radius0, x1, y1, radius1);\n                  if ( id in this.precomputedObjects ) console.log(\"warning: D2D_CREATERADIALGRADIENT ID already exists.\");\n                  this.precomputedObjects[id] = gradient;\n               }\n                  break\n\n                case D2DType.D2D_CREATELINEARGRADIENT:\n                    {\n                        const x0=owner.getDouble(currentInsParams);\n                        const y0=owner.getDouble(currentInsParams+8);\n                        const x1=owner.getDouble(currentInsParams+16);\n                        const y1=owner.getDouble(currentInsParams+24);\n                        const id= owner.getLong(currentInsParams+32);\n    \n                        let gradient=this.ctx.createLinearGradient(x0, y0, x1, y1);\n                        if ( id in this.precomputedObjects ) console.log(\"warning: D2D_CREATELINEARGRADIENT ID already exists.\");\n                        this.precomputedObjects[id] = gradient;\n                    }\n                        break\n\n                case D2DType.D2D_SETCOLORSTOP:\n                {\n                    const id = owner.getLong(currentInsParams);\n                    const pos=owner.getLong(currentInsParams+4);\n                    const cssColorPointer = owner.getLong(currentInsParams+8);\n                    const cssColor= owner.getString(cssColorPointer);\n\n                    if (!(id in this.precomputedObjects)) throw new Error(\"D2D_SETCOLORSTOP with invalid ID: \"+id);\n                    const gradient=this.precomputedObjects[id] as CanvasGradient;\n                    gradient.addColorStop(pos, cssColor);\n\n                }\n                    break\n\n                case D2DType.D2D_SETFILLSTYLEGRADIENT:\n                {\n                    const id=owner.getLong(currentInsParams);\n                    if (!(id in this.precomputedObjects)) throw new Error(\"D2D_SETFILLSTYLEGRADIENT with invalid ID: \"+id);\n                    const gradient=this.precomputedObjects[id] as CanvasGradient;\n                    this.ctx.fillStyle=gradient;\n                }\n                    break\n\n                case D2DType.D2D_RELEASEID:\n                {\n                    const id=owner.getLong(currentInsParams);\n                    if (this.precomputedObjects[id])\n                        delete this.precomputedObjects[id];\n                    else\n                        console.log(\"warning: D2D_RELEASEID with undefined ID \",id);\n                }\n                    break\n\n                  \n\n                case D2DType.D2D_PUTIMAGEDATA:\n                {\n                    const id=owner.getLong(currentInsParams);\n                    const dx=owner.getLong(currentInsParams+4);\n                    const dy=owner.getLong(currentInsParams+8);\n                    const dirtyX=owner.getLong(currentInsParams+12);\n                    const dirtyY=owner.getLong(currentInsParams+16);\n                    const dirtyWidth=owner.getLong(currentInsParams+20);\n                    const dirtyHeight=owner.getLong(currentInsParams+24);\n\n                  if (!(id in this.precomputedObjects)) throw new Error(\"D2D_PUTIMAGEDATA with invalid ID: \"+id);\n\n                  //console.log(\"D2D_PUTIMAGEDATA\",start, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight, this.imageData[start]);\n\n                  let imgData:ImageData;\n     \n                  if (this.isAsyncMod) {  // Uint8ClampedArray doesn't support shared memory, so copy the memory\n                     //console.log(\"D2D_PUTIMAGEDATA wasmModuleAsync\");\n                     const z = this.precomputedObjects[id] as {mem8:Uint8Array, width:number, height:number}; // Uint8Array\n                     const ca=Uint8ClampedArray.from(z.mem8);  // shallow copy\n                     imgData=new ImageData(ca, z.width, z.height);\n                  }\n                  else  {\n                     imgData=this.precomputedObjects[id] as ImageData;\n                  }\n                  \n                  if (dirtyWidth==0 && dirtyHeight==0) {\n                     this.ctx.putImageData(imgData, dx, dy);\n                  }\n                  else {\n                     this.ctx.putImageData(imgData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n                  }\n               }\n                  break;\n\n                case D2DType.D2D_CLOSEPATH:\n                {\n                    this.ctx.closePath();\n                }\n                    break;\n                \n                case D2DType.D2D_RESET:\n                {\n                    this.ctx.reset();\n                }\n                    break;\n\n                case D2DType.D2D_CLEARRECT:\n                {\n                    const x=owner.getDouble(currentInsParams);\n                    const y=owner.getDouble(currentInsParams+8);\n                    const w=owner.getDouble(currentInsParams+16);\n                    const h=owner.getDouble(currentInsParams+24);\n                    this.ctx.clearRect(x, y, w, h);\n                }\n                    break;\n                \n                case D2DType.D2D_SCALE:\n                {\n                    const x=owner.getDouble(currentInsParams);\n                    const y=owner.getDouble(currentInsParams+8);\n                    this.ctx.scale(x, y);\n                }\n                    break;\n                \n                case D2DType.D2D_TRANSLATE:\n                {\n                    const x=owner.getDouble(currentInsParams);\n                    const y=owner.getDouble(currentInsParams+8);\n                    this.ctx.translate(x, y);\n                }\n                    break;\n                case D2DType.D2D_ROTATE:\n                {\n                    const angle=owner.getDouble(currentInsParams);\n                    this.ctx.rotate(angle);\n                }\n                    break;\n\n                case D2DType.D2D_GETTRANSFORM:\n                {\n                    const matrix_ptr=owner.getLong(currentInsParams);\n                    const transform=this.ctx.getTransform();\n                    owner.setDouble(matrix_ptr+0, transform.a);\n                    owner.setDouble(matrix_ptr+8, transform.b);\n                    owner.setDouble(matrix_ptr+16, transform.c);\n                    owner.setDouble(matrix_ptr+24, transform.d);\n                    owner.setDouble(matrix_ptr+32, transform.e);\n                    owner.setDouble(matrix_ptr+40, transform.f);\n                }\n                    break;\n                \n                case D2DType.D2D_SETTRANSFORM:\n                {\n                    const a = owner.getDouble(currentInsParams);\n                    const b = owner.getDouble(currentInsParams+8);\n                    const c = owner.getDouble(currentInsParams+16);\n                    const d = owner.getDouble(currentInsParams+24);\n                    const e = owner.getDouble(currentInsParams+32);\n                    const f = owner.getDouble(currentInsParams+40);\n\n                    this.ctx.setTransform(a, b, c, d, e, f);\n                }\n                    break;\n                \n                case D2DType.D2D_RESETTRANSFORM:\n                {\n                    this.ctx.resetTransform();\n                }\n                    break;\n                \n                case D2DType.D2D_STROKETEXT:\n                {\n                    const x=owner.getDouble(currentInsParams);\n                    const y=owner.getDouble(currentInsParams+8);\n                    const codePage=owner.getLong(currentInsParams+20);\n                    const strPointer = owner.getLong(currentInsParams+16);\n                    const str=owner.getString(strPointer, undefined, codePage);\n    \n                    this.ctx.strokeText(str, x, y);\n                }\n                    break;\n                \n                case D2DType.D2D_ROUNDRECT:\n                {\n                    const x = owner.getDouble(currentInsParams);\n                    const y = owner.getDouble(currentInsParams+8);\n                    const width = owner.getDouble(currentInsParams+16);\n                    const height = owner.getDouble(currentInsParams+24);\n                    const radii = owner.getDouble(currentInsParams+32);\n\n                    this.ctx.roundRect(x, y, width, height, radii);\n                }\n                    break;\n                \n                case D2DType.D2D_ELLIPSE:\n                {\n                    const x=owner.getDouble(currentInsParams);\n                    const y=owner.getDouble(currentInsParams+8);\n                    const radiusX=owner.getDouble(currentInsParams+16);\n                    const radiusY=owner.getDouble(currentInsParams+24);\n                    const rotation=owner.getDouble(currentInsParams+32);\n                    const startAngle=owner.getDouble(currentInsParams+40);\n                    const endAngle=owner.getDouble(currentInsParams+48);\n                    const counterClockwise= (owner.getLong(currentInsParams+56)!=0);\n\n                    this.ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterClockwise)\n                }\n                    break;\n                \n                case D2DType.D2D_QUADRATICCURVETO:\n                {\n                    const cpx = owner.getDouble(currentInsParams);\n                    const cpy = owner.getDouble(currentInsParams+8);\n                    const x = owner.getDouble(currentInsParams+16);\n                    const y = owner.getDouble(currentInsParams+24);\n\n                    this.ctx.quadraticCurveTo(cpx, cpy, x, y);\n                }\n                    break;\n                \n                case D2DType.D2D_SETLINEDASH:\n                {\n                    const segment_len = owner.getLong(currentInsParams);\n                    const seg_ptr = owner.getLong(currentInsParams+4);\n                    let segments = [];\n                    for (let i = 0; i < segment_len; i++) {\n                        segments[i] = owner.getDouble(seg_ptr + i*8);\n                    }\n                    this.ctx.setLineDash(segments);\n                }\n                    break;\n\n                case D2DType.D2D_GETLINEDASH:\n                {\n                    const segments = this.ctx.getLineDash();\n\n                    const buffer_length = owner.getLong(currentInsParams);\n                    const buffer_ptr = owner.getLong(currentInsParams+4);\n                    const segment_length_ptr = currentInsParams+8;\n\n                    owner.setLong(segment_length_ptr, segments.length);\n                    if (segments.length > 0) {\n                        for (let i = 0; i < Math.min(segments.length, buffer_length); i++) {\n                            owner.setDouble(buffer_ptr + i*8, segments[i]);\n                        }\n                        if (segments.length > buffer_length) {\n                            console.log(\"warning: D2D_GETLINEDASH exceeded given max_length, truncating excess\");\n                        }\n                    }\n                }\n                    break;\n                \n                case D2DType.D2D_ARCTO:\n                {\n                    const x1 = owner.getDouble(currentInsParams);\n                    const y1 = owner.getDouble(currentInsParams+8);\n                    const x2 = owner.getDouble(currentInsParams+16);\n                    const y2 = owner.getDouble(currentInsParams+24);\n                    const radius = owner.getDouble(currentInsParams+32);\n\n                    this.ctx.arcTo(x1, y1, x2, y2, radius);\n                }\n                    break;\n                \n                case D2DType.D2D_GETLINEDASHLENGTH:\n                {\n                    owner.setLong(currentInsParams, this.ctx.getLineDash().length);\n                }\n                    break;\n                default:\n                    throw new Error (\"unimplemented or unknown Sequence Type in drawSeq: \"+type);\n            }\n            nextInsHdr=owner.getLong(currentInsHdr);  /* hdr->next */\n            if (nextInsHdr==0) {\n                if (currentInsHdr!=lastInsHdr) throw new Error(\"assert type error in twrcanvas, ins!=lastins\");\n                break;\n            }\n            currentInsHdr=nextInsHdr;\n            currentInsParams = currentInsHdr + insHdrSize;\n        }\n\n      if (this.cmdCompleteSignal) this.cmdCompleteSignal.signal();\n      //console.log(\"Canvas.drawSeq() completed  with instruction count of \", insCount);\n   }\n}\n\nexport class twrConsoleCanvasProxy implements IConsoleCanvasProxy {\n   canvasKeys: twrSharedCircularBuffer;\n   drawCompleteSignal:twrSignal;\n   props: ICanvasProps;\n   id:number;\n\n   constructor(params:TConsoleCanvasProxyParams) {\n      const [className, id, props, signalBuffer,  canvasKeysBuffer] = params;\n      this.drawCompleteSignal = new twrSignal(signalBuffer);\n      this.canvasKeys = new twrSharedCircularBuffer(canvasKeysBuffer);\n      this.props=props;\n      this.id=id;\n\n      //console.log(\"Create New twrCanvasProxy: \",this.props)\n\n   }\n\n   charIn() {  \n      //ctx.commit(); not avail in chrome\n\n      //postMessage([\"debug\", 'x']);\n      \n      return this.canvasKeys.readWait();  // wait for a key, then read it\n   }\n\n   inkey() {\n      if (this.canvasKeys.isEmpty())\n         return 0;\n      else\n         return this.charIn();    \n   }\n\n   // note that this implementation does not allow a property to change post creation of an instance of this class\n   getProp(propName:keyof ICanvasProps): number {\n      return this.props[propName];\n   }\n\n   drawSeq(ds:number) {\n      this.drawCompleteSignal.reset();\n      postMessage([\"canvas2d-drawseq\", [this.id, ds]]);\n      this.drawCompleteSignal.wait();\n   }\n}\n","import { IOTypes } from \"./twrcon.js\";\nimport { twrCodePageToUnicodeCodePoint, codePageUTF32 } from \"./twrlocale.js\";\nimport { twrConsoleRegistry } from \"./twrconreg.js\";\nexport class twrConsoleDebug {\n    logline = \"\";\n    element = undefined;\n    id;\n    cpTranslate;\n    constructor() {\n        this.id = twrConsoleRegistry.registerConsole(this);\n        this.cpTranslate = new twrCodePageToUnicodeCodePoint();\n    }\n    charOut(ch, codePage) {\n        const char = this.cpTranslate.convert(ch, codePage);\n        if (char == 10 || char == 0x03) { // ASCII 03 is End-of-Text, and is used here to indicate the preceding char should be printed\n            console.log(this.logline); // ideally without a linefeed, but there is no way to not have a LF with console.log API.\n            this.logline = \"\";\n        }\n        else {\n            this.logline = this.logline + String.fromCodePoint(char);\n            if (this.logline.length >= 300) {\n                console.log(this.logline);\n                this.logline = \"\";\n            }\n        }\n    }\n    getProp(propName) {\n        if (propName === \"type\")\n            return IOTypes.CHARWRITE;\n        console.log(\"twrConsoleDebug.getProp passed unknown property name: \", propName);\n        return 0;\n    }\n    getProxyParams() {\n        return [\"twrConsoleDebugProxy\", this.id];\n    }\n    keyDown(ev) {\n        throw new Error(\"twrConsoleDebug does not support character input\");\n    }\n    processMessage(msgType, data, callingModule) {\n        const [id, ...params] = data;\n        if (id != this.id)\n            throw new Error(\"internal error\"); // should never happen\n        switch (msgType) {\n            case \"debug-charout\":\n                {\n                    const [ch, codePage] = params;\n                    this.charOut(ch, codePage);\n                }\n                break;\n            case \"debug-putstr\":\n                {\n                    const [str] = params;\n                    this.putStr(str);\n                }\n                break;\n            default:\n                return false;\n        }\n        return true;\n    }\n    putStr(str) {\n        for (let i = 0; i < str.length; i++)\n            this.charOut(str.codePointAt(i) || 0, codePageUTF32);\n    }\n}\nexport class twrConsoleDebugProxy {\n    id;\n    constructor(params) {\n        this.id = params[1];\n    }\n    charIn() {\n        return 0;\n    }\n    setFocus() {\n    }\n    charOut(ch, codePoint) {\n        postMessage([\"debug-charout\", [this.id, ch, codePoint]]);\n    }\n    putStr(str) {\n        postMessage([\"debug-putstr\", [this.id, str]]);\n    }\n    getProp(propName) {\n        if (propName === \"type\")\n            return IOTypes.CHARWRITE;\n        console.log(\"twrConsoleDebugProxy.getProp passed unknown property name: \", propName);\n        return 0;\n    }\n}\n// ************************************************************************\n// debugLog doesn't currently wait for the message to log, it returns immediately.\n// I could move this to be in the twrWaitingCalls class\n//# sourceMappingURL=twrcondebug.js.map","\n\nimport {IConsoleStream, IConsoleStreamProxy, TConsoleDebugProxyParams, IOTypes} from \"./twrcon.js\"\nimport {twrCodePageToUnicodeCodePoint, codePageUTF32} from \"./twrlocale.js\"\nimport {twrConsoleRegistry} from \"./twrconreg.js\"\nimport {twrWasmModuleBase} from \"./twrmodbase.js\"\n\nexport class twrConsoleDebug implements IConsoleStream {\n\tlogline=\"\";\n\telement=undefined;\n\tid:number;\n\tcpTranslate:twrCodePageToUnicodeCodePoint;\n\n\tconstructor() {\n\t\tthis.id=twrConsoleRegistry.registerConsole(this);\n\t\tthis.cpTranslate=new twrCodePageToUnicodeCodePoint();\n\t}\n\n\tcharOut(ch:number, codePage:number) {\n      const char=this.cpTranslate.convert(ch, codePage);\n\n\t\tif (char==10 || char==0x03) {  // ASCII 03 is End-of-Text, and is used here to indicate the preceding char should be printed\n\t\t\tconsole.log(this.logline);\t// ideally without a linefeed, but there is no way to not have a LF with console.log API.\n\t\t\tthis.logline=\"\";\n\t\t}\n\t\telse {\n\t\t\tthis.logline=this.logline+String.fromCodePoint(char);\n\t\t\tif (this.logline.length>=300) {\n\t\t\t\tconsole.log(this.logline);\n\t\t\t\tthis.logline=\"\";\n\t\t\t}\n\t\t}\n\t}\n\n\tgetProp(propName: string):number {\n\t\tif (propName===\"type\") return IOTypes.CHARWRITE;  \n\t\tconsole.log(\"twrConsoleDebug.getProp passed unknown property name: \", propName)\n\t\treturn 0;\n\t}\n\n\tgetProxyParams() : TConsoleDebugProxyParams {\n\t\treturn [\"twrConsoleDebugProxy\", this.id];\n\t}\n\n\tkeyDown(ev:KeyboardEvent)  {\n\t\tthrow new Error(\"twrConsoleDebug does not support character input\");\n\t}\n\n   processMessage(msgType:string, data:[number, ...any[]], callingModule:twrWasmModuleBase):boolean {\n\t\tconst [id, ...params] = data;\n      if (id!=this.id) throw new Error(\"internal error\");  // should never happen\n\n\t\tswitch (msgType) {\n\t\t\tcase \"debug-charout\":\n\t\t\t{\n\t\t\t\tconst [ch, codePage] =  params;\n\t\t\t\tthis.charOut(ch, codePage);\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"debug-putstr\":\n\t\t\t{\n\t\t\t\tconst [str] =  params;\n\t\t\t\tthis.putStr(str);\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tputStr(str:string) {\n\t\tfor (let i=0; i < str.length; i++)\n\t\t\tthis.charOut(str.codePointAt(i)||0, codePageUTF32);\n\t}\n}\n\n\nexport class twrConsoleDebugProxy implements IConsoleStreamProxy {\n\tid:number;\n\n\tconstructor(params:TConsoleDebugProxyParams) {\n\t\tthis.id=params[1];\n\t}\n\n\tcharIn() {  \n\t\treturn 0;\n\t}\n\n   setFocus() {\n   }\n\t\n\tcharOut(ch:number, codePoint:number) {\n\t\tpostMessage([\"debug-charout\", [this.id, ch, codePoint]]);\n\t}\n\n\tputStr(str:string):void\n\t{\n\t\tpostMessage([\"debug-putstr\", [this.id, str]]);\n\t}\n\n\tgetProp(propName: string) {\n\t\tif (propName===\"type\") return IOTypes.CHARWRITE;\n\t\tconsole.log(\"twrConsoleDebugProxy.getProp passed unknown property name: \", propName)\n\t\treturn 0;\n\t}\n}\n\n\n// ************************************************************************\n// debugLog doesn't currently wait for the message to log, it returns immediately.\n// I could move this to be in the twrWaitingCalls class\n","import { twrSharedCircularBuffer } from \"./twrcircular.js\";\nimport { twrCodePageToUnicodeCodePoint, codePageUTF32 } from \"./twrlocale.js\";\nimport { IOTypes, keyDown } from \"./twrcon.js\";\nimport { twrConsoleRegistry } from \"./twrconreg.js\";\nconst TRS80_GRAPHIC_MARKER = 0xE000;\nconst TRS80_GRAPHIC_MARKER_MASK = 0xFF00;\nconst TRS80_GRAPHIC_CHAR_MASK = 0x003F; // would be 0xC0 if we included the graphics marker bit 0x80\n// Term Canvas have a size that will be set based on the character width x height.\n// The display size for a canvas is set in the HTML/JS like this:\n//    canvas.style.width = \"700px\";\n//    canvas.style.height = \"500px\";\nexport class twrConsoleTerminal {\n    element;\n    id;\n    ctx;\n    keys; // only created if getProxyParams is called \n    returnValue;\n    props;\n    size;\n    cellWidth;\n    cellHeight;\n    cellW1;\n    cellW2;\n    cellH1;\n    cellH2;\n    cellH3;\n    isCursorVisible;\n    videoMem;\n    foreColorMem;\n    backColorMem;\n    cpTranslate;\n    constructor(canvasElement, params = {}) {\n        const { foreColor = \"white\", backColor = \"black\", fontSize = 16, widthInChars = 80, heightInChars = 25 } = params;\n        this.element = canvasElement;\n        // canvasElement is where we will draw the terminal\n        if (!canvasElement.getContext)\n            throw new Error(\"canvasElement.getContext invalid\");\n        let c = canvasElement.getContext(\"2d\");\n        if (!c)\n            throw new Error(\"canvasElement.getContext('2d') failed\");\n        c.font = fontSize.toString() + \"px Courier New\";\n        c.textBaseline = \"top\";\n        const sampleText = \"          \";\n        //const sampleText=String.fromCharCode(2593).repeat(6);   // this shaded block is typically full width in a font\n        const tm = c.measureText(sampleText);\n        const charWidth = Math.ceil(tm.width / sampleText.length); // ceil rounds up (eg .9 -> 1)\n        let fM = c.measureText(\"X\");\n        const charHeight = Math.ceil(fM.fontBoundingBoxAscent + fM.fontBoundingBoxDescent);\n        canvasElement.width = charWidth * widthInChars;\n        canvasElement.height = charHeight * heightInChars;\n        const canvasHeight = canvasElement.height;\n        const canvasWidth = canvasElement.width;\n        //console.log(\"this.props.canvasHeight, this.props.canvasWidth\",this.props.canvasHeight,this.props.canvasWidth);\n        // reset after dims changed.  Not sure if ctx is needed to reset, but others do\n        let c2 = canvasElement.getContext(\"2d\");\n        if (!c2)\n            throw new Error(\"canvas 2D context not found in twrCanvas.constructor (2nd time)\");\n        this.ctx = c2;\n        this.ctx.font = fontSize.toString() + \"px Courier New\";\n        this.ctx.textBaseline = \"top\";\n        c2.fillStyle = backColor;\n        const backColorAsRGB = Number(\"0x\" + c2.fillStyle.slice(1));\n        c2.fillStyle = foreColor;\n        const foreColorAsRGB = Number(\"0x\" + c2.fillStyle.slice(1));\n        const cursorPos = 0;\n        const type = IOTypes.CHARWRITE | IOTypes.CHARREAD | IOTypes.ADDRESSABLE_DISPLAY;\n        this.props = { type, cursorPos, foreColorAsRGB, backColorAsRGB, fontSize, widthInChars, heightInChars, canvasHeight, canvasWidth, charWidth, charHeight };\n        this.isCursorVisible = false;\n        this.size = this.props.widthInChars * this.props.heightInChars;\n        this.videoMem = new Array(this.size);\n        this.foreColorMem = new Array(this.size);\n        this.backColorMem = new Array(this.size);\n        this.cellWidth = this.props.charWidth;\n        this.cellHeight = this.props.charHeight;\n        if (this.cellWidth <= 0)\n            throw new Error(\"invalid cellWidth\");\n        if (this.cellHeight <= 0)\n            throw new Error(\"invalid cellHeight\");\n        // Calc each cell separately to avoid rounding errors\n        this.cellW1 = Math.floor(this.cellWidth / 2);\n        this.cellW2 = this.cellWidth - this.cellW1;\n        this.cellH1 = Math.floor(this.cellHeight / 3);\n        this.cellH2 = this.cellH1;\n        this.cellH3 = this.cellHeight - this.cellH1 - this.cellH2;\n        this.cls();\n        this.cpTranslate = new twrCodePageToUnicodeCodePoint();\n        this.id = twrConsoleRegistry.registerConsole(this);\n    }\n    // ProxyParams are used as the constructor options to create the Proxy class as returned by getProxyClassName, \n    // in the twrModAsyncProxy WebWorker thread\n    getProxyParams() {\n        if (this.returnValue || this.keys)\n            throw new Error(\"internal error -- getProxyParams unexpectedly called twice.\");\n        // these are used to communicate with twrConsoleTerminalProxy (if it exists)\n        // tsconfig, lib must be set to 2017 or higher for SharedArrayBuffer usage\n        this.returnValue = new twrSharedCircularBuffer();\n        this.keys = new twrSharedCircularBuffer();\n        return [\"twrConsoleTerminalProxy\", this.id, this.returnValue.sharedArray, this.keys.sharedArray];\n    }\n    getProp(propName) {\n        return this.props[propName];\n    }\n    keyDown(ev) {\n        keyDown(this, ev);\n    }\n    // these messages are sent by twrConsoleTerminalProxy to cause functions to execute in the JS Main Thread\n    processMessage(msgType, data) {\n        const [id, ...params] = data;\n        if (id != this.id)\n            throw new Error(\"internal error\"); // should never happen\n        switch (msgType) {\n            case \"term-getprop\":\n                const [propName] = params;\n                const propVal = this.getProp(propName);\n                this.returnValue.write(propVal);\n                break;\n            case \"term-point\":\n                {\n                    const [x, y] = params;\n                    const r = this.point(x, y);\n                    this.returnValue.write(r ? 1 : 0); // wait for result, then read it\n                }\n                break;\n            case \"term-charout\":\n                {\n                    const [ch, codePage] = params;\n                    this.charOut(ch, codePage);\n                }\n                break;\n            case \"term-putstr\":\n                {\n                    const [str] = params;\n                    this.putStr(str);\n                }\n                break;\n            case \"term-cls\":\n                {\n                    this.cls();\n                }\n                break;\n            case \"term-setrange\":\n                {\n                    const [start, values] = params;\n                    this.setRange(start, values);\n                }\n                break;\n            case \"term-setc32\":\n                {\n                    const [location, char] = params;\n                    this.setC32(location, char);\n                }\n                break;\n            case \"term-setreset\":\n                {\n                    const [x, y, isset] = params;\n                    this.setReset(x, y, isset);\n                }\n                break;\n            case \"term-setcursor\":\n                {\n                    const [pos] = params;\n                    this.setCursor(pos);\n                }\n                break;\n            case \"term-setcursorxy\":\n                {\n                    const [x, y] = params;\n                    this.setCursorXY(x, y);\n                }\n                break;\n            case \"term-setcolors\":\n                {\n                    const [foreground, background] = params;\n                    this.setColors(foreground, background);\n                }\n                break;\n            case \"term-focus\":\n                {\n                    this.element.focus();\n                }\n                break;\n            default:\n                return false;\n        }\n        return true;\n    }\n    RGB_TO_RGBA(x) {\n        return ((x) << 8) | 0xFF; // JavaScript uses 32-bit signed integers for bitwise operations, which means the leftmost bit is the sign bit. \n    }\n    eraseLine() {\n        for (let i = this.props.cursorPos; i < Math.floor(this.props.cursorPos / this.props.widthInChars) * this.props.widthInChars + this.props.widthInChars; i++)\n            this.setC32(i, 32);\n    }\n    charOut(c, codePage) {\n        if (c == 13 || c == 10) // return\n         {\n            if (this.isCursorVisible)\n                this.setC32(this.props.cursorPos, 32);\n            this.props.cursorPos = Math.floor(this.props.cursorPos / this.props.widthInChars);\n            this.props.cursorPos = this.props.cursorPos * this.props.widthInChars;\n            this.props.cursorPos = this.props.cursorPos + this.props.widthInChars;\n            /* if return put us on a new line that isn't a scroll, erase the line */\n            if (this.props.cursorPos < this.size)\n                this.eraseLine();\n        }\n        else if (c == 8) // backspace\n         {\n            if (this.props.cursorPos > 0) {\n                if (this.isCursorVisible)\n                    this.setC32(this.props.cursorPos, 32);\n                this.props.cursorPos--;\n                this.setC32(this.props.cursorPos, 32);\n            }\n        }\n        else if (c == 0xE) // Turn on cursor\n         {\n            this.isCursorVisible = true;\n        }\n        else if (c == 0xF) // Turn off cursor\n         {\n            this.setC32(this.props.cursorPos, 32);\n            this.isCursorVisible = false;\n        }\n        else if (c == 24) /* backspace cursor*/ {\n            if (this.props.cursorPos > 0)\n                this.props.cursorPos--;\n        }\n        else if (c == 25) /* advance cursor*/ {\n            if (this.props.cursorPos < (this.size - 1))\n                this.props.cursorPos++;\n        }\n        else if (c == 26) /* cursor down one line */ {\n            if (this.props.cursorPos < this.props.widthInChars * (this.props.heightInChars - 1))\n                this.props.cursorPos += this.props.widthInChars;\n        }\n        else if (c == 27) /* cursor up one line */ {\n            if (this.props.cursorPos >= this.props.widthInChars)\n                this.props.cursorPos -= this.props.widthInChars;\n        }\n        else if (c == 28) /* home */ {\n            this.props.cursorPos = 0;\n        }\n        else if (c == 29) /* beginning of line */ {\n            this.props.cursorPos = (this.props.cursorPos / this.props.widthInChars) * this.props.widthInChars;\n        }\n        else if (c == 30) /* erase to end of line */ {\n            this.eraseLine();\n        }\n        else if (c == 31) /* erase to end of frame */ {\n            for (let i = this.props.cursorPos; i < this.size; i++)\n                this.setC32(i, 32);\n        }\n        else {\n            const c32 = this.cpTranslate.convert(c, codePage);\n            if (c32 != 0) {\n                this.setC32(this.props.cursorPos, c32);\n                this.props.cursorPos++;\n            }\n        }\n        // Do we need to scroll?\n        if (this.props.cursorPos == this.size) {\n            this.props.cursorPos = this.props.widthInChars * (this.props.heightInChars - 1);\n            for (let i = 0; i < (this.props.widthInChars * (this.props.heightInChars - 1)); i++) {\n                this.videoMem[i] = this.videoMem[i + this.props.widthInChars];\n                this.backColorMem[i] = this.backColorMem[i + this.props.widthInChars];\n                this.foreColorMem[i] = this.foreColorMem[i + this.props.widthInChars];\n            }\n            for (let i = 0; i < this.props.widthInChars; i++) {\n                this.videoMem[this.size - i - 1] = 32;\n                this.backColorMem[this.size - i - 1] = this.props.backColorAsRGB;\n                this.foreColorMem[this.size - i - 1] = this.props.foreColorAsRGB;\n            }\n            this.drawRange(0, this.size - 1);\n        }\n        if (this.isCursorVisible)\n            this.setC32(this.props.cursorPos, 9611); // 9611 is graphic block -- same cursor i use in class twrDiv\n        if (this.props.cursorPos >= this.size) {\n            throw new Error(\"twrTerm: assert: this.props.cursorPos >= this.size\");\n        }\n    }\n    //*************************************************\n    putStr(str) {\n        for (let i = 0; i < str.length; i++)\n            this.charOut(str.codePointAt(i) || 0, codePageUTF32);\n    }\n    //*************************************************\n    setC32(location, c32) {\n        if (!(location >= 0 && location < this.size))\n            throw new Error(\"Invalid location passed to setc32\");\n        this.videoMem[location] = c32;\n        this.backColorMem[location] = this.props.backColorAsRGB;\n        this.foreColorMem[location] = this.props.foreColorAsRGB;\n        // draw one before and one after to fix any character rendering overlap.  \n        // Can happen with anti-aliasing on graphic chars that fill the cell\n        let start = location - 1;\n        if (start < 0)\n            start = 0;\n        let end = location + 1;\n        if (end >= this.size)\n            end = this.size - 1;\n        this.drawRange(start, end);\n        // draw one line above and below as well to fix any character rendering overlap.  \n        // the block cursor typically can cause an issue\n        const startSave = start;\n        const endSave = end;\n        start = start - this.props.widthInChars;\n        end = end - this.props.widthInChars;\n        if (start < 0)\n            start = 0;\n        if (end < 0)\n            end = 0;\n        this.drawRange(start, end);\n        start = startSave + this.props.widthInChars;\n        end = endSave + this.props.widthInChars;\n        if (start >= this.size)\n            start = this.size - 1;\n        if (end >= this.size)\n            end = this.size - 1;\n        this.drawRange(start, end);\n    }\n    //*************************************************\n    cls() {\n        for (let i = 0; i < this.size; i++) {\n            this.videoMem[i] = 32;\n            this.backColorMem[i] = this.props.backColorAsRGB;\n            this.foreColorMem[i] = this.props.foreColorAsRGB;\n        }\n        this.props.cursorPos = 0;\n        this.isCursorVisible = false;\n        this.drawRange(0, this.size - 1);\n    }\n    setFillStyleRGB(color) {\n        // const cssColor= \"#\"+(\"00000000\" + color.toString(16)).slice(-8);  RGBA\n        const cssColor = `#${color.toString(16).padStart(6, '0')}`;\n        this.ctx.fillStyle = cssColor;\n    }\n    drawTrs80Graphic(offset, val, fgc, bgc) {\n        let x, y;\n        x = (offset % this.props.widthInChars) * this.cellWidth;\n        y = Math.floor(offset / this.props.widthInChars) * this.cellHeight;\n        this.setFillStyleRGB(bgc);\n        this.ctx.fillRect(x, y, this.cellWidth, this.cellHeight);\n        if (val == 32)\n            return;\n        this.setFillStyleRGB(fgc);\n        if (val & 1)\n            this.ctx.fillRect(x, y, this.cellW1, this.cellH1);\n        y = y + this.cellH1;\n        if (val & 4)\n            this.ctx.fillRect(x, y, this.cellW1, this.cellH2);\n        y = y + this.cellH2;\n        if (val & 16)\n            this.ctx.fillRect(x, y, this.cellW1, this.cellH3);\n        x = x + this.cellW1;\n        if (val & 32)\n            this.ctx.fillRect(x, y, this.cellW2, this.cellH3);\n        y = y - this.cellH2;\n        if (val & 8)\n            this.ctx.fillRect(x, y, this.cellW2, this.cellH2);\n        y = y - this.cellH1;\n        if (val & 2)\n            this.ctx.fillRect(x, y, this.cellW2, this.cellH1);\n    }\n    //**************************************************\n    drawCell(offset, value, fgc, bgc) {\n        if ((value & TRS80_GRAPHIC_MARKER_MASK) == TRS80_GRAPHIC_MARKER || value == 32) {\n            this.drawTrs80Graphic(offset, value & TRS80_GRAPHIC_CHAR_MASK, fgc, bgc);\n        }\n        else {\n            let x, y;\n            x = (offset % this.props.widthInChars) * this.cellWidth;\n            y = Math.floor(offset / this.props.widthInChars) * this.cellHeight;\n            this.setFillStyleRGB(bgc);\n            this.ctx.fillRect(x, y, this.cellWidth, this.cellHeight);\n            if (value != 32) {\n                this.setFillStyleRGB(fgc);\n                const txt = String.fromCodePoint(value);\n                this.ctx.fillText(txt, x, y);\n            }\n        }\n    }\n    //*************************************************\n    // !!TODO add ability to setRange colors\n    // !! should this take a bytearray?\n    // !! need to add \"getRange\" to match\n    setRange(start, values) {\n        let k = 0;\n        for (let i = start; i < start + values.length; i++) {\n            this.videoMem[i] = values[k++];\n        }\n        this.drawRange(start, start + values.length - 1);\n    }\n    drawRange(start, end) {\n        for (let i = start; i <= end; i++) {\n            this.drawCell(i, this.videoMem[i], this.foreColorMem[i], this.backColorMem[i]);\n        }\n    }\n    /*************************************************/\n    setReset(x, y, isset) {\n        const loc = Math.floor(x / 2) + this.props.widthInChars * Math.floor(y / 3);\n        const cellx = x % 2;\n        const celly = y % 3;\n        if (x < 0 || x > this.props.widthInChars * 2)\n            throw new Error(\"setReset: invalid x value\");\n        if (y < 0 || y > this.props.heightInChars * 3)\n            throw new Error(\"setReset: invalid y value\");\n        if (!((this.videoMem[loc] & TRS80_GRAPHIC_MARKER_MASK) == TRS80_GRAPHIC_MARKER)) {\n            this.videoMem[loc] = TRS80_GRAPHIC_MARKER; /* set to a cleared graphics value */\n            this.backColorMem[loc] = this.props.backColorAsRGB;\n            this.foreColorMem[loc] = this.props.foreColorAsRGB;\n        }\n        if (isset)\n            this.videoMem[loc] |= (1 << (celly * 2 + cellx));\n        else\n            this.videoMem[loc] &= ~(1 << (celly * 2 + cellx));\n        this.drawRange(loc, loc);\n    }\n    //*************************************************\n    point(x, y) {\n        const loc = Math.floor(x / 2) + this.props.widthInChars * Math.floor(y / 3);\n        const cellx = x % 2;\n        const celly = y % 3;\n        if (x < 0 || x > this.props.widthInChars * 2)\n            throw new Error(\"Point: invalid x value\");\n        if (y < 0 || y > this.props.heightInChars * 3)\n            throw new Error(\"Point: invalid y value\");\n        if (!((this.videoMem[loc] & TRS80_GRAPHIC_MARKER_MASK) == TRS80_GRAPHIC_MARKER))\n            return false; /* not a graphic cell, so false */\n        if (this.videoMem[loc] & (1 << (celly * 2 + cellx)))\n            return true;\n        else\n            return false;\n    }\n    //*************************************************\n    setCursor(location) {\n        if (location < 0 || location >= this.size)\n            throw new Error(\"setCursor: invalid location: \" + location);\n        this.props.cursorPos = location;\n    }\n    //*************************************************\n    setCursorXY(x, y) {\n        if (x < 0 || y < 0 || this.props.widthInChars * y + x >= this.size)\n            throw new Error(\"setCursorXY: invalid parameter(s)\");\n        this.setCursor(this.props.widthInChars * y + x);\n    }\n    //*************************************************\n    setColors(foreground, background) {\n        this.props.foreColorAsRGB = foreground;\n        this.props.backColorAsRGB = background;\n    }\n}\n//*************************************************\nexport class twrConsoleTerminalProxy {\n    keys;\n    returnValue;\n    id;\n    constructor(params) {\n        const [className, id, returnBuffer, keysBuffer] = params;\n        this.keys = new twrSharedCircularBuffer(keysBuffer);\n        this.returnValue = new twrSharedCircularBuffer(returnBuffer);\n        this.id = id;\n    }\n    getProp(propName) {\n        postMessage([\"term-getprop\", [this.id, propName]]);\n        return this.returnValue.readWait(); // wait for result, then read it\n    }\n    charIn() {\n        return this.keys.readWait(); // wait for a key, then read it\n    }\n    point(x, y) {\n        postMessage([\"term-point\", [this.id, x, y]]);\n        return this.returnValue.readWait() != 0; // wait for result, then read it\n    }\n    charOut(ch, codePoint) {\n        postMessage([\"term-charout\", [this.id, ch, codePoint]]);\n    }\n    putStr(str) {\n        postMessage([\"term-putstr\", [this.id, str]]);\n    }\n    cls() {\n        postMessage([\"term-cls\", [this.id]]);\n    }\n    setRange(start, values) {\n        postMessage([\"term-setrange\", [this.id, start, values]]);\n    }\n    setC32(location, char) {\n        postMessage([\"term-setc32\", [this.id, location, char]]);\n    }\n    setReset(x, y, isset) {\n        postMessage([\"term-setreset\", [this.id, x, y, isset]]);\n    }\n    setCursor(pos) {\n        postMessage([\"term-setcursor\", [this.id, pos]]);\n    }\n    setCursorXY(x, y) {\n        postMessage([\"term-setcursorxy\", [this.id, x, y]]);\n    }\n    setColors(foreground, background) {\n        postMessage([\"term-setcolors\", [this.id, foreground, background]]);\n    }\n    setFocus() {\n        postMessage([\"term-focus\", [this.id]]);\n    }\n}\n//# sourceMappingURL=twrconterm.js.map","import {twrSharedCircularBuffer} from \"./twrcircular.js\";\nimport {twrCodePageToUnicodeCodePoint, codePageUTF32} from \"./twrlocale.js\"\nimport {IConsoleTerminal, IConsoleTerminalProps, IConsoleTerminalParams, IConsoleTerminalProxy} from \"./twrcon.js\"\nimport {TConsoleTerminalProxyParams, IOTypes, keyDown} from \"./twrcon.js\"\nimport {twrConsoleRegistry} from \"./twrconreg.js\"\n\nconst TRS80_GRAPHIC_MARKER=0xE000;\nconst TRS80_GRAPHIC_MARKER_MASK=0xFF00;\nconst TRS80_GRAPHIC_CHAR_MASK=0x003F;    // would be 0xC0 if we included the graphics marker bit 0x80\n\n// Term Canvas have a size that will be set based on the character width x height.\n// The display size for a canvas is set in the HTML/JS like this:\n//    canvas.style.width = \"700px\";\n//    canvas.style.height = \"500px\";\n\n\nexport class twrConsoleTerminal implements IConsoleTerminal  {\n   element:HTMLElement;\n\tid:number;\n   ctx:CanvasRenderingContext2D;\n   keys?: twrSharedCircularBuffer;  // only created if getProxyParams is called \n   returnValue?: twrSharedCircularBuffer;\n   props:IConsoleTerminalProps;\n   size:number;\n   cellWidth:number;\n   cellHeight:number;\n   cellW1:number;\n   cellW2:number; \n   cellH1:number;\n   cellH2:number;\n   cellH3:number;\n   isCursorVisible:boolean;\n   videoMem: number[];\n   foreColorMem: number[];\n   backColorMem: number[];\n\tcpTranslate:twrCodePageToUnicodeCodePoint;\n\n\n    constructor (canvasElement:HTMLCanvasElement, params:IConsoleTerminalParams={}) {\n  \n      const {foreColor=\"white\", backColor=\"black\", fontSize=16, widthInChars=80, heightInChars=25} = params; \n\n      this.element=canvasElement;\n\n      // canvasElement is where we will draw the terminal\n      if (!canvasElement.getContext) throw new Error(\"canvasElement.getContext invalid\");\n      let c=canvasElement.getContext(\"2d\");\n      if (!c) throw new Error(\"canvasElement.getContext('2d') failed\");\n\n      c.font = fontSize.toString()+\"px Courier New\";\n      c.textBaseline=\"top\";\n      const sampleText=\"          \";\n      //const sampleText=String.fromCharCode(2593).repeat(6);   // this shaded block is typically full width in a font\n      const tm=c.measureText(sampleText);\n      const charWidth=Math.ceil(tm.width / sampleText.length);   // ceil rounds up (eg .9 -> 1)\n      let fM = c.measureText(\"X\"); \n      const charHeight = Math.ceil(fM.fontBoundingBoxAscent + fM.fontBoundingBoxDescent);\n\n      canvasElement.width=charWidth*widthInChars;\n      canvasElement.height=charHeight*heightInChars;\n\n      const canvasHeight=canvasElement.height;\n      const canvasWidth=canvasElement.width;\n      //console.log(\"this.props.canvasHeight, this.props.canvasWidth\",this.props.canvasHeight,this.props.canvasWidth);\n\n      // reset after dims changed.  Not sure if ctx is needed to reset, but others do\n      let c2=canvasElement.getContext(\"2d\");\n      if (!c2) throw new Error(\"canvas 2D context not found in twrCanvas.constructor (2nd time)\");\n      this.ctx=c2;\n      this.ctx.font = fontSize.toString()+\"px Courier New\";\n      this.ctx.textBaseline=\"top\";\n\n      c2.fillStyle=backColor;\n      const backColorAsRGB=Number(\"0x\"+c2.fillStyle.slice(1));\n\n      c2.fillStyle=foreColor;\n      const foreColorAsRGB=Number(\"0x\"+c2.fillStyle.slice(1));\n\n      const cursorPos=0;\n      const type=IOTypes.CHARWRITE|IOTypes.CHARREAD|IOTypes.ADDRESSABLE_DISPLAY;\n\n      this.props={type, cursorPos, foreColorAsRGB, backColorAsRGB, fontSize, widthInChars, heightInChars, canvasHeight, canvasWidth, charWidth, charHeight};\n\n      this.isCursorVisible=false;\n      this.size=this.props.widthInChars*this.props.heightInChars;\n      this.videoMem=new Array(this.size);\n      this.foreColorMem=new Array(this.size);\n      this.backColorMem=new Array(this.size);\n\n      this.cellWidth = this.props.charWidth;\n      this.cellHeight = this.props.charHeight;\n      if (this.cellWidth<=0) throw new Error(\"invalid cellWidth\");\n      if (this.cellHeight<=0) throw new Error(\"invalid cellHeight\");\n   \n      // Calc each cell separately to avoid rounding errors\n      this.cellW1 = Math.floor(this.cellWidth / 2);  \n      this.cellW2 = this.cellWidth - this.cellW1;  \n      this.cellH1 = Math.floor(this.cellHeight / 3);\n      this.cellH2 = this.cellH1;\n      this.cellH3 = this.cellHeight - this.cellH1 - this.cellH2;\n\n\t\tthis.cls();\n\n\t\tthis.cpTranslate=new twrCodePageToUnicodeCodePoint();\n\n\t\tthis.id=twrConsoleRegistry.registerConsole(this);\n\n   }\n\n   // ProxyParams are used as the constructor options to create the Proxy class as returned by getProxyClassName, \n   // in the twrModAsyncProxy WebWorker thread\n   getProxyParams() : TConsoleTerminalProxyParams {\n      if (this.returnValue || this.keys) throw new Error(\"internal error -- getProxyParams unexpectedly called twice.\");\n      // these are used to communicate with twrConsoleTerminalProxy (if it exists)\n      // tsconfig, lib must be set to 2017 or higher for SharedArrayBuffer usage\n      this.returnValue = new twrSharedCircularBuffer();  \n      this.keys = new twrSharedCircularBuffer();  \n      return [\"twrConsoleTerminalProxy\", this.id, this.returnValue.sharedArray, this.keys.sharedArray];\n  }\n\n   getProp(propName: string): number {\n      return this.props[propName];\n   }\n\n\tkeyDown(ev:KeyboardEvent)  {\n\t\tkeyDown(this, ev);\n\t}\n\n   // these messages are sent by twrConsoleTerminalProxy to cause functions to execute in the JS Main Thread\n   processMessage(msgType:string, data:[number, ...any[]]):boolean {\n\t\tconst [id, ...params] = data;\n      if (id!=this.id) throw new Error(\"internal error\");  // should never happen\n\n      switch (msgType) {\n         case \"term-getprop\":\n            const [propName] =  params;\n\t\t\t\tconst propVal=this.getProp(propName);\n            this.returnValue!.write(propVal);\n            break;\n\n         case \"term-point\":\n         {\n            const [x, y] =  params;\n            const r=this.point(x, y);\n            this.returnValue!.write(r?1:0);  // wait for result, then read it\n\n         }\n            break;\n\n         case \"term-charout\":\n         {\n            const [ch, codePage] =  params;\n            this.charOut(ch, codePage);\n         }\n            break;\n\n         case \"term-putstr\":\n         {\n            const [str] =  params;\n            this.putStr(str);\n         }\n            break;\n\n         case \"term-cls\":\n         {\n            this.cls();\n         }\n         break;\n\n         case \"term-setrange\":\n         {\n            const [start, values] =  params;\n            this.setRange(start, values);\n         }\n         break;\n\n         case \"term-setc32\":\n         {\n            const [location, char] =  params;\n            this.setC32(location, char);\n         }\n         break;\n\n         case \"term-setreset\":\n         {\n            const [x, y, isset] =  params;\n            this.setReset(x, y, isset);\n         }\n         break;\n\n         case \"term-setcursor\":\n         {\n            const [pos] =  params;\n            this.setCursor(pos);\n         }\n         break;\n\n         case \"term-setcursorxy\":\n         {\n            const [x, y] =  params;\n            this.setCursorXY(x, y);\n         }\n         break;\n\n         case \"term-setcolors\":\n         {\n            const [foreground, background] =  params;\n            this.setColors(foreground, background);\n         }\n         break;\n\n         case \"term-focus\":\n         {\n            this.element.focus();\n         }\n            break;\n\n\n         default:\n            return false;\n      }\n\n      return true;\n   }\n\n   private RGB_TO_RGBA(x:number) {\n      return  ((x)<<8) | 0xFF;  // JavaScript uses 32-bit signed integers for bitwise operations, which means the leftmost bit is the sign bit. \n   }\n\n   private eraseLine()\n   {\n      for (let i=this.props.cursorPos; i < Math.floor(this.props.cursorPos/this.props.widthInChars)*this.props.widthInChars+this.props.widthInChars; i++)\n         this.setC32(i, 32);\n   }\n      \n   charOut(c:number, codePage:number)\n   {\n      if (c==13 || c==10)\t// return\n      {\n         if (this.isCursorVisible)\n            this.setC32(this.props.cursorPos,32);\n         \n         this.props.cursorPos = Math.floor(this.props.cursorPos/this.props.widthInChars);\n         this.props.cursorPos = this.props.cursorPos*this.props.widthInChars;\n         this.props.cursorPos = this.props.cursorPos + this.props.widthInChars;\n         \n         /* if return put us on a new line that isn't a scroll, erase the line */\n         if (this.props.cursorPos < this.size)\t\n            this.eraseLine();\n      }\n      else if (c==8)\t// backspace\n      {\n         if (this.props.cursorPos > 0)\n         {\n            if (this.isCursorVisible)\n               this.setC32(this.props.cursorPos,32);\n            this.props.cursorPos--;\n            this.setC32(this.props.cursorPos,32);\n         }\n      }\n      else if (c==0xE)\t// Turn on cursor\n      {\n         this.isCursorVisible = true;\n      }\n      else if (c==0xF)\t// Turn off cursor\n      {\n         this.setC32(this.props.cursorPos,32);\n         this.isCursorVisible = false;\n      }\n      else if (c==24)\t/* backspace cursor*/\n      {\n         if (this.props.cursorPos > 0)\n            this.props.cursorPos--;\n      }\n      else if (c==25)\t/* advance cursor*/\n      {\n         if (this.props.cursorPos < (this.size-1))\n            this.props.cursorPos++;\n      }\n      else if (c==26)\t/* cursor down one line */\n      {\n         if (this.props.cursorPos < this.props.widthInChars*(this.props.heightInChars-1))\n            this.props.cursorPos+=this.props.widthInChars;\n      }\n      else if (c==27)\t/* cursor up one line */\n      {\n         if (this.props.cursorPos >= this.props.widthInChars)\n            this.props.cursorPos-=this.props.widthInChars;\n      }\n      else if (c==28)\t/* home */\n      {\n         this.props.cursorPos=0;\n      }\n      else if (c==29)\t/* beginning of line */\n      {\n         this.props.cursorPos=(this.props.cursorPos/this.props.widthInChars)*this.props.widthInChars;\n      }\n      else if (c==30)\t/* erase to end of line */\n      {\n         this.eraseLine();\n      }\n      else if (c==31)\t/* erase to end of frame */\n      {\n         for (let i=this.props.cursorPos; i < this.size; i++)\n            this.setC32(i, 32);\n      }\n      else\n      {\n         const c32=this.cpTranslate.convert(c, codePage);\n         if (c32!=0) {\n            this.setC32(this.props.cursorPos, c32);\n            this.props.cursorPos++;\n         }\n      }\n\n      // Do we need to scroll?\n      if (this.props.cursorPos == this.size)\t\n      {\n         this.props.cursorPos = this.props.widthInChars*(this.props.heightInChars-1);\n         for (let i=0; i < (this.props.widthInChars*(this.props.heightInChars-1)); i++) {\n            this.videoMem[i] = this.videoMem[i+this.props.widthInChars];\n            this.backColorMem[i] = this.backColorMem[i+this.props.widthInChars];\n            this.foreColorMem[i] = this.foreColorMem[i+this.props.widthInChars];\n         }\n\n         for (let i=0; i < this.props.widthInChars; i++) {\n            this.videoMem[this.size-i-1] = 32;\n            this.backColorMem[this.size-i-1] = this.props.backColorAsRGB;\n            this.foreColorMem[this.size-i-1] = this.props.foreColorAsRGB;\n         }\n\n         this.drawRange(0, this.size-1);\n      }\n\n      if (this.isCursorVisible)\n         this.setC32(this.props.cursorPos, 9611);  // 9611 is graphic block -- same cursor i use in class twrDiv\n\n      if (this.props.cursorPos >= this.size)\n      {\n         throw new Error(\"twrTerm: assert: this.props.cursorPos >= this.size\");\n      }\n   }\n\n   //*************************************************\n\n   putStr(str:string) {\n      for (let i=0; i < str.length; i++)\n         this.charOut(str.codePointAt(i)||0, codePageUTF32);\n   }\n\n   //*************************************************\n\n   setC32(location:number, c32:number) : void\n   {\n      if (!(location>=0 && location<this.size)) throw new Error(\"Invalid location passed to setc32\")\n\n      this.videoMem[location]=c32;\n      this.backColorMem[location]=this.props.backColorAsRGB;\n      this.foreColorMem[location]=this.props.foreColorAsRGB;\n      \n      // draw one before and one after to fix any character rendering overlap.  \n      // Can happen with anti-aliasing on graphic chars that fill the cell\n      let start=location-1;\n      if (start<0) start=0;\n      let end=location+1;\n      if (end >= this.size) end=this.size-1;\n      this.drawRange(start, end);\n\n      // draw one line above and below as well to fix any character rendering overlap.  \n      // the block cursor typically can cause an issue\n      const startSave=start;\n      const endSave=end;\n      start=start-this.props.widthInChars;\n      end=end-this.props.widthInChars;\n      if (start<0) start=0;\n      if (end<0) end=0;\n      this.drawRange(start, end);  \n\n      start=startSave+this.props.widthInChars;\n      end=endSave+this.props.widthInChars;\n      if (start >= this.size) start=this.size-1;\n      if (end >= this.size) end=this.size-1;\n      this.drawRange(start, end);    \n   }\n\n   //*************************************************\n\n   cls()\n   {\n      for (let i=0; i < this.size; i++) {\n         this.videoMem[i]=32;\n         this.backColorMem[i]=this.props.backColorAsRGB;\n         this.foreColorMem[i]=this.props.foreColorAsRGB;\n      }\n\n      this.props.cursorPos = 0;\n      this.isCursorVisible = false;\n\n      this.drawRange(0, this.size-1);\n   }\n\n   private setFillStyleRGB(color:number) {\n      // const cssColor= \"#\"+(\"00000000\" + color.toString(16)).slice(-8);  RGBA\n\t\tconst cssColor = `#${color.toString(16).padStart(6, '0')}`;\n      this.ctx.fillStyle = cssColor;\n   }\n\n   drawTrs80Graphic(offset:number, val:number, fgc:number, bgc:number)\n   {\n      let x, y;\n   \n      x = (offset%this.props.widthInChars)*this.cellWidth;\n      y = Math.floor(offset/this.props.widthInChars)*this.cellHeight;\n   \n      this.setFillStyleRGB(bgc);\n      this.ctx.fillRect(x, y, this.cellWidth, this.cellHeight);\n   \n      if (val == 32)\n         return;\n   \n      this.setFillStyleRGB(fgc);\n   \n      if (val&1)\n         this.ctx.fillRect(x, y, this.cellW1, this.cellH1);\n   \n      y=y+this.cellH1;\n   \n      if (val&4)\n         this.ctx.fillRect(x, y, this.cellW1, this.cellH2);\n   \n      y=y+this.cellH2;\n   \n      if (val&16)\n         this.ctx.fillRect(x, y, this.cellW1, this.cellH3);\n   \n      x=x+this.cellW1;\n   \n      if (val&32)\n         this.ctx.fillRect(x, y, this.cellW2, this.cellH3);\n   \n      y=y-this.cellH2;\n   \n      if (val&8)\n         this.ctx.fillRect(x, y, this.cellW2, this.cellH2);\n   \n      y=y-this.cellH1;\n   \n      if (val&2)\n         this.ctx.fillRect(x, y, this.cellW2, this.cellH1);\n   \n   } \n   \n   //**************************************************\n   \n   private drawCell(offset:number, value:number, fgc:number, bgc:number)\n   {\n      if ( (value&TRS80_GRAPHIC_MARKER_MASK)==TRS80_GRAPHIC_MARKER || value==32)\n      {\n         this.drawTrs80Graphic(offset, value&TRS80_GRAPHIC_CHAR_MASK, fgc, bgc);\n      }\n      else\n      {\n         let x, y;\n   \n         x = (offset%this.props.widthInChars)*this.cellWidth;\n         y = Math.floor(offset/this.props.widthInChars)*this.cellHeight;\n   \n         this.setFillStyleRGB(bgc);\n         this.ctx.fillRect(x, y, this.cellWidth, this.cellHeight);\n         if (value!=32) {\n            this.setFillStyleRGB(fgc);\n            const txt=String.fromCodePoint(value);\n            this.ctx.fillText(txt, x, y);\n         }\n      }\n   }\n   \n   //*************************************************\n   // !!TODO add ability to setRange colors\n   // !! should this take a bytearray?\n   // !! need to add \"getRange\" to match\n   setRange(start:number, values:[])\n   {\n      let k=0;\n      for (let i=start; i < start+values.length; i++) {\n         this.videoMem[i]=values[k++];\n      }\n      this.drawRange(start, start+values.length-1)\n   }\n\n   private drawRange(start:number, end:number)\n   {\n      for (let i=start; i <= end; i++) {\n         this.drawCell(i, this.videoMem[i], this.foreColorMem[i], this.backColorMem[i] );\n      }\n   }\n\n\n   /*************************************************/\n\n   setReset(x:number, y:number, isset:boolean) : void\n   {\n      const loc = Math.floor(x/2)+this.props.widthInChars*Math.floor(y/3);\n      const cellx = x%2;\n      const celly = y%3;\n\n      if (x<0 || x>this.props.widthInChars*2) throw new Error(\"setReset: invalid x value\");\n      if (y<0 || y>this.props.heightInChars*3) throw new Error(\"setReset: invalid y value\");\n\n      if (!((this.videoMem[loc]&TRS80_GRAPHIC_MARKER_MASK)==TRS80_GRAPHIC_MARKER)) {\n         this.videoMem[loc]= TRS80_GRAPHIC_MARKER;\t/* set to a cleared graphics value */\n         this.backColorMem[loc]=this.props.backColorAsRGB;\n         this.foreColorMem[loc]=this.props.foreColorAsRGB;\n      }\n\n      if (isset)\n         this.videoMem[loc]|= (1<<(celly*2+cellx));\n      else\n         this.videoMem[loc]&= ~(1<<(celly*2+cellx));\n\n      this.drawRange(loc, loc);\n   }\n\n   //*************************************************\n\n   point(x:number, y:number) : boolean\n   {\n      const loc = Math.floor(x/2)+this.props.widthInChars*Math.floor(y/3);\n      const cellx = x%2;\n      const celly = y%3;\n\n      if (x<0 || x>this.props.widthInChars*2) throw new Error(\"Point: invalid x value\");\n      if (y<0 || y>this.props.heightInChars*3) throw new Error(\"Point: invalid y value\");\n\n      if (!((this.videoMem[loc]&TRS80_GRAPHIC_MARKER_MASK)==TRS80_GRAPHIC_MARKER))\n         return false;\t/* not a graphic cell, so false */\n\n      if (this.videoMem[loc]&(1<<(celly*2+cellx)))\n         return true;\n      else \n         return false;\n   }\n\n\n   //*************************************************\n\n   setCursor(location:number) : void\n   {\n      if (location<0 || location>=this.size) throw new Error(\"setCursor: invalid location: \"+location);\n\n      this.props.cursorPos = location;\n   }\n\n   //*************************************************\n\n   setCursorXY(x:number, y:number) {\n      if (x<0 || y<0 || this.props.widthInChars*y+x >= this.size) throw new Error(\"setCursorXY: invalid parameter(s)\");\n      this.setCursor(this.props.widthInChars*y+x); \n   }\n\n   //*************************************************\n\n   setColors(foreground:number, background:number) : void \n   {\n      this.props.foreColorAsRGB=foreground;\n      this.props.backColorAsRGB=background;\n   }\n}\n\n//*************************************************\n\nexport class twrConsoleTerminalProxy implements IConsoleTerminalProxy {\n   keys: twrSharedCircularBuffer;\n   returnValue: twrSharedCircularBuffer;\n\tid:number;\n\n   constructor(params:TConsoleTerminalProxyParams) {\n       const [className, id, returnBuffer, keysBuffer] = params;\n       this.keys = new twrSharedCircularBuffer(keysBuffer);\n       this.returnValue = new twrSharedCircularBuffer(returnBuffer);\n\t\t this.id=id;\n   }\n\n   getProp(propName: string):number\n   { \n      postMessage([\"term-getprop\", [this.id, propName]]);\n      return this.returnValue.readWait();  // wait for result, then read it\n   }\n   \n   charIn() {  \n       return this.keys.readWait();  // wait for a key, then read it\n   }\n\n   point(x:number, y:number):boolean\n   { \n      postMessage([\"term-point\", [this.id, x, y]]);\n      return this.returnValue.readWait()!=0;  // wait for result, then read it\n   }\n   \n   charOut(ch:number, codePoint:number) {\n      postMessage([\"term-charout\", [this.id, ch, codePoint]]);\n   }\n\n   putStr(str:string):void\n   {\n      postMessage([\"term-putstr\", [this.id, str]]);\n   }\n\n   cls():void\n   { \n      postMessage([\"term-cls\", [this.id]]);\n   }\n\n   setRange(start:number, values:[]):void\n   { \n      postMessage([\"term-setrange\", [this.id, start, values]]);\n   }\n\n   setC32(location:number, char:number):void\n   { \n      postMessage([\"term-setc32\", [this.id, location, char]]);\n   }\n\n   setReset(x:number, y:number, isset:boolean):void\n   { \n      postMessage([\"term-setreset\", [this.id, x, y, isset]]);\n   }\n\n   setCursor(pos:number):void\n   { \n      postMessage([\"term-setcursor\", [this.id, pos]]);\n   }\n\n   setCursorXY(x:number, y:number):void\n   { \n      postMessage([\"term-setcursorxy\", [this.id, x, y]]);\n   }\n\n   setColors(foreground:number, background:number):void\n   {\n      postMessage([\"term-setcolors\", [this.id, foreground, background]]);\n   }\n\n   setFocus() {\n      postMessage([\"term-focus\", [this.id]]);\n   }\n\n}"],"names":["$d97fe2e0130c8ea6$var$twrSignalState","$496ef95f52233740$var$D2DType","twrSignalState","D2DType","$2e39aae7c890164c$var$mod","Object","defineProperty","get","$2e39aae7c890164c$export$a5f3f3f0bd96bb23","set","s","enumerable","configurable","$9bb9a90df2906a7c$export$918ffb7e046a537b","mod","constructor","atod","strptr","len","str","getString","upper","trimStart","toUpperCase","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","parseFloat","replaceAll","dtoa","buffer","buffer_size","value","max_precision","r","toString","copyString","length","toPrecision","toFixed","decdigits","toExponential","fcvtS","sizeInBytes","fracpart_numdigits","dec","sign","digits","decpos","isNaN","slice","isFinite","Math","abs","mem32","intPart","fracPart","roundValStr","split","replace","setLong","$07ff08a59ba75008$export$c7de3f2686797480","decoderUTF8","TextDecoder","decoder1252","convert","c","codePage","outstr","decode","Uint8Array","stream","String","fromCharCode","fromCodePoint","Error","codePointAt","$07ff08a59ba75008$var$cpTranslate","$07ff08a59ba75008$export$b1748e2af4950b56","cp","$07ff08a59ba75008$var$noasyncCopyString","outbuf","sin","ru8","stringToU8","mem8","$07ff08a59ba75008$export$99a2816c432302a9","$07ff08a59ba75008$var$noasyncPutString","navigator","language","$07ff08a59ba75008$export$6e12283a61625fd2","regexpStrIdx","regexp","RegExp","cstr","test","$07ff08a59ba75008$export$8644084c19ac418e","instr","normalize","console","log","$07ff08a59ba75008$export$1619a0be8731b76a","toLocaleLowerCase","$07ff08a59ba75008$export$b8cd0608a44dce64","toLocaleUpperCase","$07ff08a59ba75008$export$2663d7470da86e92","lhs","rhs","lhStr","undefined","rhStr","collator","Intl","Collator","compare","$07ff08a59ba75008$export$a0bf9983b7d1ed7c","tmIdx","epochSecs","d","Date","getSeconds","getMinutes","getHours","getDate","getMonth","getFullYear","getDay","$07ff08a59ba75008$var$getDayOfYear","date","start","floor","diff","getTime","timeString","toLocaleTimeString","timeZoneName","includes","getTimezoneOffset","timeZone","pop","$07ff08a59ba75008$var$setAndPutString","idx","stridx","strIndex","malloc","exports","$07ff08a59ba75008$export$714291919e374cc0","lconvIdx","locDec","formattedNumber","formatter","NumberFormat","format","charAt","locSep","minimumFractionDigits","$07ff08a59ba75008$var$getLocalCurrencySymbol","$07ff08a59ba75008$export$6e74b5e725f469d6","dtnamesStructIdx","i","$07ff08a59ba75008$var$getLocalizedDayName","$07ff08a59ba75008$var$getLocalizedMonthNames","$07ff08a59ba75008$var$getLocalizedAM","morningDate","dayPeriodPart","formattedParts","DateTimeFormat","hour","hour12","formatToParts","find","part","type","$07ff08a59ba75008$var$getLocalizedPM","afternoonDate","n","weekdayType","setDate","weekday","monthType","month","$650c04823a04b22b$export$c83a0a3bffe07399","memory","memD","isAsyncProxy","floatUtil","Uint32Array","Float64Array","loadWasm","pathToLoad","imports","ioNamesToID","response","fetch","err","ok","statusText","wasmBytes","arrayBuffer","instance","WebAssembly","instantiate","env","ArrayBuffer","postMessage","size","Promise","resolve","m","init","stack","twrInit","twr_wasm_init","stdio","stderr","std2d","callC","params","cparams","preCallC","retval","callCImpl","postCallC","fname","f","Array","ci","p","putString","URL","fetchAndPutURL","putArrayBuffer","u8","j","encoder","TextEncoder","encode","putU8","u8a","dest","ab","fnin","src","getLong","idx32","getDouble","idx64","setDouble","getShort","encodeFormat","indexOf","td","u8todecode","regularUint8Array","getU8Arr","rv","dataptr","getU32Arr","$25e0032167928e0e$export$a952b8f8c62754b8","now","$997394d69310721e$export$a01cca24f011573a","sharedArray","buf","sa","window","crossOriginIsolated","location","protocol","SharedArrayBuffer","Int32Array","write","Atomics","notify","read","isEmpty","readWait","rdptr","wait","$99d2301965139f24$export$5d8b86200307417d","CHARREAD","CHARWRITE","ADDRESSABLE_DISPLAY","CANVAS2D","EVENTS","$6a274cb2c782baea$export$401f32ea04a2dc08","consoles","registerConsole","con","push","getConsole","id","getConsoleID","$6a274cb2c782baea$export$c966f466478010bf","registerConsoleProxy","getConsoleProxy","$c484b2e8c67a7340$export$e4a97cb991521e57","keys","className","keysBuffer","charIn","inkey","charOut","ch","codePoint","putStr","getProp","propName","setFocus","$d97fe2e0130c8ea6$export$e37a7b7b851b97f3","WAITING","signal","SIGNALED","isSignaled","reset","$7c86b727c15072df$export$78d2a4633fe89379","callCompleteSignal","parameters","sleep","ms","$496ef95f52233740$export$97cec2c338f46b48","canvasKeys","drawCompleteSignal","props","signalBuffer","canvasKeysBuffer","drawSeq","ds","$f04c956722c3945f$export$bcb1e5070a093206","$e8e3453ed3aa6b92$export$6dc37146168f9b6c","returnValue","returnBuffer","point","x","y","cls","setRange","values","setC32","char","setReset","isset","setCursor","pos","setCursorXY","setColors","foreground","background","self","onmessage","e","data","allProxyParams","urlToLoad","then","catch","ex","rc","cpTranslate","getProxyInstance","conProxyParams","waitingCallsProxy","waitingCallsProxyParams","conProxyCall","funcName","jsid","args","call","twrTimeEpoch","twrTimeTmLocal","bind","twrUserLconv","twrUserLanguage","twrRegExpTest1252","twrToLower1252","twrToUpper1252","twrStrcoll","twrUnicodeCodePointToCodePage","twrCodePageToUnicodeCodePoint","twrGetDtnames","twrGetConIDFromName","nameIdx","name","twrSleep","twrConCharOut","twrConCharIn","twrSetFocus","twrConGetProp","pn","twrConCls","twrConSetC32","twrConSetReset","twrConPoint","twrConSetCursor","twrConSetColors","twrConSetRange","chars","twrConPutStr","twrConDrawSeq","twrSin","twrCos","cos","twrTan","tan","twrFAbs","twrACos","acos","twrASin","asin","twrATan","atan","twrExp","exp","twrFloor","twrCeil","ceil","twrFMod","twrLog","twrPow","pow","twrSqrt","sqrt","twrTrunc","trunc","twrDtoa","twrToFixed","twrToExponential","twrAtod","twrFcvtS"],"version":3,"file":"twrmodasyncproxy.c3081bc6.js.map"}