{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Easier WebAssembly with twr-wasmDocumentation and Examples","text":"<p>Version 2.5.0</p> <p>twr-wasm is a simple, lightweight and easy to use library for building C/C++ WebAssembly code directly with clang. Run C/C++ code in a web browser. Legacy code, libraries, full applications, or single functions can be integrated with JavaScript and TypeScript. twr-wam solves some common use cases with less work than the more feature rich emscripten. </p> <p>Key Features:</p> <ul> <li>build <code>.wasm</code> modules using C/C++ using clang directly (no wrapper)</li> <li>from JavaScript load <code>.wasm</code> modules, call C/C++ functions, and access wasm memory</li> <li> <p>comprehensive console support for <code>stdin</code>, <code>stdio</code>, and <code>stderr</code>.</p> <ul> <li>in C/C++, print and get characters to/from <code>&lt;div&gt;</code> tags in your HTML page</li> <li>in C/C++, print and get characters to/from a <code>&lt;canvas&gt;</code> based \"terminal\"</li> <li>localization support, UTF-8, and windows-1252 support</li> </ul> </li> <li> <p>the optional TypeScript <code>class twrWasmModuleAsync</code> can be used to:</p> <ul> <li>integrate a C/C++ Read-Eval-Print Loop (REPL) with JavaScript</li> <li>integrate a C/C++ CLI or Shell with JavaScript</li> <li>In JavaScript <code>await</code> on blocking/synchronous C/C++ functions. </li> </ul> </li> <li> <p>2D drawing API for C/C++ compatible with JavaScript Canvas</p> </li> <li>audio playback APIs for C/C++</li> <li>create your own C/C++ APIs using TypeScript by extending <code>class twrLibrary</code></li> <li>standard C library optimized for WebAssembly</li> <li>libc++ built for WebAssembly</li> <li>comprehensive examples and documentation</li> <li>TypeScript and JavaScript support</li> </ul>"},{"location":"#live-webassembly-examples-and-source","title":"Live WebAssembly Examples and Source","text":"Name View Live Link Source Link Bouncing Balls (C++) View bouncing balls Source for balls Pong (C++) Pong Source Input/Output with <code>&lt;div&gt;</code> View square demo Source I/O to terminal with <code>&lt;canvas&gt;</code> View demo Source CLI using libc++ and <code>&lt;canvas&gt;</code>) View console Source"},{"location":"#hello-world","title":"Hello World","text":"<p>Here is the simplest <code>twr-wasm</code> example.</p> helloworld.c<pre><code>#include &lt;stdio.h&gt;\n\nvoid hello() {\n    printf(\"hello, world!\\n\");\n}\n</code></pre> index.html<pre><code>&lt;head&gt;\n   &lt;title&gt;Hello World&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n   &lt;div id=\"twr_iodiv\"&gt;&lt;/div&gt;\n\n   &lt;script type=\"module\"&gt;\n      import {twrWasmModule} from \"twr-wasm\";\n\n      const mod = new twrWasmModule();\n      await mod.loadWasm(\"./helloworld.wasm\");\n      await mod.callC([\"hello\"]);\n   &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"#on-github","title":"On Github","text":"<p>https://github.com/twiddlingbits/twr-wasm</p>"},{"location":"#why","title":"Why?","text":"<p>The Wasm Runtime Limitations section explains why a library like twr-wasm is needed to use WebAssembly.</p>"},{"location":"#limitations","title":"Limitations","text":"<ul> <li>libc++ not built with exceptions enabled</li> <li>some standard C library functions are not 100% implemented</li> <li>Designed to work with a browser.  Not tested with or designed to work with node.js  </li> <li>Not all of compile-rt is ported (but most bits you need are)</li> </ul>"},{"location":"#post-feedback","title":"Post Feedback","text":"<p>Please post feedback (it worked for you, didn't work, requests, questions, etc) at https://github.com/twiddlingbits/twr-wasm/</p>"},{"location":"api/api-c-audio/","title":"Audio API for WebAssembly","text":"<p>This section describes twr-wasm's C Audio API, which allows audio API functions to be called using C/C++ from WebAssembly.</p>"},{"location":"api/api-c-audio/#examples","title":"Examples","text":"Name View Live Link Source Link Pong (C++) View Pong Source for Pong tests-audio View tests-audio Source for tests-audio"},{"location":"api/api-c-audio/#code-example","title":"Code Example","text":"Play Audio<pre><code>#include \"twr-audio.h\"\n#include &lt;math.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define M_PI 3.14159265358979323846\n\nvoid play() {\n   twr_audio_play_file(\"example.mp3\"); //plays audio from specified URL\n\n   const long SAMPLE_RATE = 48000; //48,000 samples per second\n   const double DURATION = 10.0; //play for 10 seconds\n   const double freq = 493.883; //Middle B (B4)\n\n   long length = (long)ceil(SAMPLE_RATE*DURATION);\n   //PCM audio data in the form of -1.0 to 1.0\n   float* wave = (float*)malloc(sizeof(float) * length);\n\n   //generate square wave at specified frequency and duration\n   for (long i = 0; i &lt; length; i++) {\n      wave[i] = cos(2*M_PI*freq*(i/(float)sample_rate)) &gt; 0 ? 1 : -1;\n   }\n\n   //creates a mon-audio channel buffer at our given SAMPLE_RATE\n   // and square-wave data we generated\n   long node_id = twr_audio_from_float_pcm(1, SAMPLE_RATE, wave, length);\n\n   //plays the square wave\n   // Can be played multiple times, and is only freed on twr_audio_free\n   twr_audio_play(node_id);\n}\n</code></pre>"},{"location":"api/api-c-audio/#overview","title":"Overview","text":"<p>The Audio API is part a twr-wasm library that can be accessed via <code>#include \"twr-audio.h\"</code>. It has two main methods to play audio: from raw PCM data and from a URL. </p> <p>Raw PCM data can be initialized via <code>twr_audio_from_&lt;type&gt;_pcm</code> or <code>twr_audio_load</code>. There are multiple types for <code>twr_audio_from_&lt;type&gt;_pcm</code>. These types include Float, 8bit, 16bit, and 32bit. Float takes in values between -1.0 and 1.0. Meanwhile, the 8bit, 16bit, and 32bit versions take them in as signed numbers between their minimum and maximum values. <code>twr_audio_load</code>, on the other hand, reads the PCM data from an audio file that is specified by a URL. This method does not stream the audio, so it might take some time to read the file (depending how long the file is). Each function returns an integer <code>node_id</code> that identifies the loaded PCM data.  Once the PCM data is initialized, it can be played via functions like <code>twr_audio_play</code>, <code>twr_audio_play_range</code>, <code>twr_audio_play_sync</code>, and <code>twr_audio_play_range_sync</code>.  The play functions can be called multiple times for each audio ID.</p> <p>You can also play audio directly from a URL. Unlike <code>twr_audio_load</code>, the url is initialized directly into an <code>HTMLAudioElement</code> which streams the audio and starts playback immediately.</p> <p>In addition to playing audio, there are functions that allow you to query and modify an ongoing playback. These include stopping the playback, getting how long it's been playing, and modifying the pan; volume; or playback rate of the audio.</p>"},{"location":"api/api-c-audio/#notes","title":"Notes","text":"<p>When playing audio, a <code>playback_id</code> is returned to query or modify the playback. However, once playback completes, the <code>playback_id</code> becomes invalid. Most functions that take in a <code>playback_id</code> will simply return a warning and return without error if the <code>playback_id</code> is invalid. An exception is <code>twr_audio_query_playback_position</code> which will return -1 when given an invalid <code>playback_id</code>.</p> <p>Functions that end in <code>_sync</code> are for use with <code>twrWamModuleAsync</code>, and are synchronous.  Meaning they don't return until the operation, such as playback, is complete.</p> <p>Note that on some platforms, sounds that are too short might not play correctly.  This is true in JavaScript as well.</p>"},{"location":"api/api-c-audio/#functions","title":"Functions","text":"<p>These are the current Audio APIs available in C/C++:</p> <pre><code>long twr_audio_from_float_pcm(long num_channels, long sample_rate, float* data, long singleChannelDataLen);\nlong twr_audio_from_8bit_pcm(long number_channels, long sample_rate, char* data, long singleChannelDataLen);\nlong twr_audio_from_16bit_pcm(long number_channels, long sample_rate, short* data, long singleChannelDataLen);\nlong twr_audio_from_32bit_pcm(long number_channels, long sample_rate, int* data, long singleChannelDataLen);\n\nfloat* twr_audio_get_float_pcm(long node_id, long* singleChannelDataLenPtr, long* numChannelsPtr);\nchar* twr_audio_get_8bit_pcm(long node_id, long* singleChannelDataLenPtr, long* numChannelsPtr);\nshort* twr_audio_get_16bit_pcm(long node_id, long* singleChannelDataLenPtr, long* numChannelsPtr);\nint* twr_audio_get_32bit_pcm(long node_id, long* singleChannelDataLenPtr, long* numChannelsPtr);\n\nlong twr_audio_play(long node_id);\nlong twr_audio_play_volume(long node_id, double volume, double pan);\nlong twr_audio_play_callback(long node_id, double volume, double pan, int finish_callback);\n\nstruct PlayRangeFields {\n   double pan, volume;\n   int loop, finish_callback;\n   long sample_rate;\n};\nstruct PlayRangeFields twr_audio_default_play_range();\nlong twr_audio_play_range(long node_id, long start_sample, long end_sample);\nlong twr_audio_play_range_ex(long node_id, long start_sample, long end_sample, struct PlayRangeFields* fields);\n\nlong twr_audio_play_sync(long node_id);\nlong twr_audio_play_sync_ex(long node_id, double volume, double pan);\n\n\nstruct PlayRangeSyncFields {\n   double pan, volume;\n   int loop;\n   long sample_rate;\n};\n\nstruct PlayRangeSyncFields twr_audio_default_play_range_sync();\nlong twr_audio_play_range_sync(long node_id, long start_sample, long end_sample);\nlong twr_audio_play_range_sync_ex(long node_id, long start_sample, long end_sample, struct PlayRangeSyncFields* fields);\n\nlong twr_audio_load_sync(char* url);\nlong twr_audio_load(int event_id, char* url);\nlong twr_audio_query_playback_position(long playback_id);\nvoid twr_audio_free_id(long node_id);\n\nvoid twr_audio_stop_playback(long playback_id);\n\nvoid twr_audio_modify_playback_volume(long playback_id, double volume);\nvoid twr_audio_modify_playback_pan(long playback_id, double pan);\nvoid twr_audio_modify_playback_rate(long playback_id, double sample_rate);\n\nlong twr_audio_play_file(char* file_url);\nlong twr_audio_play_file_ex(char* file_url, double volume, double playback_rate, int loop);\n\nstruct AudioMetadata {\n   long length;\n   long sample_rate;\n   long channels;\n};\n\nvoid twr_audio_get_metadata(long node_id, struct AudioMetadata* metadata);\n</code></pre>"},{"location":"api/api-c-con/","title":"WebAssembly Character Console API","text":"<p>twr-wasm for WebAssembly provides Consoles for interactive user I/O. Character and graphic 2D draw consoles exist.  This section covers the streaming and addressable character APIs that can be used with an instance of twrConsoleDebug, twrConsoleTerminal, twrConsoleDiv. This API works with stdin, stdout, stderr and custom named consoles.</p> <p>Also see the Consoles section in Getting Started</p>"},{"location":"api/api-c-con/#examples","title":"Examples","text":"Name View Live Link Source Link \"terminal\" in/out with a <code>&lt;canvas&gt;</code> View mini-term demo Source"},{"location":"api/api-c-con/#getting-a-console","title":"Getting a Console","text":""},{"location":"api/api-c-con/#stdin-stdout-stderr","title":"stdin, stdout, stderr","text":"<p><code>stdin</code>, <code>stdout</code>, <code>stderr</code> are defined in <code>&lt;stdio.h&gt;</code>.</p> <p>This section describes how to configure stdio</p> <p>In C, consoles are represented by a <code>twr_ioconsole_t</code>. </p> <p>stdio.h also defines <code>FILE</code> like this: <pre><code>typedef twr_ioconsole_t FILE; \n</code></pre></p> <p>from <code>&lt;stdio.h&gt;</code>: <pre><code>#define stderr (FILE *)(twr_get_stderr_con())\n#define stdin (FILE *)(twr_get_stdio_con())\n#define stdout (FILE *)(twr_get_stdio_con())\n</code></pre></p>"},{"location":"api/api-c-con/#twr_get_console","title":"twr_get_console","text":"<p>This function will retrieve a console by its name.  The standard names are <code>stdio</code>, <code>stderr</code>, and <code>std2d</code>.  In addition, any named console that was passed to a module using the <code>io</code> option can be retrieved with this function.</p> <p>See io doc.</p> <p>See the multi-io example.</p> <pre><code>#include \"twr-crt.h\"\n\ntwr_ioconsole_t* twr_get_console(const char* name)\n</code></pre>"},{"location":"api/api-c-con/#io_nullcon","title":"io_nullcon","text":"<p>Returns an IoConsole that goes to the bit bucket.  io_getc32 will return 0.</p> <pre><code>#include \"twr-io.h\"\n\ntwr_ioconsole_t* io_nullcon(void);\n</code></pre>"},{"location":"api/api-c-con/#io-console-functions","title":"IO Console Functions","text":""},{"location":"api/api-c-con/#io_cls","title":"io_cls","text":"<p>For addressable display consoles only.</p> <p>Clears the screen.  That is, all character cells in the console are set to a space, their colors are reset to the current default colors (see <code>io_set_colors</code>).</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_cls(twr_ioconsole_t* io);\n</code></pre>"},{"location":"api/api-c-con/#io_getc32","title":"io_getc32","text":"<p>Waits for the user to press a key and then returns a unicode code point. </p> <p>To return characters encoded with the current locale, see <code>io_mbgetc</code></p> <pre><code>#include &lt;twr_io.h&gt;\n\nint io_getc32(twr_ioconsole_t* io);\n</code></pre>"},{"location":"api/api-c-con/#io_get_colors","title":"io_get_colors","text":"<p>For addressable display consoles only.</p> <p>Gets the current default foreground and background colors.  These colors are used by an new text updates.</p> <p>The color format is a 24 bit int as RGB.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_get_colors(twr_ioconsole_t* io, unsigned long *foreground, unsigned long *background);\n</code></pre>"},{"location":"api/api-c-con/#io_get_cursor","title":"io_get_cursor","text":"<p>Returns an integer of the current cursor position.  The cursor is where the next <code>io_putc</code> is going to go. </p> <p>For addressable display consoles, the cursor position ranges from [0, width*height-1], inclusive.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nint io_get_cursor(twr_ioconsole_t* io);\n</code></pre>"},{"location":"api/api-c-con/#io_get_prop","title":"io_get_prop","text":"<p>Given a string key (name) of a property, returns its integer value.  The available properties varies by console type. <pre><code>#include &lt;twr_io.h&gt;\n\nint io_get_prop(twr_ioconsole_t* io, const char* key)\n</code></pre> All consoles support: \"type\".</p> <p>Addressable consoles also support:     \"cursorPos\", \"charWidth\", \"charHeight\", \"foreColorAsRGB\",  \"backColorAsRGB\",     \"widthInChars\", \"heightInChars\", \"fontSize\", \"canvasWidth\", \"canvasHeight\"</p> <p>You can do a bitwise <code>&amp;</code> on type with the following C defines to determine a console capabilities:</p> <ul> <li><code>IO_TYPE_CHARREAD</code></li> <li><code>IO_TYPE_CHARWRITE</code></li> <li><code>IO_TYPE_ADDRESSABLE_DISPLAY</code></li> <li><code>IO_TYPE_CANVAS2D</code></li> </ul> <p>For example: <pre><code>if (io_get_prop(stdin, \"type\")&amp;IO_TYPE_CHARREAD) {\n   printf (\"okay to read from stdin);\n}\n</code></pre></p>"},{"location":"api/api-c-con/#io_get_width","title":"io_get_width","text":"<p>Returns the width in characters of an addressable console.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nint io_get_width(twr_ioconsole_t* io);\n</code></pre>"},{"location":"api/api-c-con/#io_get_height","title":"io_get_height","text":"<p>Returns the height in characters of an addressable console.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nint io_get_height(twr_ioconsole_t* io);\n</code></pre>"},{"location":"api/api-c-con/#io_set_colors","title":"io_set_colors","text":"<p>For addressable display consoles only.</p> <p>Sets a 24 bit RGB default color for the foreground and background.  The prior default colors are changed (lost).  For example, if you set the default colors when you created the console (see twrConsoleTerminal Options), the defaults will no longer be active.  Use <code>io_get_colors</code> to save existing colors for later restoration using <code>io_set_colors</code>.</p> <p>A call to <code>io_set_colors</code> doesn't actually cause any on screen changes.  Instead, these new default colors are used in future draw and text calls.  A foreground and background color is set for each cell in the console window.  The cell's colors are set to these default foreground/background colors when a call to <code>io_setc</code>, <code>io_setreset</code>, etc is made.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_set_colors(twr_ioconsole_t* io, unsigned long foreground, unsigned long background);\n</code></pre>"},{"location":"api/api-c-con/#io_setc","title":"io_setc","text":"<p>For addressable display consoles only.</p> <p>Sets a console cell to the specified character.  Sends a byte to an console and supports the current locale's character encoding.    This function will \"stream\" using the current code page.  In other words, if you are in the \"C\" locale <code>io_setc</code> it will set ASCII characters.  If the current locale is set to 1252, then you can send windows-1252 encoded characters.  If the current locale is UTF-8, then you can stream UTF-8 (that is, call <code>io_setc</code> once for each byte of the multi-byte UTF-8 character).</p> <pre><code>#include &lt;twr_io.h&gt;\n\nbool io_setc(twr_ioconsole_t* io, int location, unsigned char c);\n</code></pre>"},{"location":"api/api-c-con/#io_setc32","title":"io_setc32","text":"<p>For addressable display consoles only.</p> <p>Sets a console cell to a unicode code point.  The colors are set to the defaults (see <code>io_set_colors</code>).</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_setc32(twr_ioconsole_t* io, int location, int c);\n</code></pre>"},{"location":"api/api-c-con/#io_set_cursor","title":"io_set_cursor","text":"<p>Moves the cursor.  See <code>io_get_cursor</code>.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_set_cursor(twr_ioconsole_t* io, int loc);\n</code></pre>"},{"location":"api/api-c-con/#io_set_cursorxy","title":"io_set_cursorxy","text":"<p>Set's the cursor's x,y position in an addressable console.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_set_cursorxy(twr_ioconsole_t* io, int x, int y);\n</code></pre>"},{"location":"api/api-c-con/#io_setfocus","title":"io_setfocus","text":"<p>Sets the input focus to the indicated console.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_setfocus(twr_ioconsole_t* io);\n</code></pre>"},{"location":"api/api-c-con/#io_set_range","title":"io_set_range","text":"<p>Sets a range of characters in an addressable display.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_set_range(twr_ioconsole_t* io, int *chars32, int start, int len)\n</code></pre>"},{"location":"api/api-c-con/#io_setreset","title":"io_setreset","text":"<p>For addressable display consoles only.</p> <p>Sets or resets (clears) a chunky graphics \"pixel\".  Each character cell can also be a 2x3 grid of graphic \"pixels\".  In other words, the terminal window has pixel dimensions of width2 x height3.</p> <p>The color will be set to the defaults if the impacted cell is not a graphics cell.  If it is an existing graphics cell, the colors don't change.</p> <p>See the <code>terminal</code> example.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nbool io_setreset(twr_ioconsole_t* io, int x, int y, bool isset);\n</code></pre>"},{"location":"api/api-c-con/#io_mbgetc","title":"io_mbgetc","text":"<p><code>io_mbgetc</code> will get a character from stdin and encode it using the character encoding of the LC_CTYPE category of the current locale.  \"C\" will use ASCII.  UTF-8 and windows-1252 are also supported.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_mbgetc(twr_ioconsole_t* io, char* strout);\n</code></pre>"},{"location":"api/api-c-con/#io_mbgets","title":"io_mbgets","text":"<p>Gets a string from a Console.  Returns when the user presses \"Enter\".  Displays a cursor character and echos the inputted characters, at the current cursor position. Uses character encoding of LC_TYPE of current locale.  If the encoding is UTF-8, then the result will be multibyte.</p> <p>This function is commonly used with  <code>stdin</code>.</p> <p>This function requires that you use <code>twrWasmModuleAsync</code>.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nchar *io_mbgets(twr_ioconsole_t* io, char *buffer );\n</code></pre>"},{"location":"api/api-c-con/#io_point","title":"io_point","text":"<p>For addressable display consoles only.</p> <p>Checks if a chunky graphics \"pixel\" is set or clear.  See <code>io_setreset</code>.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nbool io_point(twr_ioconsole_t* io, int x, int y);\n</code></pre>"},{"location":"api/api-c-con/#io_putc","title":"io_putc","text":"<p>Sends a byte to an IoConsole and supports the current locale's character encoding.    This function will \"stream\" using the current code page.  In other words, if you <code>io_putc</code> ASCII, it will work as \"normal\".  If the current locale is set to 1252, then you can send windows-1252 encoded characters.  If the current locale is UTF-8, then you can stream UTF-8 (that is, call <code>io_putc</code> once for each byte of the multi-byte UTF-8 character).</p> <p>Note that when characters are sent to the browser console using <code>stderr</code> they will not render to the console until a newline or return is sent.</p> <pre><code>#include \"twr-io.h\"\n\nvoid io_putc(twr_ioconsole_t* io, unsigned char c);\n</code></pre>"},{"location":"api/api-c-con/#io_putstr","title":"io_putstr","text":"<p>Calls <code>io_putc</code> for each byte in the passed string.</p> <pre><code>#include \"twr-io.h\"\n\nvoid io_putstr(twr_ioconsole_t* io, const char* s);\n</code></pre>"},{"location":"api/api-c-con/#io_printf","title":"io_printf","text":"<p>Identical to <code>fprintf</code>, however io_printf will call <code>io_begin_draw</code> and <code>io_end_draw</code> around its drawing activities -- resulting in snapper performance.</p> <p>For example: <pre><code>#include \"twr-io.h\"\n\nio_printf(twr_debugcon(), \"hello over there in browser debug console land\\n\");\n</code></pre></p> <p>or</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;twr_io.h&gt;\n\nio_printf(stdout, \"hello world\\n\");\n</code></pre> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_printf(twr_ioconsole_t *io, const char *format, ...);\n</code></pre>"},{"location":"api/api-c-con/#io_begin_draw","title":"io_begin_draw","text":"<p>For addressable display consoles only.</p> <p>This call (and its matching io_end_draw) are not required.  But if you bracket any call sequence that draws to the terminal window with an <code>io_begin_draw</code> and <code>io_end_draw</code>, the updates will be batched into one update.  This will increase performance and usually prevents the user from seeing partial updates.</p> <p><code>io_begin_draw</code> can be nested. </p> <p>See the terminal example.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_begin_draw(twr_ioconsole_t* io);\n</code></pre>"},{"location":"api/api-c-con/#io_end_draw","title":"io_end_draw","text":"<p>For addressable display consoles only.</p> <p>See <code>io_begin_draw</code>.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_end_draw(twr_ioconsole_t* io);\n</code></pre>"},{"location":"api/api-c-con/#deprecated-functions","title":"Deprecated Functions","text":""},{"location":"api/api-c-con/#twr_debugcon","title":"twr_debugcon","text":"<p>This function has been removed.  Use <code>stderr</code> or <code>twr_conlog</code>.</p> <pre><code>#include \"twr-crt.h\"\n\ntwr_conlog(\"hello 99 in hex: %x\", 99);\n</code></pre> <p>or</p> <pre><code>#include &lt;stdio.h&gt;\n\nfprintf(stderr, \"hello over there in browser debug console land\\n\");\n</code></pre>"},{"location":"api/api-c-con/#twr_divcon","title":"twr_divcon","text":"<p>This function has been removed.</p>"},{"location":"api/api-c-con/#twr_windowcon","title":"twr_windowcon","text":"<p>This function has been removed.</p>"},{"location":"api/api-c-d2d/","title":"2D Draw C API for WebAssembly","text":"<p>This section describes twr-wasm's C D2D API, which allows your WebAssembly module to call many of the JavaScript Canvas APIs.  </p>"},{"location":"api/api-c-d2d/#examples","title":"Examples","text":"Name View Live Link Source Link Bouncing Balls (C++) View bouncing balls Source for balls Pong (C++) View Pong Source for Pong Maze (Win32 C Port) View live maze here Source for maze"},{"location":"api/api-c-d2d/#code-example","title":"Code Example","text":"Draw A Rectangle<pre><code>#include \"twr-draw2d.h\"\n\nvoid square() {\n   // batch draw commands, with a maximum of 100 commands before render\n   struct d2d_draw_seq* ds=d2d_start_draw_sequence(100);\n   // set color using CSS color string\n   d2d_setfillstyle(ds, \"blue\");\n   // draw a the rect\n   d2d_fillrect(ds, 10, 10, 100, 100);\n   // this will cause the JavaScript thread to render\n   d2d_end_draw_sequence(ds);\n}\n</code></pre>"},{"location":"api/api-c-d2d/#overview","title":"Overview","text":"<p>The Draw 2D APIs are C APIs and are part of the twr-wasm library that you access with <code>#include \"twr-draw2d.h\"</code>.  There is also a C++ canvas wrapper class in <code>examples/twr-cpp</code> used by the balls and pong examples.</p> <p>To create a canvas surface, that you can draw to using the twr-wasm 2D C drawing APIs, use the <code>twrConsoleCanvas</code> class in your JavaScript/HTML (see Consoles Section).  Or more simply, if you add a canvas tag to your HTML named <code>twr_d2dcanvas</code>, the needed <code>twrConsoleCanvas</code> will be created automatically.</p> <pre><code>&lt;canvas id=\"twr_d2dcanvas\" width=\"600\" height=\"600\"&gt;&lt;/canvas&gt;\n//Feel free to change the `width=\"600` and/or `height=\"600` attributes.\n</code></pre> <p>To draw using the C 2D Draw API:</p> <ul> <li>call <code>d2d_start_draw_sequence</code>  (or alternately <code>d2d_start_draw_sequence_with_con</code>)</li> <li>call one or more (a sequence) of 2D draw commands, like <code>d2d_fillrect</code></li> <li>call <code>d2d_end_draw_sequence</code></li> <li>repeat as desired</li> </ul> <p><code>d2d_start_draw_sequence</code> will draw to the default <code>twrConsoleCanvas</code>, as explained at the start of this section.  <code>d2d_start_draw_sequence_with_con</code> is optional, and allows you to specify the <code>twrConsoleCanvas</code> to draw to.  You would typically get this console in C using the <code>twr_get_console</code> function (which retrieves a named console that you specified in the <code>io</code> module option.)</p> <p>Commands are queued until flushed -- which will take the batch of queued draw commands, and execute them.  The 2D draw APIs will work with either <code>twrWasmModule</code> or <code>twrWasmModuleAsync</code>.   With <code>twrWasmModuleAsync</code>, the batch of commands is sent from the worker thread over to the JavaScript main thread for execution. By batching the calls between calls to <code>d2d_start_draw_sequence</code> and <code>d2d_end_draw_sequence</code>, performance is improved.</p> <p><code>d2d_flush</code> waits for the commands to finish execution before returning.  <code>d2d_flush</code> is called automatically by <code>d2d_end_draw_sequence</code> and so you generally don't need to call it manually.</p> <p>You pass an argument to <code>d2d_start_draw_sequence</code> specifying how many instructions will trigger an automatic call to <code>d2d_flush</code>.  You can make this larger for efficiency, or smaller if you want to see the render progress more frequently.  There is no limit on the size of the queue, except memory used in the Wasm module.  The <code>d2d_flush</code> function can be called manually, but this is not normally needed, unless you would like to ensure a sequence renders before your <code>d2d_end_draw_sequence</code> is called, or before the count passed <code>d2d_start_draw_sequence</code> is met.</p> <p>If you are using <code>twrWasmModuleAsync</code>, or if you are re-rendering the entire frame for each animation update, you should ensure that all of your draws for a complete frame are made without an explicit or implicit call to <code>d2d_flush</code> in the middle of the draw sequence, as this may cause flashing.</p>"},{"location":"api/api-c-d2d/#possible-pitfalls","title":"Possible Pitfalls","text":"<p>Some commands have extra details that you need to be aware of to avoid performance loss or bugs.</p> <ul> <li>Getters, like d2d_measuretext, will flush the queue in order to retrieve the requested data. If your program relies on not flushing early (for example, to avoid flashes), then getters should be avoided in your main render loops.</li> <li>putImageData references the provided pointer, so the given image data needs to stay valid on the caller's stack or heap until flush is called.</li> <li>getLineDash takes in a buffer_length, double * array (the buffer), and returns the amount of the buffer filled. If there are more line segments than can fit in the buffer_length, a warning is printed and the excess is voided. If you want to know the size before hand for allocation, the getLineDashLength function is available.</li> </ul>"},{"location":"api/api-c-d2d/#notes","title":"Notes","text":"<p>The functions listed below are based on the JavaScript Canvas 2D API (found here). However, there are some slight differences since these APIs are made for C rather than JavaScript.  For example some items keep resources stored on the JavaScript side (such as d2d_createlineargradient) which are referenced by a numeric ID , rather than an actual object reference.</p> <p>Additionally, there are alternative functions like d2d_setstrokestylergba,  which calls the same underlying function as d2d_setstrokestyle, but takes in a color as a number rather than CSS style string.</p> <p>As noted above, putImageData requires that the image data be valid until flush is called.</p> <p>Other functions that take a string, like d2d_filltext,  don't have this same issue because they make a copy of the string argument.  These string copies will be automatically freed.</p> <p>getCanvasPropDouble, getCanvasPropString, setCanvasPropDouble, and setCanvasPropString allow you to change canvas properties by name. If the previous values type is either undefined, a string rather than a number, etc. then it will throw an error so ensure that you have your property names correct.</p> <p>d2d_load_image is not called like other instructions which rely on d2d_start_draw_sequence. This means it always gets called immediately and doesn't queue up in or flush the instruction queue. This can cause some issues such as the example below. Load Image Pitfall<pre><code>#include \"twr-draw2d.h\"\nbool has_background = false;\nconst long BACKGROUND_ID = 1;\n//draws the background\nvoid draw_background(struct d2d_draw_seq* ds) {\n   assert(has_background);\n   d2d_drawimage(ds, BACKGROUND_ID, x, y);\n}\n//loads a new background image\nvoid load_background_image(struct d2d_draw_seq* ds, const char * url) {\n   if (has_background) {\n      //free previous background\n      //this isn't called until the buffer in ds get's flushed.\n      // For this program, that doesn't happen until d2d_end_draw_sequence is called,\n      // so d2d_load_image processes before d2d_releasid throws a warning and then is deleted when d2d_releaseid\n      // is eventually called.\n      d2d_releaseid(ds, BACKGROUND_ID);\n      //d2d_flush(ds) //by adding a flush like so, it ensures releaseid is called before d2d_load_image\n   } else {\n      has_background = true;\n   }\n   d2d_load_image(url, BACKGROUND_ID);\n}\nvoid render() {\n   struct d2d_draw_seq* ds=d2d_start_draw_sequence(100);\n\n   //load background\n   load_background_image(ds, \"example_image.com\");\n\n   draw_background(ds); //draw it\n\n   d2d_end_draw_sequence(ds);\n\n\n   struct d2d_draw_seq* ds=d2d_start_draw_sequence(100);\n\n   //load new background image\n   load_background_image(ds, \"example_image2.com\");\n   draw_background(ds);\n\n   d2d_end_draw_sequence(ds);\n}\n</code></pre></p>"},{"location":"api/api-c-d2d/#functions","title":"Functions","text":"<p>These are the Canvas APIs currently available in C:</p> <pre><code>struct d2d_draw_seq* d2d_start_draw_sequence(int flush_at_ins_count);\nstruct d2d_draw_seq* d2d_start_draw_sequence_with_con(int flush_at_ins_count, twr_ioconsole_t * con);\nvoid d2d_end_draw_sequence(struct d2d_draw_seq* ds);\nvoid d2d_flush(struct d2d_draw_seq* ds);\nint d2d_get_canvas_prop(const char* prop);\n\nvoid d2d_fillrect(struct d2d_draw_seq* ds, double x, double y, double w, double h);\nvoid d2d_strokerect(struct d2d_draw_seq* ds, double x, double y, double w, double h);\nvoid d2d_filltext(struct d2d_draw_seq* ds, const char* str, double x, double y);\nvoid d2d_fillcodepoint(struct d2d_draw_seq* ds, unsigned long c, double x, double y);\nvoid d2d_stroketext(struct d2d_draw_seq* ds, const char* text, double x, double y);\n\nvoid d2d_measuretext(struct d2d_draw_seq* ds, const char* str, struct d2d_text_metrics *tm);\nvoid d2d_save(struct d2d_draw_seq* ds);\nvoid d2d_restore(struct d2d_draw_seq* ds);\n\nvoid d2d_setlinewidth(struct d2d_draw_seq* ds, double width);\nvoid d2d_setstrokestylergba(struct d2d_draw_seq* ds, unsigned long color);\nvoid d2d_setfillstylergba(struct d2d_draw_seq* ds, unsigned long color);\nvoid d2d_setstrokestyle(struct d2d_draw_seq* ds, const char* css_color);\nvoid d2d_setfillstyle(struct d2d_draw_seq* ds, const char* css_color);\nvoid d2d_setfont(struct d2d_draw_seq* ds, const char* font);\nvoid d2d_setlinecap(struct d2d_draw_seq* ds, const char* line_cap);\nvoid d2d_setlinejoin(struct d2d_draw_seq* ds, const char* line_join);\nvoid d2d_setlinedash(struct d2d_draw_seq* ds, unsigned long len, const double* segments);\nunsigned long d2d_getlinedash(struct d2d_draw_seq* ds, unsigned long length, double* buffer);\nunsigned long d2d_getlinedashlength(struct d2d_draw_seq* ds);\nvoid d2d_setlinedashoffset(struct d2d_draw_seq* ds, double line_dash_offset);\n\nvoid d2d_createlineargradient(struct d2d_draw_seq* ds, long id, double x0, double y0, double x1, double y1);\nvoid d2d_createradialgradient(struct d2d_draw_seq* ds, long id, double x0, double y0, double radius0, double x1, double y1, double radius1);\nvoid d2d_addcolorstop(struct d2d_draw_seq* ds, long gradID, long position, const char* csscolor);\nvoid d2d_setfillstylegradient(struct d2d_draw_seq* ds, long gradID);\nvoid d2d_releaseid(struct d2d_draw_seq* ds, long id);\n\nvoid d2d_beginpath(struct d2d_draw_seq* ds);\nvoid d2d_fill(struct d2d_draw_seq* ds);\nvoid d2d_stroke(struct d2d_draw_seq* ds);\nvoid d2d_moveto(struct d2d_draw_seq* ds, double x, double y);\nvoid d2d_lineto(struct d2d_draw_seq* ds, double x, double y);\nvoid d2d_arc(struct d2d_draw_seq* ds, double x, double y, double radius, double start_angle, double end_angle, bool counterclockwise);\nvoid d2d_arcto(struct d2d_draw_seq* ds, double x1, double y1, double x2, double y2, double radius);\nvoid d2d_bezierto(struct d2d_draw_seq* ds, double cp1x, double cp1y, double cp2x, double cp2y, double x, double y);\nvoid d2d_roundrect(struct d2d_draw_seq* ds, double x, double y, double width, double height, double radii);\nvoid d2d_ellipse(struct d2d_draw_seq* ds, double x, double y, double radiusX, double radiusY, double rotation, double startAngle, double endAngle, bool counterclockwise);\nvoid d2d_quadraticcurveto(struct d2d_draw_seq* ds, double cpx, double cpy, double x, double y);\nvoid d2d_rect(struct d2d_draw_seq* ds, double x, double y, double width, double height);\nvoid d2d_closepath(struct d2d_draw_seq* ds);\n\n//deprecated, use d2d_ctoimagedata instead\nvoid d2d_imagedata(struct d2d_draw_seq* ds, long id, void*  mem, unsigned long length, unsigned long width, unsigned long height);\n\nvoid d2d_ctoimagedata(struct d2d_draw_seq* ds, long id, void* mem, unsigned long length, unsigned long width, unsigned long height);\nvoid d2d_putimagedata(struct d2d_draw_seq* ds, long id, unsigned long dx, unsigned long dy);\nvoid d2d_putimagedatadirty(struct d2d_draw_seq* ds, long id, unsigned long dx, unsigned long dy, unsigned long dirtyX, unsigned long dirtyY, unsigned long dirtyWidth, unsigned long dirtyHeight);\n\nvoid d2d_reset(struct d2d_draw_seq* ds);\nvoid d2d_clearrect(struct d2d_draw_seq* ds, double x, double y, double w, double h);\nvoid d2d_scale(struct d2d_draw_seq* ds, double x, double y);\nvoid d2d_translate(struct d2d_draw_seq* ds, double x, double y);\nvoid d2d_rotate(struct d2d_draw_seq* ds, double angle);\nvoid d2d_gettransform(struct d2d_draw_seq* ds, struct d2d_2d_matrix *transform);\nvoid d2d_settransform(struct d2d_draw_seq* ds, double a, double b, double c, double d, double e, double f);\nvoid d2d_settransformmatrix(struct d2d_draw_seq* ds, const struct d2d_2d_matrix * transform);\nvoid d2d_transform(struct d2d_draw_seq* ds, double a, double b, double c, double d, double e, double f);\nvoid d2d_transformmatrix(struct d2d_draw_seq* ds, const struct d2d_2d_matrix * transform);\nvoid d2d_resettransform(struct d2d_draw_seq* ds);\n\nbool d2d_load_image(const char* url, long id);\nbool d2d_load_image_with_con(const char* url, long id, twr_ioconsole_t * con);\nvoid d2d_drawimage(struct d2d_draw_seq* ds, long id, double dx, double dy);\nvoid d2d_drawimage_ex(struct d2d_draw_seq* ds, long id, double sx, double sy, double sWidth, double sHeight, double dx, double dy, double dWidth, double dHeight);\nvoid d2d_getimagedata(struct d2d_draw_seq* ds, long id, double x, double y, double width, double height);\nunsigned long d2d_getimagedatasize(double width, double height);\nvoid d2d_imagedatatoc(struct d2d_draw_seq* ds, long id, void* buffer, unsigned long buffer_len);\n\ndouble d2d_getcanvaspropdouble(struct d2d_draw_seq* ds, const char* prop_name);\nvoid d2d_getcanvaspropstring(struct d2d_draw_seq* ds, const char* prop_name, char* buffer, unsigned long buffer_len);\nvoid d2d_setcanvaspropdouble(struct d2d_draw_seq* ds, const char* prop_name, double val);\nvoid d2d_setcanvaspropstring(struct d2d_draw_seq* ds, const char* prop_name, const char* val);\n</code></pre> <p>d2d_measuretext() returns this structure:</p> <pre><code>struct d2d_text_metrics {\n    double actualBoundingBoxAscent;\n    double actualBoundingBoxDescent;\n    double actualBoundingBoxLeft;\n    double actualBoundingBoxRight;\n    double fontBoundingBoxAscent;\n    double fontBoundingBoxDescent;\n    double width;\n};\n</code></pre> <p>d2d_get_canvas_prop() returns a value of:</p> <pre><code>export interface ICanvasProps {\n   charWidth: number,\n   charHeight: number,\n   foreColor: number,\n   backColor: number,\n   widthInChars: number,\n   heightInChars: number,\n   canvasWidth:number,\n   canvasHeight:number\n}\n</code></pre> <p>d2d_gettransform() returns this structure: <pre><code>struct d2d_2d_matrix {\n   double a, b, c, d, e, f;\n};\n</code></pre></p> <p>d2d_getlinedash() returns this structure: <pre><code>struct d2d_line_segments {\n    long len;\n    double *segments;\n};\n</code></pre></p>"},{"location":"api/api-c-general/","title":"General C API for Wasm","text":""},{"location":"api/api-c-general/#overview","title":"Overview","text":"<p>This sections describes the \"general\" twr-wasm functions available that don't fit neatly into another category (such as standard C library functions, Draw 2D functions, etc.) </p> <p>These functions often start with \"twr_\" and are generally found in this include file:</p> <p><code>\\twr-wasm\\include\\twr-crt.h</code></p>"},{"location":"api/api-c-general/#bzero","title":"bzero","text":"<p>Set a block of memory to zeros.  Calls <code>memset(to, 0, count)</code>.</p> <pre><code>#include &lt;string.h&gt;\n\nvoid bzero (void *to, size_t count);\n</code></pre>"},{"location":"api/api-c-general/#getc","title":"getc","text":"<p>This is the standard c library function (see the the standard library docs available on the internet). </p> <p>Of note this function will return extended ASCII (128-255 inclusive).  The extend ASCII are always encoded with Windows-1252 encoding.  </p> <p>See <code>twr_getc32</code> for  a list of related functions.</p> <p>Note that C character input is blocking and you must use twrWasmModuleAsync -- see stdin for details on how to enable blocking character input.</p>"},{"location":"api/api-c-general/#twr_atod","title":"twr_atod","text":"<p>Similar to stdlib <code>atof</code>.</p> <pre><code>#include \"twr-crt.h\"\n\ndouble twr_atod(const char* str);\n</code></pre>"},{"location":"api/api-c-general/#twr_atou64","title":"twr_atou64","text":"<p>Convert a string to a 64 bit unsigned integer, stopping when the first non-valid character is encountered.  If len is provided, it will be set to the number of characters read.  Radix should be &gt;=2 and &lt;=36 -- for example, 10 is a normal base 10 number and 16 is hexadecimal.</p> <pre><code>#include \"twr-crt.h\"\n\nint64_t twr_atou64(const char *str, int* len, int radix);\n</code></pre>"},{"location":"api/api-c-general/#twr_dtoa","title":"twr_dtoa","text":"<p>The functions to convert double to text are <code>snprintf</code>, <code>fcvt_s</code>,<code>twr_dtoa</code>, <code>twr_toexponential</code>, and <code>twr_tofixed</code></p> <pre><code>#include \"twr-crt.h\"\n\nvoid twr_dtoa(char* buffer, int sizeInBytes, double value, int max_precision);\n</code></pre>"},{"location":"api/api-c-general/#twr_cache_mallocfree","title":"twr_cache_malloc/free","text":"<p>These functions keep allocated memory in a cache for much faster re-access than the standard malloc/free.</p> <pre><code>#include \"twr-crt.h\"\n\nvoid *twr_cache_malloc(twr_size_t size);\nvoid twr_cache_free(void* mem);\n</code></pre>"},{"location":"api/api-c-general/#twr_code_page_to_utf32_streamed","title":"twr_code_page_to_utf32_streamed","text":"<p>Return a unicode code point (aka utf-32 value) when passed a byte stream that represents an encoded character using the current local's LC_CTYPE code page. A zero is returned if the byte stream has not yet completed a decode.  </p> <p>For example:</p> <pre><code>int cp\n\nsetlocale(LC_ALL, \"\");  // set to default locale, which will be UTF-8 encoding with local language/region\n\n// turn a UTF-8 Euro into a UTF-32 value\ncp==twr_code_page_to_utf32_streamed(0xE2);\nassert (cp==0);\ncp=twr_code_page_to_utf32_streamed(0x82);\nassert (cp==0);\ncp=twr_code_page_to_utf32_streamed(0xAC);\nassert (cp==0x000020AC);   // Euro Code points\n</code></pre> <pre><code>#include &lt;locale.h&gt;\n\nint twr_code_page_to_utf32_streamed(unsigned char byte) \n</code></pre>"},{"location":"api/api-c-general/#twr_conlog","title":"twr_conlog","text":"<p><code>twr_conlog</code> prints debug messages to <code>stderr</code> (usually your browser console) from your C code. <pre><code>#include \"twr-crt.h\"\n\nvoid twr_conlog(char* format, ...);\n</code></pre> This call is identical to <code>fprintf(stderr, ...)</code>, except that it adds a newline.</p> <p>When <code>stderr</code> is set to <code>twrConsoleDebug</code> each call to twr_conlog() will generate a single call to console.log() in JavaScript to ensure that you see debug prints.  </p> <p>The current implementation does not wait for the debug string to output to the console before returning from twr_conlog, when using twrWasmModuleAsync.  In this case, it can take a small bit of time for the string to make its way across the Worker Thread boundary.  This is normally not a problem and results in faster performance.  But if your code crashes soon after the debug print, the print might not appear.  If you think this is an issue, you can call <code>twr_sleep(1)</code> after your twr_conlog call.  This will force a blocking wait for the print to print.</p>"},{"location":"api/api-c-general/#twr_epoch_timems","title":"twr_epoch_timems","text":"<p>Returns the number of milliseconds since the start of the epoch. <pre><code>#include \"twr-crt.h\"\n\nuint64_t twr_epoch_timems();\n</code></pre></p>"},{"location":"api/api-c-general/#twr_getc32","title":"twr_getc32","text":"<p>Gets a 32 bit unicode code point character from stdin. Unlike the standard C library function <code>getchar</code>, <code>twr_getc32</code> does not buffer a line (that is, <code>twr_getc32</code> will return a character before the user presses Enter).</p> <p><code>twr_getc32</code> is implemented as: <pre><code>int twr_getc32() {\n    return io_getc32(twr_get_stdio_con());\n}\n</code></pre></p> <p>Note that stdlib <code>getchar</code> and <code>ungetc</code> are not currently implemented. </p> <p>Note that C character input with these functions is blocking and you must use twrWasmModuleAsync -- see stdin for details on how to enable blocking character input.</p> <p>Also see:</p> <ul> <li><code>io_mbgets</code> - get a multibyte string from a console using the current locale character encoding.   Console must support IO_TYPE_CHARREAD.</li> <li><code>twr_mbgets</code> - the same as <code>io_mbgets</code> with the console set to <code>stdin</code>.</li> <li><code>io_mbgetc</code> - get a multibyte character from an IoConsole (like <code>stdin</code>) using the current locale character encoding</li> <li><code>getc</code> (sames as <code>fgetc</code>) - get a single byte from a FILE * (IoConsole) -- returning ASCII or extended ASCII (window-1252 encoding)</li> <li><code>io_getc32</code> - gets a 32 bit unicode code point from an IoConsole (which must support IO_TYPE_CHARREAD)</li> </ul> <pre><code>#include \"twr-crt.h\"\n\nint twr_getc32();\n</code></pre>"},{"location":"api/api-c-general/#twr_get_navlang","title":"twr_get_navlang","text":"<p>Returns the BCP 47 language tag as found in javacript <code>navigator.language</code>.  If len is not null, it will be filled in with the string length of the language tag.</p> <pre><code>#include \"twr-crt.h\"\n\nconst char* twr_get_navlang(int *len);\n</code></pre>"},{"location":"api/api-c-general/#twr_get_current_locale","title":"twr_get_current_locale","text":"<pre><code>extern inline locale_t twr_get_current_locale(void);\n</code></pre> <p><code>twr_get_current_locale</code> will return the locale that has been set by <code>setlocale</code>.  It can be used to pass to a function that takes a locale_t.</p>"},{"location":"api/api-c-general/#twr_localize_numeric_string","title":"twr_localize_numeric_string","text":"<p>Functions like <code>twr_dtoa</code> do not localize the decimal point.  To get a localized decimal point, you can use <code>printf</code>,  or alternately <code>twr_localize_numeric_string</code> to post process a string.   For example:</p> <pre><code>char b[10];\nstrcpy(b, \"1.23\");\ntwr_localize_numeric_string(b, twr_get_current_locale());\n// if locale was set to french, then b is now 1,23\n</code></pre> <pre><code>#include &lt;locale.h&gt;\n\nvoid twr_localize_numeric_string(char* str, locale_t locale);\n</code></pre>"},{"location":"api/api-c-general/#twr_mem_debug_stats","title":"twr_mem_debug_stats","text":"<p>Print memory map and malloc stats to stderr or stdout.</p> <p>(note FILE * is the same as twr_ioconsole_t*)</p> <pre><code>#include &lt;stdio.h&gt;\n\nvoid twr_mem_debug_stats(twr_ioconsole_t* outcon);\n</code></pre>"},{"location":"api/api-c-general/#twr_mbgets","title":"twr_mbgets","text":"<p>Gets a string from stdin. The string will be in the current locale's character encoding -- ASCII for \"C\", and either UTF-8 or windows-1252 for \"\".  See Character Encoding Support with twr-wasm.</p> <pre><code>#include \"twr-crt.h\"\n\nchar* twr_mbgets(char* buffer);\n</code></pre> <p>Internally this function uses the stdio IoConsole -- see the IoConsole section for more advanced input/output.</p> <p>This function will encode characters as specified by the LC_CTYPE category of the current locale.  ASCII is used for \"C\", and UTF-8 and Windows-1252 are also supported (see  localization)</p> <p>Note that C character input is blocking and you must use twrWasmModuleAsync -- see stdin for details on how to enable blocking character input.</p>"},{"location":"api/api-c-general/#twr_mbslen_l","title":"twr_mbslen_l","text":"<p>Returns the number of characters in a string using the character encoding of the passed locale (ASCII for \"C\", UTF-8, or windows-1252 for \"\").  You can use <code>twr_get_current_locale</code> to find the current locale. <pre><code>#include &lt;string.h&gt;\n\nsize_t twr_mbslen_l(const char *str, locale_t locale);\n</code></pre></p>"},{"location":"api/api-c-general/#twr_sleep","title":"twr_sleep","text":"<p><code>twr_sleep</code> is a traditional blocking sleep function.   This function is blocking, and so is only available if you use <code>twrWasmModuleAsync</code>.</p> <pre><code>#include \"twr-crt.h\"\n\nvoid twr_sleep(int ms);\n</code></pre>"},{"location":"api/api-c-general/#twr_register_callback","title":"twr_register_callback","text":"<p>Returns a new event ID that is paired with the specified C function.  This event ID can be passed to functions that accept an event ID.  When the event is triggered, the specified callback is called. </p> <p>The callback function's first argument will be the event ID.  Subsequent arguments are event specific.  It is legal to register the same callback for multiple event IDs.</p> <pre><code>#include \"twr-crt.h\"\n\nint twr_register_callback(const char* func_name);\n</code></pre> <p>For example: <pre><code>// timer event callback (called once)\n__attribute__((export_name(\"on_timer1\")))\nvoid on_timer1(int event_id) {\n   printf(\"timer callback 1 entered (event id=%d) !\\n\", event_id);\n}\n\n// entry point\n__attribute__((export_name(\"twr_main\")))\nvoid twr_main() {\n   int timer1=twr_register_callback(\"on_timer1\");\n   twr_timer_single_shot(2000, timer1);\n}\n</code></pre></p>"},{"location":"api/api-c-general/#twr_timer_single_shot","title":"twr_timer_single_shot","text":"<p>Triggers the specified event (callback) once after <code>milliSeconds</code>.  Returns a <code>timerID</code> which can be used with <code>twr_timer_cancel</code>.</p> <pre><code>int twr_timer_single_shot(int milliSeconds, int eventID);\n</code></pre>"},{"location":"api/api-c-general/#twr_timer_repeat","title":"twr_timer_repeat","text":"<p>Triggers the specified event (callback) repeatedly after <code>milliSeconds</code>.  Returns a <code>timerID</code> which can be used with <code>twr_timer_cancel</code>.</p> <pre><code>int twr_timer_repeat(int milliSeconds, int eventID);\n</code></pre>"},{"location":"api/api-c-general/#twr_timer_cancel","title":"twr_timer_cancel","text":"<p>Cancels the specfied timer.</p> <pre><code>void twr_timer_cancel(int timerID);\n</code></pre>"},{"location":"api/api-c-general/#twr_tofixed","title":"twr_tofixed","text":"<p>This function is identical to its JavaScript version. <pre><code>#include \"twr-crt.h\"\n\nvoid twr_tofixed(char* buffer, int buffer_size, double value, int dec_digits);\n</code></pre></p> <p>The functions to convert double to text are <code>snprintf</code>, <code>fcvt_s</code>,<code>twr_dtoa</code>, <code>twr_toexponential</code>, and <code>twr_tofixed</code></p>"},{"location":"api/api-c-general/#twr_toexponential","title":"twr_toexponential","text":"<p>This function is identical to its JavaScript version.</p> <pre><code>#include \"twr-crt.h\"\n\nvoid twr_toexponential(char* buffer, int buffer_size, double value, int dec_digits);\n</code></pre> <p>The functions to convert double to text are <code>snprintf</code>, <code>fcvt_s</code>,<code>twr_dtoa</code>, <code>twr_toexponential</code>, and <code>twr_tofixed</code></p>"},{"location":"api/api-c-general/#twr_strhorizflip","title":"twr_strhorizflip","text":"<p>Mirror image the passed in string. <pre><code>#include \"twr-crt.h\"\n\nvoid twr_strhorizflip(char * buffer, int n);\n</code></pre></p>"},{"location":"api/api-c-general/#twr_utf8_char_len","title":"twr_utf8_char_len","text":"<p>Returns the number of bytes in a UTF-8 character (passed as a string pointer).  UTF-8 characters can be 1 to 4 bytes in length. <pre><code>#include &lt;string.h&gt;\n\nint twr_utf8_char_len(const char *str);\n</code></pre></p>"},{"location":"api/api-c-general/#twr_utf32_to_code_page","title":"twr_utf32_to_code_page","text":"<p>Takes a utf32 value (aka unicode code point value), and fills in the passed character array buffer with the character encoding of the utf32 value, using the current locale's LC_CTYPE code page. The buffer is 0 terminated.</p> <p>Also see <code>c32rtomb</code> and <code>c16rtomb</code>.</p> <p>For example: <pre><code>char strbuf[6];             // max size of utf-8 is 4+terminating zero.  Max size of ASCII or windows 1252 is 1 + terminating zero\nsetlocale(LC_ALL, \"\");  // set to default locale, which will be UTF-8 encoding with local language/region\ntwr_utf32_to_code_page(strbuf, 0x000020AC);  // encode a Euro code point \nprintf(\"%s\", strbuf); \nassert ( strcmp(strbuf,\"\\xE2\\x82\\xAC\")==0 );  // utf-8 encoding of euro\nassert ( strcmp(strbuf,\"\u20ac\")==0 );           // clang string literals default to utf-8 encoding\n</code></pre></p> <pre><code>include &lt;locale.h&gt;\n\nvoid twr_utf32_to_code_page(char* out, int utf32)\n</code></pre>"},{"location":"api/api-c-general/#twr_vprintf","title":"twr_vprintf","text":"<p>Performs a printf by calling the callback with cbdata for each character. <pre><code>#include \"twr-crt.h\"\n\nvoid twr_vprintf(twr_cbprintf_callback out, void* cbdata, const char *format, va_list* args);\n</code></pre></p>"},{"location":"api/api-c-general/#floating-math-helpers","title":"floating math helpers","text":"<pre><code>int twr_isnan(double v);\nint twr_isinf(double v);\ndouble twr_nanval();\ndouble twr_infval();\n</code></pre>"},{"location":"api/api-c-localization/","title":"Localization Reference for twr-wasm","text":"<p>This section details twr-wasm's WebAssembly localization support.</p> <p>Also see Introduction to Character Encoding Support with twr-wasm</p>"},{"location":"api/api-c-localization/#using-c","title":"Using C:","text":"<p>Standard C locale functions are supported by twr-wasm.  ASCII, UTF-8 and windows-1252 encoding is supported by the twr-wasm standard C library locale.  twr-wasm also includes C functions for UTF-32 support.</p>"},{"location":"api/api-c-localization/#using-c_1","title":"Using C++:","text":"<ul> <li>libc++ locale and unicode functions are supported by twr-wasm.</li> <li>libc++ unicode support includes utf-16 and utf-32 strings.</li> </ul>"},{"location":"api/api-c-localization/#character-encodings","title":"Character Encodings","text":"<p>twr-wasm C locales support ASCII, UTF-8 or windows-1252 encoding.  UTF-16/32 are not supported as a std c lib locale setting, but functions are provided to convert utf-32 (unicode code points) to and from ASCII, UTF-8, and windows-1252 \"code pages\" (there are other miscellaneous utf-32 based functions as well.)</p>"},{"location":"api/api-c-localization/#locales-standard-c-library","title":"Locales (Standard C Library)","text":""},{"location":"api/api-c-localization/#c","title":"\"C\"","text":"<p>\"C\" is the default locale, as usual.  When \"C\" is selected, the functions operate as usual. One subtly is that console i/o functions (such as <code>printf</code>) will generally function as expected with UTF-8, since the <code>div</code> and <code>window</code> consoles correctly handle UTF-8 character encoding.  This is normal on some OSs, such as linux, but not the default on Windows (which often defaults to windows-1252 for backward compatibility).</p> <p><code>isgraph</code> style functions will only recognize ASCII characters, as is normal.   Functions such as <code>strcmp</code> operate on the byte sequence, which will typically results in UTF-8 codes being compared lexically. <code>strcoll</code> will use lexical ordering.</p>"},{"location":"api/api-c-localization/#posix","title":"\"POSIX\"","text":"<p>\"POSIX\" is the same as \"C\"</p>"},{"location":"api/api-c-localization/#_1","title":"\"\"","text":"<p>\"\" is the locale to specify the users default setting (this selects the setting used by the browser).  This will also enable UTF-8 in functions such as <code>strcoll</code>.  For example, if your browser is set to \"en-US\" as its default locale, <code>setlocale(LC_ALL, \"\")</code> will return <code>en-US.UTF-8</code>.  </p> <p><code>isgraph</code> style functions will still only recognize ASCII characters (since UTF-8 doesn't encode any single bytes greater than 127).  <code>strcoll</code>  uses locale specific ordering, and <code>printf</code> will use locale specific decimal points.  <code>strcmp</code> still compares two strings lexicographically (byte-by-byte) without considering locale-specific rules, per the spec. </p>"},{"location":"api/api-c-localization/#utf-8","title":"\".UTF-8\"","text":"<p>\".UTF-8\" is the same as \"\" with twr-wasm.</p>"},{"location":"api/api-c-localization/#1252","title":"\".1252\"","text":"<p>\".1252\" will select the current default locale, but use windows-1252 character encoding (instead of UTF-8). Windows-1252 is a super set of ISO-8859-1 and is the most commonly used encoding for many european languages when unicode is not used.  This mode is primarily for legacy software, backwards compatibly, and windows compatibility.   </p>"},{"location":"api/api-c-localization/#others","title":"Others","text":"<p>Setting arbitrary locales, such as \"fr-FR\" when the browser is defaulted to another locale, is not supported.  </p>"},{"location":"api/api-c-localization/#select-the-default-locale","title":"Select the default locale","text":"<p>To select the user's browser's default locale using the C language, and enable consistent utf-8 support, use a call like this:</p> <pre><code>setlocale(LC_ALL, \"\")\n</code></pre>"},{"location":"api/api-c-localization/#c-and-libc-functions","title":"C and libc++ functions","text":"<p>If you are using twr-wasm's build of libc++, libc++ locale and unicode functions work as normal.</p> <p>The usual standard C library locale support is available, along with some POSIX extensions.   In addition, some locale useful twr-wasm specific functions are documented in C API, such as <code>twr_get_current_locale</code>,<code>twr_mbgets</code>, <code>twr_getc32</code>, <code>twr_utf8_char_len</code>, <code>twr_mbslen_l</code>, <code>twr_utf32_to_code_page</code>, <code>twr_code_page_to_utf32_streamed</code>, <code>twr_get_navlang</code>, <code>twr_localize_numeric_string</code>.</p> <p>Note that <code>io_getc32</code>, <code>getc(stdin)</code>, <code>fgetc(stdin)</code> do not look at the current locale.  <code>io_getc32</code> returns a 32 bit unicode code point, and <code>getc</code>/<code>fgetc</code> return extended ASCII. </p> <p>For a locale aware character input, use <code>io_mbgetc()</code> or <code>twr_mbgets()</code>. Both use the locale category LC_CTYPE.  See C API.</p> <p>Note that when the locale is not set (or whenever the \"C\" locale is set) functions that get character(s) from stdin that are locale aware, like <code>twr_mbgets()</code>, behave different than functions that output characters to stdout (like  <code>puts</code>, <code>io_putstr</code>, <code>io_putc</code>, <code>putchar</code>).  Characters to stdout in \"C\" locale will handle UTF-8 characters.  For stdin, \"C\" locale uses ASCII.</p> <p>For consistent UTF-8 (or windows-1252) behavior, set the locale as discussed above ( use <code>setlocale</code> )</p> <p>The primary standard C library locale functions are: <pre><code>char* setlocale(int category, const char* locale);\nstruct lconv *localeconv(void);\n</code></pre></p> <p>As well as the two standard library functions above, appropriate functions take into account the current locale (printf, strcoll, etc).</p> <p>Note that <code>setlocale</code> returns a string using BCP 47 format (like a web browser).  Locale strings look like \"en-US.UTF-8\", instead of \"en_US.UTF-8\". A dash, not an underscore, is used as a separator.</p> <p>POSIX functions These are the extended POSIX style functions provided that are related to locale:</p> <pre><code>locale_t newlocale(int category_mask, const char *locale, locale_t base);\nlocale_t uselocale(locale_t);\nvoid freelocale(locale_t);\nlocale_t duplocale(locale_t);\n\nint isalnum_l(int c, locale_t loc);\nint isalpha_l(int c, locale_t loc);\nint isblank_l(int c, locale_t loc);\nint iscntrl_l(int c, locale_t loc);\nint isdigit_l(int c, locale_t loc);\nint isgraph_l(int c, locale_t loc);\nint islower_l(int c, locale_t loc);\nint isprint_l(int c, locale_t loc);\nint ispunct_l(int c, locale_t loc);\nint isspace_l(int c, locale_t loc);\nint isupper_l(int c, locale_t loc);\nint isxdigit_l(int c, locale_t loc);\nint tolower_l(int c, locale_t loc);\nint toupper_l(int c, locale_t loc);\n\nlong long strtoll_l(const char *str, char **str_end, int base,  locale_t loc);\nunsigned long long strtoull_l(const char *str, char **str_end,  int base, locale_t loc);\nfloat strtof_l(const char *str, char ** str_end, locale_t locale);\ndouble strtod_l(const char *str, char **str_end, locale_t locale);\nlong double strtold_l(const char *str, char **str_end, locale_t locale);\n\nint strcoll_l(const char* lhs, const char* rhs,  locale_t loc);\n\nsize_t strftime_l(char *s, size_t maxsize, const char *format, const struct tm *timeptr, locale_t locale);\n</code></pre>"},{"location":"api/api-c-stdlib/","title":"Standard C library for WebAssembly","text":"<p>This section describes twr-wasm's support for the Standard C Library.   twr-wasm includes its own implementation of the standard C library optimized for WebAssembly and Wasm running in a web browser.  This is a core feature of twr-wasm.</p> <p>For documentation of these functions, see the many standard C library documentation web sites.</p> <p>The following subset of the standard C library is available. Also see <code>twr-wasm/include</code> folder for include files.</p>"},{"location":"api/api-c-stdlib/#stdioh","title":"stdio.h","text":"<pre><code>* fprintf will only work with these -- stderr, stdin, stdout */\n/* these return 'twr_ioconsole_t *' which is same as 'FILE *' */\n#define stderr (FILE *)(twr_get_stderr_con())\n#define stdin (FILE *)(twr_get_stdio_con())\n#define stdout (FILE *)(twr_get_stdio_con())\n\nint snprintf(char *buffer, size_t bufsz, const char *format, ... );\nint sprintf( char *buffer, const char *format, ... );\nint vsnprintf(char *buffer, size_t bufsz, const char *format, va_list vlist);\nint vasprintf(char **strp, const char* format, va_list vlist );\nint printf(const char* format, ...);\nint vprintf(const char* format, va_list vlist );\nint puts(const char *str);\nint putchar(int c);\n\ntypedef twr_ioconsole_t FILE; \nint vfprintf(FILE *stream, const char *format, va_list vlist);\nint fprintf(FILE *stream, const char* format, ...);\nsize_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);\nint ferror(FILE *stream);\nint feof(FILE *stream);\nint fflush(FILE *stream);\nint is_terminal(FILE *stream);\nint fputc(int ch, FILE* stream);\nint putc(int ch, FILE* stream);\nint fgetc(FILE *stream );\nint getc(FILE *stream);\n</code></pre>"},{"location":"api/api-c-stdlib/#stdlibh","title":"stdlib.h","text":"<pre><code>void *malloc(size_t size);\nvoid free(void *mem);\nsize_t avail(void);\nvoid *realloc( void *ptr, size_t new_size );\nvoid* calloc( size_t num, size_t size );\nvoid *aligned_alloc( size_t alignment, size_t size );\n\nint rand(void);\nvoid srand(int seed);\n\n#define __min(a,b) (((a) &lt; (b)) ? (a) : (b))\n#define __max(a,b) (((a) &gt; (b)) ? (a) : (b))\n\nint abs(int n);\n\nint _fcvt_s(\n   char* buffer,\n   size_t sizeInBytes,\n   double value,\n   int fracpart_numdigits,\n   int *dec,\n   int *sign\n);\ndouble atof(const char* str);\nint atoi(const char *str);\nlong atol( const char *str );\nlong long atoll( const char *str );\nlong strtol(const char *str, char **str_end, int base);\nlong long strtoll(const char *str, char **str_end, int base);\nlong long strtoll_l(const char *str, char **str_end, int base,  locale_t loc);\nunsigned long long strtoull(const char *str, char **str_end,  int base);\nunsigned long long strtoull_l(const char *str, char **str_end,  int base, locale_t loc);\nunsigned long strtoul(const char *str, char ** str_end,  int base);\nfloat strtof(const char *str, char ** str_end);\nfloat strtof_l(const char *str, char ** str_end, locale_t locale);\ndouble strtod(const char *str, char **str_end);\ndouble strtod_l(const char *str, char **str_end, locale_t locale);\nlong double strtold(const char *str, char **str_end);\nlong double strtold_l(const char *str, char **str_end, locale_t locale);\nint _itoa_s(int64_t value, char * buffer, size_t size, int radix);\n\ndiv_t div( int x, int y );\nldiv_t ldiv( long x, long y );\nlldiv_t lldiv( long long x, long long y );\n\n_Noreturn void abort(void);\nint atexit(void (*func)(void));\n</code></pre> <p>Note that _fcvt_s as currently enabled has these limitations:    - fractional digits &lt;=100    - values must be less than 1e+21    - values negative exponents must be smaller than 1e-99</p> <p>There is a full featured version of _fcvt_s in the source code, but it is not currently enabled, since the version enabled is smaller and works in most use cases.</p>"},{"location":"api/api-c-stdlib/#asserth","title":"assert.h","text":"<pre><code>void assert(int expression);\n</code></pre>"},{"location":"api/api-c-stdlib/#mathh","title":"math.h","text":"<pre><code>double acos(double arg);\ndouble asin(double arg);\ndouble atan(double arg);\ndouble atan2(double y, double x);\ndouble ceil(double arg);\ndouble cos(double arg);\ndouble exp(double arg);\ndouble fabs(double arg);\ndouble floor(double arg);\ndouble fmod(double x, double y);\ndouble log(double arg);\ndouble pow(double base, double exp);\ndouble sin(double arg);\ndouble sqrt(double arg);\ndouble tan(double arg);\ndouble trunc(double arg);\n</code></pre>"},{"location":"api/api-c-stdlib/#stdargh","title":"stdarg.h","text":"<pre><code>#define va_start(v,l)   __builtin_va_start(v,l)\n#define va_end(v)   __builtin_va_end(v)\n#define va_arg(v,l) __builtin_va_arg(v,l)\n#define va_copy(d,s)    __builtin_va_copy(d,s)\ntypedef __builtin_va_list va_list;\n</code></pre>"},{"location":"api/api-c-stdlib/#ctypeh","title":"ctype.h","text":"<pre><code>int isascii(int);\nint toascii(int);\nint isalnum(int c);\nint isalpha(int c);\nint isblank(int);\nint iscntrl(int);\nint isdigit(int c);\nint isgraph(int c);\nint islower(int);\nint isprint(int);\nint ispunct(int);\nint isspace(int c);\nint isupper(int);\nint isxdigit(int);\nint tolower(int c);\nint toupper(int c);\n\nint isalnum_l(int c, locale_t loc);\nint isalpha_l(int c, locale_t loc);\nint isblank_l(int c, locale_t loc);\nint iscntrl_l(int c, locale_t loc);\nint isdigit_l(int c, locale_t loc);\nint isgraph_l(int c, locale_t loc);\nint islower_l(int c, locale_t loc);\nint isprint_l(int c, locale_t loc);\nint ispunct_l(int c, locale_t loc);\nint isspace_l(int c, locale_t loc);\nint isupper_l(int c, locale_t loc);\nint isxdigit_l(int c, locale_t loc);\nint tolower_l(int c, locale_t loc);\nint toupper_l(int c, locale_t loc);\n</code></pre>"},{"location":"api/api-c-stdlib/#stddefh","title":"stddef.h","text":"<pre><code>#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)\ntypedef __PTRDIFF_TYPE__ ptrdiff_t;\ntypedef double max_align_t;\n</code></pre>"},{"location":"api/api-c-stdlib/#stringh","title":"string.h","text":"<pre><code>size_t strlen(const char * str);\nchar *strdup(const char * source);\nchar *strcpy(char *dest, const char *source);\nint strcat_s(char *dest, size_t destsz, const char *src);\nchar* strcat(char *dest, const char *src);\nchar *strncpy(char *dest, const char *source, size_t count);\nint strcmp(const char* string1, const char* string2);\nint strncmp(const char* lhs, const char* rhs, size_t count);\nint stricmp(const char* string1, const char* string2);\nint strnicmp(const char* string1, const char* string2, size_t count);\nint strcoll(const char* lhs, const char* rhs);\nint strcoll_l(const char* lhs, const char* rhs,  locale_t loc);\nchar *strchr(const char *str, int ch);\nvoid *memchr(const void *ptr, int ch, size_t count);\nchar *strstr(const char *haystack, const char *needle);\nchar * strerror(int errnum );\nchar * _strerror(const char *strErrMsg);\nvoid *memmove(void *dest, const void *src, size_t n);\nint memcmp( const void* lhs, const void* rhs, size_t count );\nvoid bzero (void *to, size_t count);\n\n// implemented in memcpy.wat\nvoid *memcpy(void *dest, const void * src, size_t n);\nvoid *memset(void *mem, int c, size_t n);\n</code></pre>"},{"location":"api/api-c-stdlib/#timeh","title":"time.h","text":"<pre><code>typedef unsigned long time_t;\nunsigned long time(unsigned long *time);\nsize_t strftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr);\nsize_t strftime_l(char *s, size_t maxsize, const char *format, const struct tm *timeptr, locale_t  locale);\nstruct tm *localtime(const time_t *timer);\nint gettimeofday(struct timeval *tv, void* notused);\n#define timerisset(tvp)     ((tvp)-&gt;tv_sec || (tvp)-&gt;tv_usec)\n#define timercmp(tvp,uvp,cmp)                   \\\n        ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec ||     \\\n         ((tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec &amp;&amp; (tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec))\n#define timerclear(tvp)     (tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0\n</code></pre>"},{"location":"api/api-c-stdlib/#localeh","title":"locale.h","text":"<pre><code>#define LC_GLOBAL_LOCALE twr_get_current_locale()\nchar* setlocale(int category, const char* locale);\nstruct lconv *localeconv(void);\nlocale_t newlocale(int category_mask, const char *locale, locale_t base);\nlocale_t    uselocale(locale_t);\nvoid freelocale(locale_t);\nlocale_t duplocale(locale_t);\nextern inline locale_t twr_get_current_locale(void);\n</code></pre>"},{"location":"api/api-c-stdlib/#ucharh","title":"uchar.h","text":"<pre><code>typedef uint_least32_t char32_t;\ntypedef uint_least16_t char16_t;\n\nsize_t c32rtomb( char* s, char32_t c32, mbstate_t* ps );\n</code></pre>"},{"location":"api/api-c-stdlib/#errnoh","title":"errno.h","text":"<pre><code>typedef int errno_t;\n\nextern int * _errno(void);\n#define errno (*_errno())\n\nerrno_t  _set_errno(int _Value);\nerrno_t  _get_errno(int *_Value);\n</code></pre>"},{"location":"api/api-c-stdlib/#_stdtypesh","title":"_stdtypes.h","text":"<p>// don't include directly -- included by various .h files <pre><code>typedef unsigned long size_t;\n#define MAX_SIZE_T 2147483647  \n\n#ifdef __cplusplus\n#define NULL __null\n#else\n#define NULL ((void*)0)\n#endif\n\ntypedef struct __locale_t_struct * locale_t;\n</code></pre></p>"},{"location":"api/api-c-stdlib/#other-include-files-available","title":"Other include files available","text":"<pre><code>float.h\nlimits.h\nstdbool.h\nstdint.h\n</code></pre>"},{"location":"api/api-libcpp/","title":"libc++ for WebAssembly","text":"<p>This section describes twr-wasm's support for using the standard c++ library libc++ with WebAssembly.</p> <p>twr-wasm includes libc++ built for WebAssembly in the <code>twr-wasm/lib-c</code> folder.</p> <p>For C++ the use of libc++ is optional.  That is you can build twr-wasm projects in C++ with or without libc++.</p> <p>See the examples tests-libcx and tests-user for examples of using libc++.</p> <p>See the balls example for how to create a C++ WebAssembly program without the standard C++ library.  The primary advantage to this approach is a bit smaller code size.  You don't need to staticly link libc++.</p> <p>Some of the key options twr-wasm's libc++ for WebAssembly was built with are these:</p> <pre><code>DLIBCXX_ENABLE_LOCALIZATION=ON \nDLIBCXX_ENABLE_UNICODE=ON \nDLIBCXX_ENABLE_RTTI=ON \nDLIBCXX_ENABLE_STATIC_ABI_LIBRARY=ON \n\nDCMAKE_BUILD_TYPE=Release       \nDCMAKE_CXX_STANDARD=20 \n\nDLIBCXX_ENABLE_EXCEPTIONS=OFF \nDLIBCXX_ENABLE_THREADS=OFF \nDLIBCXX_ENABLE_SHARED=OFF \nDLIBCXX_ENABLE_WIDE_CHARACTERS=OFF \nDLIBCXX_ENABLE_FILESYSTEM=OFF \nDLIBCXX_ENABLE_TIME_ZONE_DATABASE=OFF \nDLIBCXX_ENABLE_MONOTONIC_CLOCK=OFF \nDLIBCXX_ENABLE_RANDOM_DEVICE=OFF\n</code></pre>"},{"location":"api/api-ts-consoles/","title":"Console Classes","text":"<p>This section describes the twr-wasm TypeScript/JavaScript classes that you use to create I/O Consoles for character streaming, a terminal, or 2D Canvas Drawing</p> <p>The classes <code>twrConsoleDiv</code>, <code>twrConsoleTerminal</code>, <code>twrConsoleDebug</code>, and <code>twrConsoleCanvas</code> create consoles that enable user i/o. Your C/C++ can direct user interactive i/o to these consoles.  </p>"},{"location":"api/api-ts-consoles/#related-console-documentation","title":"Related Console Documentation","text":"<ul> <li>Console Introduction</li> <li>Console C APIs</li> </ul>"},{"location":"api/api-ts-consoles/#class-twrconsoledebug","title":"class twrConsoleDebug","text":"<p><code>twrConsoleDebug</code> streamings characters to the browser debug console.  </p> <p>C type: <code>IO_TYPE_CHARWRITE</code></p> <p>There are no constructor parameters.</p>"},{"location":"api/api-ts-consoles/#class-twrconsolediv","title":"class twrConsoleDiv","text":"<p><code>twrConsoleDiv</code> streams character input and output to a div tag .</p> <p>C type:  <code>IO_TYPE_CHARREAD</code> and  <code>IO_TYPE_CHARWRITE</code></p> <p>The div tag will expand as you add more text (via printf, etc).</p> <p>You pass a <code>&lt;div&gt;</code> element to use to render the Console to to the <code>twrConsoleDiv</code> constructor.  For example: <pre><code>&lt;div id=\"div1\" tabindex=\"0\"&gt;&lt;/div&gt;\n\n&lt;script type=\"module\"&gt;\n   import {twrWasmModuleAsync, twrConsoleDiv} from \"twr-wasm\";\n\n   const stream1Element=document.getElementById(\"div1\");\n\n   // adding keyDown events is needed if the console will accept key input\n   // don't forget to set \"tabindex\" in your tag, otherwise it won't get key events\n   stream1Element.addEventListener(\"keydown\",(ev)=&gt;{stream1.keyDown(ev)});\n\n   const stream1 = new twrConsoleDiv(stream1Element);\n   const mod = new twrWasmModuleAsync( {stdio: stream1} );\n   // mod.callC would go here...\n&lt;/script&gt;\n</code></pre></p> <p>There are constructor options to set the color and font size. You can also set these directly in the HTML for your <code>&lt;div&gt;</code> tag. If you wish to change the default font, set the font in the <code>div</code> tag with the normal HTML tag options.</p> twrConsoleDiv constructor options<pre><code>constructor(element:HTMLDivElement,  params:IConsoleDivParams)\n\nexport interface IConsoleDivParams {\n   foreColor?: string,\n   backColor?: string,\n   fontSize?: number,\n}\n</code></pre> <p>You can use the <code>putStr</code> member function to print a string to the div console in JavaScript.</p>"},{"location":"api/api-ts-consoles/#class-twrconsoleterminal","title":"class twrConsoleTerminal","text":"<p><code>twrConsoleTerminal</code> provides streaming and addressable character input and output.  A <code>&lt;canvas&gt;</code> tag is used to render into.</p> <p>C types: <code>IO_TYPE_CHARREAD</code>, <code>IO_TYPE_CHARWRITE</code>, <code>IO_TYPE_ADDRESSABLE_DISPLAY</code></p> <p>twrConsoleTerminal is a simple windowed terminal and supports the same streamed output and input features as a does <code>twrConsoleDiv</code>, but also supports x,y coordinates, colors, and other features. The window console supports chunky (low res) graphics (each character cell can be used as a 2x3 graphic array). </p> <p>The canvas width and height, in pixels, will be set based on your selected font size and the width and height (in characters) of the terminal.  These are passed as constructor options when you instantiate the <code>twrConsoleTerminal</code>.</p> <p>You can use the <code>putStr</code> member function on twrConsoleTerminal to print a string to the terminal in JavaScript.</p> <p>As you add more text (via printf, etc), the <code>twrConsoleTerminal</code> will scroll if it becomes full (unlike <code>twrConsoleDiv</code>, which expands)</p> <p>A list of C functions that operate on <code>twrConsoleTerminal</code> are available.</p> <p>Here is an example: <pre><code>&lt;body&gt;\n\n   &lt;canvas id=\"canvas1forterm\" tabindex=\"0\"&gt;&lt;/canvas&gt;\n\n   &lt;script type=\"module\"&gt;\n      import {twrWasmModuleAsync, twrConsoleTerminal} from \"twr-wasm\";\n\n      // find the HTML elements that we will use for our console to render into\n      const term1Element=document.getElementById(\"canvas1forterm\");\n\n      // adding keyDown events is needed if the console will accept key input\n      // don't forget to set \"tabindex\" in your tag, otherwise it won't get key events\n      term1Element.addEventListener(\"keydown\",(ev)=&gt;{term1.keyDown(ev)});\n\n      // create the console\n      const term1 = new twrConsoleTerminal(term1Element, {widthInChars: 50, heightInChars: 20});\n\n      const amod = new twrWasmModuleAsync( \n         {io:{\n            stdio: debug, stderr: debug, stream1: stream1, stream2: stream2, term1: term1, term2: term2, draw1: draw1, draw2: draw2\n         }} );\n\n      // set the input focus so user doesn't have to click\n      stream1Element.focus();\n\n      // load the wasm code and call the multi C function\n      await amod.loadWasm(\"./multi-io.wasm\");\n      await amod.callC([\"multi\"]);\n\n      // example of using a console in in JavaScript\n      stream1.putStr(`Hello stream1 of type ${stream1.getProp(\"type\")} from JavaScript!\\n`);\n\n   &lt;/script&gt;\n&lt;/body&gt;\n</code></pre></p> twrConsoleTerminal constructor options<pre><code>constructor (canvasElement:HTMLCanvasElement, params:IConsoleTerminalParams)\n\n// see twrConsoleDiv options elsewhere, which are also supported\nexport interface IConsoleTerminalParams extends IConsoleDivParams {\n   widthInChars?: number,\n   heightInChars?: number,\n}\n</code></pre>"},{"location":"api/api-ts-consoles/#class-twrconsolecanvas","title":"class twrConsoleCanvas","text":"<p><code>twrConsoleCanvas</code> creates a 2D drawing surface that the Canvas compatible 2d drawing APIs can be used with. </p> <p>C type: <code>IO_TYPE_CANVAS2D</code>.</p> <pre><code>constructor(element:HTMLCanvasElement)\n</code></pre> twrConsoleCanvas Example<pre><code>&lt;body&gt;\n   canvas id=\"canvas1for2d\"&gt;&lt;/canvas&gt;\n\n   &lt;script type=\"module\"&gt;\n      import {twrWasmModule, twrConsoleCanvas} from \"twr-wasm\";\n\n      // find the HTML elements that we will \n      // use for our console to render into\n      const draw1Element=document.getElementById(\"canvas1for2d\");\n\n      // create the console\n      const draw1 = new twrConsoleCanvas(draw1Element);\n\n      const mod = new twrWasmModule( {io: {std2d: draw1}  }} );\n\n      // callC here...\n   &lt;/script&gt;\n</code></pre>"},{"location":"api/api-ts-library/","title":"twr-wasm Libraries","text":"<p>twr-wasm Libraries are used to expose TypeScript code to C/C++ as C APIs.  All of the twr-wasm C APIs are implemented with twr-wasm libraries.  You can also use a library to implement your own C APIs using TypeScript.</p> <p>There are two kinds of Libraries:</p> <ul> <li>Those that have only once instance (such as the math library)</li> <li>Those that can have multiple instances across one or more library types, where each library type implements the same interface.  Consoles are an example of this (see interfaceName).</li> </ul>"},{"location":"api/api-ts-library/#basic-steps","title":"Basic Steps","text":"<p>twr-wasm Libraries support both <code>twrWasmModule</code> and <code>twrWasmModuleAsync</code>.  That is, when you create a twrLibrary, it will function with either type of module.  In many cases no extra work is needed for the <code>twrWasmModuleAsync</code>, but in some cases, extra code is needed.</p> <p>The class <code>twrLibrary</code>  provides the core functionality:</p> <ul> <li>Support for functions to be imported into the WebAssembly Module</li> <li>Support for <code>twrWasmModuleAsync</code> proxy Web Worker thread</li> <li>An event framework, allowing you to post events to WebAssembly C code.</li> </ul> <p>To implement a twr-wasm library you:</p> <ul> <li>create a new TypeScript class that extends <code>class twrLibrary</code>.  </li> <li>create a C .h file for your new functions (with function signatures)</li> <li>add one or more functions to your TypeScript class</li> <li>add the functions to the <code>import</code> object (that is part of your class)</li> <li>consider if special handling is needed for <code>twrWasmModuleAsync</code> (more on this below)</li> </ul>"},{"location":"api/api-ts-library/#lib-example","title":"Lib Example","text":"<p>See the <code>lib</code> example here for a more complete example which shows how each of the different use cases can be handled.  In addition, you can look in <code>/source/twr-ts</code> for files that start with <code>twrlib*</code> or <code>twrcon*</code> for examples.</p>"},{"location":"api/api-ts-library/#example-twrlibtimer","title":"Example twrLibTimer","text":"<p>The following code is from the twr-wasm source for twrlibtimer.</p> <ul> <li><code>twr_timer_single_shot</code> - sends an event to C after the timer times out.</li> <li><code>twr_sleep</code> - blocks C execution for a period of time.</li> </ul> <pre><code>import {IWasmModule,} from \"./twrmod.js\"\nimport {IWasmModuleAsync} from \"./twrmodasync.js\"\nimport {twrLibrary, TLibImports, twrLibraryInstanceRegistry} from \"./twrlibrary.js\"\n\n// Libraries use default export\nexport default class twrLibTimer extends twrLibrary {\n   id: number;\n   imports:TLibImports = {\n      twr_timer_single_shot:{},\n      twr_sleep:{isAsyncFunction: true, isModuleAsyncOnly: true},\n   };\n\n   libSourcePath = new URL(import.meta.url).pathname;\n\n   constructor() {\n      // all library constructors should start with these two lines\n      super();\n      this.id=twrLibraryInstanceRegistry.register(this);\n   }\n\n   twr_timer_single_shot(callingMod:IWasmModule|IWasmModuleAsync, milliSeconds:number,  eventID:number) {\n      setTimeout(()=&gt;{\n         callingMod.postEvent(eventID)\n      }, milliSeconds);     \n   }\n\n   async twr_sleep_async(callingMod:IWasmModuleAsync, milliSeconds:number) {\n      const p = new Promise&lt;void&gt;( (resolve)=&gt;{\n         setTimeout(()=&gt;{ resolve() }, milliSeconds);  \n      });\n\n      return p;\n   }\n\n}\n</code></pre>"},{"location":"api/api-ts-library/#c-header-files","title":"C Header Files","text":"<p>You need to create a .h file that provides signatures to the C users of your new API.  For example, for this library your .h file would be this:</p> <pre><code>__attribute__((import_name(\"twr_timer_single_shot\"))) void twr_timer_single_shot(int ms, int event_id);\n__attribute__((import_name(\"twr_sleep\"))) void twr_sleep(int ms);\n</code></pre> <p>The purpose of <code>import_name</code> code is to export your functions from WebAssembly to JavaScript.  These are an equivalent alternative to adding the functions to an <code>wasm-ld</code> <code>-export</code> option.</p>"},{"location":"api/api-ts-library/#registering-your-api","title":"Registering your API","text":"<p>To register you class so that the APIs are available to C code, you use code akin to this in your <code>index.html</code> (or similar): <pre><code>import twrLibTimerMod from \"./twrlibtimer.js\"  // default export\n\nnew twrLibTimerMod();  // will register itself\n</code></pre></p> <p>If you are a contributor to twr-wasm and plan to add your library as new built-in APIs, add the registration to <code>twrLibBultins.ts</code></p>"},{"location":"api/api-ts-library/#example-function-explained","title":"Example Function Explained","text":"<p>Here is what is happening in this code:</p> <pre><code>imports:TLibImports = {\n   twr_timer_single_shot:{},\n}\n\n// this function will work in both twrWasmModule and twrWasmModuleAsync\ntwr_timer_single_shot(callingMod:IWasmModule|IWasmModuleAsync, milliSeconds:number,  eventID:number) {\n   setTimeout(()=&gt;{\n      callingMod.postEvent(eventID)\n   }, milliSeconds);     \n}\n</code></pre> <p><code>twr_timer_single_shot</code> is listed in the <code>imports</code> class member variable which causes the function <code>twr_timer_single_shot</code> to be added to the WebAssembly.ModuleImports imports. </p> <p>The argument for <code>callingMod:IWasmModule|IWasmModuleAsync</code> is filled in by the <code>twrLibrary</code> code -- the calling C function does not include this as an argument.   All Parameters following <code>callingMod</code> are passed by the C code calling the function.</p> <p><code>twr_timer_single_shot</code> creates a JavaScript timer.  When the timer completes, an event is posted, which will trigger a callback in the C code.</p>"},{"location":"api/api-ts-library/#events","title":"Events","text":"<p>To receive an Event, the C code needs to register an event callback, and then pass the event ID to the function that will generate events.  Like this:</p> <pre><code>__attribute__((export_name(\"on_timer\")))\nvoid on_timer(int event_id) {\n   printf(\"timer callback 2 entered (event id=%d)\\n\", event_id);\n}\n\n__attribute__((export_name(\"twr_main\")))\nvoid twr_main() {\n   int timer1=twr_register_callback(\"on_timer\");\n   twr_timer_single_shot(2000, timer);\n</code></pre> <p>In this example, <code>on_timer</code> will be called after 2 seconds.</p> <p><code>__attribute__((export_name(\"on_timer\")))</code> is needed because this C function is exported out of the WebAssembly module and into the JavaScript code.  JavaScript needs to call this function.</p> <p>In this example, the event does not have any arguments.  But it may -- integers (which includes pointers) can be accepted as arguments to the event callback.  These arguments are event specific.</p>"},{"location":"api/api-ts-library/#imports","title":"imports","text":"<p>All TypeScript functions that you wish to import into a WebAssembly module as C APIs, should be listed in the <code>imports</code> object.</p> <p>Each function in the <code>imports</code> object has optional options, that are primarily for use with <code>twrWasmModuleAsync</code> modules.</p> <p><code>imports</code> are added to WebAssembly.ModuleImports imports.</p>"},{"location":"api/api-ts-library/#callingmod","title":"callingMod","text":"<p>Each function listed in the <code>import</code> section will be passed a module as the first parameter.  In general, a function should be written to handle being called either with <code>IWasmModule</code> or <code>IWasmModuleAsync</code> as the calling module interface ( <code>callingMod:IWasmModule|IWasmModuleAsync</code> ).  This is generally straight forward.  </p> <p>Examples that might cause some extra work, and that are covered below, are:</p> <ul> <li>Implementing  blocking functions like <code>twr_sleep</code></li> <li>Allocating memory, for example, to return a string</li> </ul>"},{"location":"api/api-ts-library/#numbers-only","title":"Numbers Only","text":"<p>All of the parameters received by an <code>import</code> function need to be numbers.  These functions interface directly with the WebAssembly module with no conversion.  If you are passing or returning strings, or accessing structures, you will need to use the data access functions that are provided in <code>callingMod.memWasm</code> (more on this below).  The general issue and approach is explained in this document..</p>"},{"location":"api/api-ts-library/#memwasm","title":"memWasm","text":"<p>A <code>callingMod</code> member function that you may need to use is <code>memWasm</code> (<code>callingMod.memWasm</code>).   <code>memWasm</code> is used to access data in the WebAssembly Memory.  This will happen when you need to dereference a pointer, access strings, or access structures. See <code>wasmMem</code> documentation here.</p> <p><code>memWasm</code> is exposed by both <code>IWasmModule</code> and <code>IWasmModuleAsync</code>.  </p> <ul> <li><code>IWasmModule</code> exposes <code>wasmMem: IWasmMemory</code> </li> <li><code>IWasmModuleAsync</code> exposes <code>wasmMem: IWasmMemoryAsync</code>.  </li> </ul> <p>If you wish to write a function that accesses the <code>async</code> <code>PutXXX</code> functions, you should use the <code>isAsyncFunction: true</code> option.</p>"},{"location":"api/api-ts-library/#twrwasmmodule-and-twrwasmmoduleasync","title":"<code>twrWasmModule</code> and <code>twrWasmModuleAsync</code>.","text":"<p>twrLibrary's are designed to work with either <code>twrWasmModule</code> and <code>twrWasmModuleAsync</code>.  (Recall that twr-wasm has two different module types:  <code>twrWasmModule</code> and <code>twrWasmModuleAsync</code>).</p> <ul> <li><code>twrWasmModule</code> runs in the JavaScript main thread, and thus all functions that it exposes are asynchronous -- meaning that they should return relatively quickly and not block execution.</li> <li><code>twrWasmModuleAsync</code> runs in a JavaScript Worker thread , and thus all functions that it exposes are synchronous  -- meaning they can block C execution.  The \"Async\" in <code>twrWasmModuleAsync</code> refers to the fact that javaScript can <code>await</code> on <code>twrWasmModuleAsync</code> blocking APIs.  It takes blocking APIs and makes them \"asynchronous\" to the JavaScript main thread.</li> </ul> <p>Although many functions can be listed in <code>imports</code> and written without worrying about which type of module is using them, this isn't always true.  Some tomes extra code or thought is needed to have optimal APIs for <code>twrWasmModuleAsync</code>.</p> <p>In the above example, <code>twr_timer_single_shot</code> will work correctly with both <code>twrWasmModule</code> and <code>twrWasmModuleAsync</code>.  It is an asynchronous function -- meaning that it returns quickly.  </p> <p>However, the function <code>twr_sleep</code> blocks C code, and will only work with <code>twrWasmModuleAsync</code>.</p>"},{"location":"api/api-ts-library/#twrwasmmoduleasync-thread-structure","title":"<code>twrWasmModuleAsync</code> thread structure","text":"<p>To understand more clearly why <code>twrWasmModuleAsync</code> might need more attention, it is helpful to understand how it is allocates task between its two threads: the JavaScript main thread, and a worker thread.</p>"},{"location":"api/api-ts-library/#the-twr_sleep-function-is-used-to-illustrate-thread-structure","title":"The <code>twr_sleep</code> function is used to illustrate thread structure","text":"<p>The function <code>twr_sleep_async</code> will only function with <code>twrWasmModuleAsync</code> because it causes the C code to block.  For example, <code>twr_sleep</code> can be used like this:</p> <pre><code>printf(\"going to sleep...\");\ntwr_sleep(1000);\nprintf(\"awake!\\n\");\n</code></pre>"},{"location":"api/api-ts-library/#twrwasmmoduleasync-uses-two-threads","title":"<code>twrWasmModuleAsync</code> uses Two Threads","text":"<p>The<code>twrWasmModuleAsync</code> consists of two threads:  The JavaScript main thread, and the Web Worker.  By default the code for your library functions is always executed in the JavaScript main thread.   In the Web Worker, an internal class called <code>twrWasmModuleAsyncProxy</code> executes.  The default execution (unless <code>isCommonCode</code> is specified -- which is explained later), happens like this:</p> <ol> <li>in C: twr_sleep() is called</li> <li>in <code>twrWasmModuleAsyncProxy</code>, a message is sent to the JavaScript main thread, requesting execution of the <code>twrLibTimer.twr_sleep</code> function.</li> <li><code>twrWasmModuleAsyncProxy</code> is paused (thus <code>twr_sleep</code> is blocking), waiting for a response to the message sent ins step 2.</li> <li>The JavaScript main thread receives the message, and <code>awaits</code> on <code>twrLibTimer.twr_sleep</code></li> <li>When the Promise that is being awaited on resolves, the JavaScript main threads sends a reply back to <code>twrWasmModuleAsyncProxy</code> indicating that execution is complete. If there are any return codes they are also sent (twr_sleep does not have a return code)</li> <li><code>twr_sleep</code> returns to the C caller</li> </ol> <p>The above sequence actually happens for all <code>import</code> functions by default when using <code>twrWasmModuleAsync</code>, irregardless if or how long they block for.  This is because certain JavaScript code can only execute in the JavaScript main thread.  Import function options exists to modify this behavior, in the cases where it is not desired.</p> <p>The above steps also glosses over an important point -- the method that the <code>twrWasmModuleAsyncProxy</code> uses to wait for a response from the main JavaScript thread.  In step 3 above (Worker thread is blocking from <code>twr_sleep</code> call), the worker thread is blocking on a call to <code>Atomics.wait</code>.  Communication from the JavaScript main thread to the Worker is through shared memory and a circular buffer.  This is how twrWasmModuleAsync is able to block execution of the C code.  This means that the Worker Thead main event loop can block for long periods of time -- perhaps indefinitely.  And this means common JavaScript code can not run reliably in the Worker thread.  For example, a setTimeout callback may not happen (because it is dispatched by the main JavaScript event loop).  Likewise, Animations won't work since they are often executed inside the JavaScript event loop.   This is another important reason that all the <code>import</code> code generally runs inside the JavaScript main thread.</p>"},{"location":"api/api-ts-library/#blocking-function-explained","title":"Blocking Function Explained","text":"<p>twr-wasm supports blocking functions like sleep when the API user is using <code>twrWasmModuleAsync</code>. This section explains the <code>sleep</code> function which causes C code to block.  In other words, in C, code like this will work:</p> <pre><code>printf(\"going to sleep...\");\ntwr_sleep(1000);\nprintf(\"awake!\\n\");\n</code></pre> <p>The TypeScript twrLibrary derived class implementation looks like this:</p> <pre><code>// this function will only work in twrWasmModuleAsync since it blocks the C caller.\nasync twr_sleep_async(callingMod:IWasmModuleAsync, milliSeconds:number) {\n   const p = new Promise&lt;void&gt;( (resolve)=&gt;{\n      setTimeout(()=&gt;{ resolve() }, milliSeconds);  \n   });\n\n   return p;\n}\n</code></pre> <p>And has these import options set: <pre><code>imports:TLibImports = {\n   twr_sleep:{isAsyncFunction: true, isModuleAsyncOnly: true},\n};\n</code></pre></p> <p><code>isAsyncFunction: true</code> is telling twrLibrary to call the <code>twr_sleep_async</code> function with <code>await</code> and so allow the function being called to <code>await</code>.  <code>isModuleAsyncOnly: true</code> is telling twrLibrary that this function only exists when <code>twrWasmModuleAsync</code> is used.</p> <p>This code will execute in the JavaScript main thread.  The Calling C code (<code>twr_sleep</code>) will block in a Worker thread while waiting for this code in the JavaScrit main thread to complete.  The function <code>twr_sleep_async</code> creates a JavaScript promise that the calling code will <code>await</code> on.  Once the promise  resolves, the calling function will unblock the C <code>twr_sleep</code> function that is in the Worker Thread.</p>"},{"location":"api/api-ts-library/#import-options","title":"<code>import</code> options","text":"<p>The various <code>import</code> options are used to handle different cases for <code>twrWasmModuleAsync</code>.</p> <p>The import options are: <pre><code>isAsyncFunction?:boolean;\nisModuleAsyncOnly?:boolean;\nisCommonCode?:boolean;\n</code></pre></p>"},{"location":"api/api-ts-library/#isasyncfunction","title":"<code>isAsyncFunction</code>","text":"<p>This option is used when you wish to <code>await</code> inside the implementation of your function. This option also specifies that the function will be called with <code>await</code>.  </p> <p>This option will only modify behavior this way when your function is called from <code>twrWasmModuleAsync</code>.</p> <ul> <li>If this option is not specified, the same <code>import</code> function will be used for both module types, and the function can not use the <code>await</code> keyword. </li> <li>if this option is specified, then when <code>twrWasmModuleAsync</code> calls the indicated <code>import</code> function, it will call a version of the function that has <code>_async</code> append to the function name.  This means that you will create two versions of the <code>import</code> <code>funcA</code> - <code>funcA</code> and <code>funcA_async</code>. </li> <li>If, however, you also specify the option <code>isModuleAsyncOnly</code>, then only the <code>_async</code> function is expected.</li> </ul> <p>Here is an example of how declare a function with the <code>import</code> option <code>isAsyncFunction</code>:</p> <pre><code>async twr_sleep_async(callingMod:IWasmModuleAsync, milliSeconds:number)\n</code></pre> <p>Note that:</p> <ul> <li>the function declaration starts with the async keyword</li> <li>the function has the suffix <code>_async</code> appended to its <code>import</code> name</li> <li>that the function is passed an <code>IWasmModuleAsync</code> as the callingMod.</li> </ul> <p>By using this option, you may need to create two versions of the <code>import</code> function -- one that is <code>async</code> (for use by <code>twrWasmModuleAsync</code>), and one that does not use the <code>async</code> keyword--for use by <code>twrWasmModule</code>.</p> <p>In a case like <code>twr_sleep</code>, there is only one function implemented for sleep - the async function.  But this is not always the case.  For example, if your <code>import</code> function uses the <code>wasmMem.PutXX</code> functions, you will need to create two functions for the <code>import</code>.  Here is an example:</p> <pre><code> imports:TLibImports = {\n      ex_append_two_strings:{isAsyncFunction: true},\n   };\n\n   ex_append_two_strings(callingMod:IWasmModule, str1Idx:number, str2Idx:number) {\n      const newStr=callingMod.wasmMem.getString(str1Idx)+callingMod.wasmMem.getString(str2Idx);\n      const rv=callingMod.wasmMem.putString(newStr);\n      return rv;\n   }\n\n   async ex_append_two_strings_async(callingMod:IWasmModuleAsync, str1Idx:number, str2Idx:number) {\n      const newStr=callingMod.wasmMem.getString(str1Idx)+callingMod.wasmMem.getString(str2Idx);\n      const rv=await callingMod.wasmMem.putString(newStr);\n      return rv;\n   }\n</code></pre>"},{"location":"api/api-ts-library/#ismoduleasynconly","title":"<code>isModuleAsyncOnly</code>","text":"<p>This option specifies that the indicated function is only available to <code>twrWasmModuleAsync</code>. This option should be used for functions that block C execution. The <code>twr_sleep</code> is an example.</p>"},{"location":"api/api-ts-library/#iscommoncode","title":"<code>isCommonCode</code>","text":"<p>This option is used to specify a function that should be used directly by the <code>twrWasmModuleAsync</code> Web Worker.  Without this option, the behavior is that code running in the Web Worker will send a message to the JavaScript Main thread requesting that the function be executed in the context of the JavaScript main thread.  The Web Worker will then wait for a reply to the message before continuing C execution.  However, in certain cases, it is possible, and might be more performant, to have the code execute directly in the WorkerThread.</p> <p>There are limitations on the code that will work correctly with <code>isCommonCode</code>:</p> <ul> <li>The functions must be available to a Worker thread</li> <li>The function can not be <code>async</code> (that is, it can not use <code>await</code>)</li> <li>The function can not call <code>PostEvent</code></li> <li>The functions must not depend on the Worker's main event loop running (this event loop often doesn't execute with the <code>twrWasmModuleAsync</code> Worker thread.)</li> <li>The function can not use a callback (the callback won't get called because callbacks are often dispatched in the JavaScript main event loop)</li> </ul> <p>Here is an Example of using <code>isCommonCode</code>:</p> <pre><code>export default class twrLibMath extends twrLibrary {\n   imports:TLibImports = {\n      twrSin:{isCommonCode: true},\n   }\n\n   libSourcePath = new URL(import.meta.url).pathname;\n\n   twrSin(callingMod:IWasmModule|twrWasmBase, angle:number ) {return Math.sin(angle)}\n}\n</code></pre> <p>In this case the <code>Math.sin</code> function is available in both a Web Worker and the JavaScript main thread.  It is a simple function, that works fine without the JavaScript event loop operating.</p>"},{"location":"api/api-ts-library/#noblock","title":"noBlock","text":"<p><code>noBlock</code> will cause a function call in an <code>twrWasmModuleAsync</code> to send the message from the Worker proxy thread to the JS main thread to execute the function, but not to wait for the result.  This should only be used for functions with a <code>void</code> return value.  This has the advantage that (a) the C code will not block waiting for a void return value (so it returns faster), and (b) it takes advantage of multiple cores by allowing the JS Main thread and the Worker thread to execute in parallel.  </p> <p>Note that the messages sent from the proxy thread to the JS main thread (for function execution) will cause execution of function calls to serialize, and so if a function that blocks (waits for results from JS main thread) is called after a call with <code>noBlock</code>, everything should work as expected.</p> <p>Do not use <code>noBlock</code> if:</p> <ul> <li>the function returns a value</li> <li>the C code should not continue executing until the function completes execution.</li> <li>if the following scenario could arise:<ul> <li>funcA (with noBlock) called</li> <li>funcB called and returns a value or otherwise depends on funcA completing execution,  and funcA uses async keyword.</li> </ul> </li> </ul> <p>Use <code>noBlock</code> carefully.</p>"},{"location":"api/api-ts-library/#libsourcepath","title":"libSourcePath","text":"<p>Always set this as follows:    <pre><code>libSourcePath = new URL(import.meta.url).pathname;\n</code></pre></p> <p><code>libSourcePath</code> is used to uniquely identify the library class, as well as to dynamically import the library when <code>isCommonCode</code> is used.</p>"},{"location":"api/api-ts-library/#interfacename","title":"interfaceName","text":"<p>In a twrLibrary, </p> <ul> <li>An \"interface\" refers to the set of functions that the library exposes to C. Ie, the functions in the <code>import</code> object.</li> <li>The name of the interface is anonymous, unless <code>interfaceName</code> is set. </li> <li>An undefined interfaceName (anonymous interface) also means that only one instance of that class is allowed (for example <code>twrLibMath</code>)</li> <li>Set <code>interfaceName</code> to a unique name when multiple instances that support the same interface are allowed (for example the twr-wasm Consoles).  </li> <li>Multiple classes may have the same interfaceName (a class is identified by its libSourcePath). For example <code>twrConDiv</code>, <code>twrConDebug</code>, <code>twrConTerminal</code> all have the same interface.</li> </ul> <p>When multiple instances of classes with the same interface are enabled (by setting <code>interfaceName</code>), the first argument in every C function call is expected to be the twrLibrary <code>id</code> (a member variable of the twrLibrary derived class).  The twrLibrary will use this <code>id</code> to route the function call to the correct instance of the library.  The <code>id</code> is not passed to the twrLibrary function (even though it is required to be the first C arg).</p> <p>The twrLibrary instance should be created in the JavaScript main thread, and passed to the module in the <code>io</code> option.  The C code can discover the <code>id</code>, by using the <code>twr_get_console</code>.</p> example<pre><code>interfaceName = \"twrConsole\";\n</code></pre>"},{"location":"api/api-ts-library/#the-twrwasmmoduleasync-event-loop","title":"The <code>twrWasmModuleAsync</code> Event Loop","text":"<p>TODO</p>"},{"location":"api/api-ts-memory/","title":"Accessing Data in WebAssembly Memory","text":"<p>There are situations where you may need to access WebAssembly memory from your TypeScript code. For example, if you need to allocate a new string, de-reference a pointer, or examine or modify a structure. A <code>TwrLibrary</code> in particular may need to do this. ( For background on the issues involved in using WebAssembly Memory with C and TypeScript see  Passing Function Arguments from JavaScript to C/C++ with WebAssembly.).</p> <p>To access WebAssembly memory you will use the <code>wasmMem</code> public member variable:</p> <ul> <li><code>twrWasmModule</code> has the public member variable <code>wasmMem:IWasmMemory</code></li> <li><code>twrWasmModuleAsync</code> has the public member variable <code>wasmMem:IWasmMemoryAsync</code></li> </ul> <p>If you are writing a <code>twrLibrary</code>, the appropriate <code>wasmMem</code> is the first parameter of your import functions.</p> <p>Both versions of wasmMem extend <code>IWasmMemoryBase</code> which has common functions for retrieving or setting values from WebAssembly memory.  With <code>IWasmMemoryAsync</code>, for functions that call <code>malloc</code> internally, <code>await</code> must be used.  This situation arises in the <code>IWasmMemoryAsync</code> versions of the <code>PutXXX</code> functions -- they return a Promise. <code>PutXX</code> makes a call to <code>malloc</code>, and in <code>twrWasmModuleAsync</code>, <code>malloc</code> needs to message the Worker thread and <code>await</code> for a response.</p> <p><code>mem8</code>, <code>mem32</code>, <code>memF</code>, and <code>memD</code> can be used to access the WebAssembly memory directly.  They are different views on the same memory.</p> <p><code>getU8Arr</code> and <code>getU32Arr</code> expect that <code>idx</code> (a pointer) points to a: <pre><code>struct {\n   int size;\n   void* data;\n}\n</code></pre></p> <p>Note: In prior versions of twr-wasm, these functions were available directly on the module instance.  For example, <code>mod.GetString</code>.  These functions have been deprecated.   Now you should use <code>mod.wasmMem.getString</code> (for example).</p> <pre><code>// IWasmMemoryBase operate on shared memory, so they will function in any WasmModule \nexport interface IWasmMemoryBase {\n   memory:WebAssembly.Memory;\n   mem8:Uint8Array;\n   mem32:Uint32Array;\n   memF:Float32Array;\n   memD:Float64Array;\n   stringToU8(sin:string, codePage?:number):Uint8Array;\n   copyString(buffer:number, buffer_size:number, sin:string, codePage?:number):void;\n   getLong(idx:number): number;\n   setLong(idx:number, value:number):void;\n   getDouble(idx:number): number;\n   setDouble(idx:number, value:number):void;\n   getShort(idx:number): number;\n   getString(strIndex:number, len?:number, codePage?:number): string;\n   getU8Arr(idx:number): Uint8Array;\n   getU32Arr(idx:number): Uint32Array;\n}\n\n// IWasmMemory does not support await, and so will only work in a thread that has the module loaded\n// That would be twrWasmModule, twrWasmModuleAsyncProxy\nexport interface IWasmMemory extends IWasmMemoryBase {\n   malloc:(size:number)=&gt;number;\n   free:(size:number)=&gt;void;\n   putString(sin:string, codePage?:number):number;\n   putU8(u8a:Uint8Array):number;\n   putArrayBuffer(ab:ArrayBuffer):number;\n}\n\n// IWasmMemoryAsync must be used from an async function since await is needed\nexport interface IWasmMemoryAsync extends IWasmMemoryBase {\n   malloc:(size:number)=&gt;Promise&lt;number&gt;;\n   free:(size:number)=&gt;Promise&lt;void&gt;;\n   putString(sin:string, codePage?:number):Promise&lt;number&gt;;\n   putU8(u8a:Uint8Array):Promise&lt;number&gt;;\n   putArrayBuffer(ab:ArrayBuffer):Promise&lt;number&gt;;\n}\n</code></pre>"},{"location":"api/api-ts-modules/","title":"Wasm Modules","text":"<p>This section describes the twr-wasm TypeScript/JavaScript classes <code>twrWasmModule</code> and <code>twrWasmModuleAsync</code> that are used to load <code>.wasm</code> modules, call their C functions, and access wasm memory.  Both classes have similar APIs.  </p>"},{"location":"api/api-ts-modules/#about-twrwasmmodule","title":"About <code>twrWasmModule</code>","text":"<p><code>class twrWasmModule</code> allows you to integrate WebAssembly C/C++ code into your Web Page.  You can call C/C++ functions, and read and write WebAssembly memory. Function calls are asynchronous, as is normal for a JavaScript function.  That is C/C++ functions should not block - they should return quickly (just as happens in JavaScript).</p> <p>The constructor accepts an optional object (type <code>IModOpts</code>), which is explained further down. <pre><code>import {twrWasmModule} from \"twr-wasm\";\n\nconst mod = new twrWasmModule();\n</code></pre></p>"},{"location":"api/api-ts-modules/#about-twrwasmmoduleasync","title":"About <code>twrWasmModuleAsync</code>","text":"<p><code>class twrWasmModuleAsync</code> allows you to integrate WebAssembly C/C++ code into your Web Page that uses a Read-Eval-Print Loop (REPL) pattern, a CLI pattern or code that blocks.  For example, with <code>twrWasmModuleAsync</code> your C/C++ code can call a synchronous function for keyboard input (that blocks until the user has entered the keyboard input).  Or your C/C++ code can <code>sleep</code> or otherwise block.   This is the pattern that is used by many standard C library functions - <code>fread</code>, etc.  </p> <p><code>class twrWasmModuleAsync</code> creates a WorkerThread that runs in parallel to the JavaScript main thread.  This Worker thread executes your C/C++ code, and proxies functionality that needs to execute in the JavaScript main thread via remote procedure calls.  This allows the JavaScript main thread to <code>await</code> on a blocking <code>callC</code> in your JavaScript main thread.  </p> <p>The <code>Async</code> part of the <code>twrWasmModuleAsync</code> name refers to the property of <code>twrWasmModuleAsync</code> that makes your synchronous C/C++ code asynchronous.</p> <p>The APIs in <code>class twrWasmModuleAsync</code> are identical to <code>class twrWasmModule</code>, except that certain functions use the <code>async</code> keyword and thus need to be called with <code>await</code>.  This happens whenever the function needs to cross the JavaScript main thread and the Worker thread boundary.  For example:  <code>callC</code> or <code>malloc</code>.</p> <p>The constructor accepts an optional object (type <code>IModOpts</code>), which is explained further down.</p> <pre><code>import {twrWasmModuleAsync} from \"twr-wasm\";\n\nconst amod = new twrWasmModuleAsync();\n</code></pre>"},{"location":"api/api-ts-modules/#loadwasm","title":"loadWasm","text":"<p>This function is available on both <code>class twrWasmModule</code> and <code>class twrWasmModuleAsync</code>.</p> <p>Use <code>loadWasm</code> to load your compiled C/C++ code (the <code>.wasm</code> file).  <pre><code>await mod.loadWasm(\"./mycode.wasm\")\n</code></pre></p>"},{"location":"api/api-ts-modules/#callc","title":"callC","text":"<p>This function is available on both <code>class twrWasmModule</code> and <code>class twrWasmModuleAsync</code>.   <code>twrWasmModuleAsync</code> returns a Promise, <code>twrWasmModule</code> does not.</p> <p>After your .<code>wasm</code> module is loaded with <code>loadWasm</code>, you call functions in your C/C++ from TypeScript/JavaScript like this:</p> twrWasmModule<pre><code>let result=mod.callC([\"function_name\", ...params])\n</code></pre> twrWasmModuleAsync<pre><code>let result=await mod.callC([\"function_name\", ...params])\n</code></pre> <p>If you are calling into C++, you need to use <code>extern \"C\"</code> like this in your C++ function: <pre><code>extern \"C\" int function_name() {}\n</code></pre></p> <p>Each C/C++ function that you wish to call from TypeScript/JavaScript needs to be exported in your <code>wasm-ld</code> command line with an option like this: <pre><code>--export=function_name\n</code></pre> Or like this in your source file: <pre><code>__attribute__((export_name(\"function_name\")))\nvoid function_name() {\n   ...\n}\n</code></pre></p> <p>Fo more details, see the Compiler Options.</p> <p><code>callC</code> takes an array where:</p> <ul> <li>the first entry is the name of the C function in the Wasm module to call </li> <li> <p>and the next optional entries are a variable number of arguments to pass to the C function, of type:</p> <ul> <li><code>number</code> - will be converted to a signed or unsigned <code>long</code>, <code>int32_t</code>, <code>int</code>, <code>float</code> or <code>double</code> as needed to match the C function declaration.</li> <li><code>bigint</code> - will be converted into an <code>int64_t</code> or equivalent</li> <li><code>string</code> - converted to a <code>char *</code> of malloc'd module memory where string is copied into</li> <li><code>ArrayBuffer</code> - the array is copied into malloc'd module memory.  If you need to pass the length, pass it as a separate argument.  Any modifications to the memory made by your C code will be reflected back into the JavaScript ArrayBuffer.</li> </ul> </li> </ul> <p><code>callC</code> returns the value returned by the C function. <code>long</code>, <code>int32_t</code>, <code>int</code>, <code>float</code> or <code>double</code> and the like are returned as a <code>number</code>.   <code>int64_t</code> is returned as a <code>bigint</code>, and pointers are returned as a <code>number</code>.  The contents of the pointer will need to be extracted using the functions listed below.   More details can be found in this article: Passing Function Arguments to WebAssembly and in this example.  The FFT example demonstrates passing and modifying a <code>Float32Array</code> view of an <code>ArrayBuffer</code>.</p> <p>Although you can always use <code>await</code> on a <code>callC</code>, it is only strictly necessary if the module is of class <code>twrWasmModuleAsync</code>.</p> <p><code>CallC</code> is mapped to <code>wasmCall.callC</code>.  <code>wasmCall</code> also exposes <code>callCImpl</code>, which can be used if no argument conversion is needed.That is if the arguments are all numbers).</p>"},{"location":"api/api-ts-modules/#fetchandputurl","title":"fetchAndPutURL","text":"<p><code>fetchAndPutURL</code> is available as a member function of both <code>twrWasmModule</code> and <code>twrWasmModuleAsync</code>.</p> <pre><code>fetchAndPutURL(fnin:URL) : Promise&lt;[number, number]&gt;;\n</code></pre> <p>The returned array contains the index of where the URL contents have been loaded into wasm memory (in index 0), and the length (in index 1).</p> <p>In prior versions of twr-wasm, <code>callC</code> could accept an argument type of URL.  This is no longer supported, and instead <code>fetchAndPutURL</code>  should be used.</p>"},{"location":"api/api-ts-modules/#log","title":"log","text":"<p><code>log</code> is available as a member function of both <code>twrWasmModule</code> and <code>twrWasmModuleAsync</code>.</p> <p><code>log</code> is similar to the JavaScript <code>console.log</code>, except that the output is sent to the <code>stdio</code> console.  </p> <pre><code>log(...params: string[]):void;\n</code></pre> <p>Also note that most consoles have a <code>putStr</code> function.</p>"},{"location":"api/api-ts-modules/#twrwasmmoduleasync-details","title":"twrWasmModuleAsync Details","text":"<p><code>twrWasmModuleAsync</code> implements all of the same functions as <code>twrWasmModule</code>, plus allows blocking inputs, and blocking code generally. This is achieved by proxying all the calls through a Web Worker thread. </p> <p>For example, with this C function in your Wasm module: <pre><code>void mysleep() {\n   twr_sleep(5000);  // sleep 5 seconds\n}\n</code></pre></p> <p>can be called from your JavaScript main loop like this: <pre><code>await amod.callC([\"mysleep\"]);\n</code></pre></p> <p>You must use <code>twrWasmModuleAsync</code> in order to:</p> <ul> <li>call any blocking C function (meaning it takes \"a long time\") to return</li> <li>use blocking input from a div or canvas ( eg. <code>twr_mbgets</code> )</li> <li>use <code>twr_sleep</code></li> </ul>"},{"location":"api/api-ts-modules/#linking-requirements","title":"Linking Requirements","text":"<p>When linking your C/C++ code, <code>twrWasmModule</code> and <code>twrWasmModuleAsync</code> use slightly different <code>wasm-ld</code> options since <code>twrWasmModuleAsync</code> uses shared memory. <code>twrWasmModule</code> will operate with shared memory, so technically you could just use the same share memory options with either module,  but you don't need the overhead of shared memory when using twrWasmModule, and so better to not enable it.</p> <p>See wasm-ld Linker Options.</p>"},{"location":"api/api-ts-modules/#javascript-needed-for-char-input","title":"JavaScript Needed for Char Input","text":"<p>When a console will handle key input, you need to add a line to your JavaScript to send key events to the console.  There are two options for this:  You can send the key events directly to the console, or if the key events are always directed to <code>stdio</code>, you cam send the key events to the module.  This latter case is primarily for when you are using tag shortcuts.</p> <p>To send key events to the console, you add a line like this: <pre><code>yourDivOrCanvasElement.addEventListener(\"keydown\",(ev)=&gt;{yourConsoleClassInstance.keyDown(ev)});\n</code></pre></p> <p>To send key events to the module's <code>stdio</code>, you add a line like this: <pre><code>yourDivOrCanvasElement.addEventListener(\"keydown\",(ev)=&gt;{yourModuleClassInstance.keyDown(ev)});\n</code></pre></p> <p>You likely want a line like this to automatically set the focus to the div or canvas element (so the user doesn't have to click on the element to manually set focus.  Key events are sent to the element with focus.):</p> <pre><code>yourDivOrCanvasElement.focus();\n</code></pre> <p>You will also need to set the <code>tabindex</code> attribute in your tag like this to enable key events:</p> <pre><code>&lt;div id=\"twr_iodiv\" tabindex=\"0\"&gt;&lt;/div&gt;\n&lt;canvas id=\"twr_iocanvas\" tabindex=\"0\"&gt;&lt;/canvas&gt;\n</code></pre> <p>See this example on character input.</p> <p>Note that this section describes blocking input.  As an alternative, you can send events (keyboard, mouse, timer, etc) to a non-blocking C function from JavaScript using <code>callC</code>.  See the <code>balls</code> or <code>pong</code> examples.</p>"},{"location":"api/api-ts-modules/#sharedarraybuffers","title":"SharedArrayBuffers","text":"<p><code>twrWasmModuleAsync</code> uses SharedArrayBuffers which require certain CORS HTTP headers to be set. Note that <code>twrWasmModule</code> does not use SharedArrayBuffers.  If you limit yourself to <code>twrWasmModule</code> you will not need to worry about configuring the CORS http headers on your web server.</p> <p>See this note on enabling CORS HTTP headers for SharedArrayBuffers.</p>"},{"location":"api/api-ts-modules/#module-options","title":"Module Options","text":"<p>The <code>twrWasmModule</code> and <code>twrWasmModuleAsync</code> constructor both take optional options.</p> <p>For example: <pre><code>let amod=new twrWasmModuleAsync();\n\nlet amod=new twrWasmModuleAsync({\n   stdio: new twrConsoleDebug();  // send stdio to debug console\n   });\n</code></pre></p> <p>These are the options: twrWasmModule &amp; twrWasmModuleAsync Options<pre><code>export interface IModOpts {\n   stdio?: IConsoleStream&amp;IConsoleBase,\n   d2dcanvas?: IConsoleCanvas&amp;IConsoleBase,\n   io?: {[key:string]: IConsole},\n}\n</code></pre></p>"},{"location":"api/api-ts-modules/#stdio-option","title":"<code>stdio</code> Option","text":"<p>Set this to a Console class instance.  If you leave it undefined, <code>twrConsoleDebug</code> will be used (or a tag shortcut, if set)</p> <p>This option is a shortcut to setting <code>stdio</code> using the <code>io</code> option.</p>"},{"location":"api/api-ts-modules/#d2dcanvas-option","title":"<code>d2dcanvas</code> Option","text":"<p>Set this to a <code>twrConsoleCanvas</code> instance to configure a 2D drawing surface. If you leave it undefined, a tag shortcut will be used.</p> <p>This option is a shortcut to setting <code>std2d</code> using the <code>io</code> option (note the different names).</p>"},{"location":"api/api-ts-modules/#io-option-multiple-consoles-with-names","title":"<code>io</code> Option: Multiple Consoles with Names","text":"<p>This option allows you to assign names to consoles.  The C/C++ code can then retrieve a console by name.</p> <p>When using the <code>io</code> object to specify named consoles:</p> <ul> <li>You can use the attribute  <code>stdio</code> to set stdio.  </li> <li>You can use the attribute <code>stderr</code> to set stderr</li> <li>You can use the attribute <code>std2d</code> to set the default 2D Drawing Surfaces -- used by twr-wasm 2D APIs.</li> <li>all other attribute names are available for your consoles.  Use this to access consoles in C/C++ beyond (or instead of) stdio, etc.</li> </ul> <p>Alternately, you can specify <code>stdio</code> and <code>std2d</code> directly as module attributes (outside of <code>io</code>) as a shortcut (see above).</p> <p>There is a twr-wasm C API to access named consoles: <code>twr_get_console</code>.</p> <p>This code snippet shows how to use the <code>io</code> option to pass in an object containing named console attributes:</p> <pre><code>const stream1Element=document.getElementById(\"stream1\");\nconst stream2Element=document.getElementById(\"stream2\");\n\nconst debug = new twrConsoleDebug();\nconst stream1 = new twrConsoleDiv(stream1Element);\nconst stream2 = new twrConsoleDiv(stream2Element);\n\nstream1Element.addEventListener(\"keydown\",(ev)=&gt;{stream1.keyDown(ev)});\nstream2Element.addEventListener(\"keydown\",(ev)=&gt;{stream2.keyDown(ev)});\n\n// setting stdio and/or stderr to a debug console isn't necessary since that will be the default if stdio or stderr is not set.\n// but here to show how to set stdio and/or stderr.  They can be set to any console.\nconst amod = new twrWasmModuleAsync( {io:{stdio: debug, stderr: debug, stream1: stream1, stream2: stream2}} );\nconst mod = new twrWasmModule( {io:{stdio: debug, stderr: debug, stream1: stream1, stream2: stream2}} );\n</code></pre> <p>In this case, as well as setting stdio and stderr, consoles named \"stream1\" and \"stream2\" are made available to the C/C++ code.</p> Using a Named Console<pre><code>twr_ioconsole_t * stream1=twr_get_console(\"stream1\");\nfprintf(stream1, \"Hello Stream One!\\n\");\n</code></pre> <p>A complete example multi-io is provided.</p>"},{"location":"api/api-ts-modules/#deprecated-options","title":"Deprecated Options","text":"<p>The following options are deprecated.  Instead of these, use options available to <code>twrConsoleDiv</code> and <code>twrConsoleTerminal</code> constructors.</p> deprecated<pre><code>export interface IModOpts {\n   windim?:[number, number],\n   forecolor?:string,\n   backcolor?:string,\n   fontsize?:number,\n}\n</code></pre> <p>Note:</p> <ul> <li><code>windim</code> - if stdio is set to a <code>twrConsoleTerminal</code>, this will set the width and height, in characters.  Instead, use constructor options on twrConsoleTerminal.</li> <li><code>forecolor</code> and <code>backcolor</code> - if stdio is set to <code>twrConsoleDiv</code> or <code>twrConsoleTerminal</code>, these can be set to a CSS color (like '#FFFFFF' or 'white') to change the default background and foreground colors.  However, these are deprecated, and instead, use the <code>twrConsoleDiv</code> or <code>twrConsoleTerminal</code> constructor options.</li> <li><code>fonsize</code> - Changes the default fontsize if stdio is set to <code>twrConsoleDiv</code> or <code>twrConsoleTerminal</code>.  Deprecated, instead use <code>twrConsoleDiv</code> or <code>twrConsoleTerminal</code> constructor options.</li> <li><code>TStdioVals</code> have been removed (they were a not too useful option in prior versions of twr-wasm)</li> <li><code>divLog</code> has been renamed <code>log</code>.  Or use the <code>putStr</code> member function on most consoles.</li> </ul>"},{"location":"examples/examples-balls/","title":"Bouncing Balls - 2D Draw API Wasm Example","text":"<p>This example uses twr-wasm's 2D Draw API and a C++ Canvas class with WebAssembly and C++ to bounce balls around your HTML page.</p> <ul> <li>View bouncing balls </li> <li>Source for balls </li> </ul> <p>The bouncing balls example demonstrates</p> <ul> <li>C++</li> <li>Using the twr-wasm draw 2D APIs that match Javascript Canvas APIs.</li> <li>Using the twr-wasm canvas.cpp wrapper class.</li> </ul> <p>This example does not use libc++, which results in smaller code size.   For an example that uses libc++ see tests-libcxx.</p>"},{"location":"examples/examples-balls/#screen-grab-of-balls-example","title":"Screen Grab of Balls Example","text":""},{"location":"examples/examples-callc/","title":"callC - Calling WebAssembly Functions Example","text":"<p>This example demonstrates how to pass and return values between TypeScript/JavaScript and C/C++ when you are using WebAssembly with twr-wasm.</p> <p>This article explains the key concepts to pass arguments between JavaScript/TypeScript and Wasm C/C++.</p> <ul> <li>View callC example running live</li> <li>View callC example source</li> </ul>"},{"location":"examples/examples-divcon/","title":"divcon - Printf and Input Using a <code>div</code> Tag","text":""},{"location":"examples/examples-divcon/#what-it-does","title":"What It Does","text":"<p>This example inputs a number, squares it, and prints the result using standard C library functions.</p> <p>The divcon example demos:</p> <ul> <li>A Read-Eval-Print Loop (REPL) </li> <li>using twr-wasm <code>class twrWasmModuleAsync</code> to <code>await</code> on blocking C code</li> <li>getting and print characters to a <code>div</code> tag using twr-wasm <code>class twrConsoleDiv</code></li> </ul>"},{"location":"examples/examples-divcon/#running-examples-and-source","title":"Running Examples and Source:","text":"<ul> <li>view divcon example running live</li> <li>View divcon source code</li> </ul>"},{"location":"examples/examples-divcon/#screen-grab-of-square-calculator","title":"Screen Grab of Square Calculator","text":""},{"location":"examples/examples-divcon/#c-code","title":"C Code","text":"divcon.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"twr-crt.h\"\n\nvoid stdio_div() {\n    char inbuf[64];\n    char *r;\n    int i;\n\n    printf(\"Square Calculator\\n\");\n\n    while (1) {\n        printf(\"Enter an integer: \");\n        r=twr_mbgets(inbuf);  // r is NULL if esc entered.  Otherwise r == inbuf\n        if (r) {  \n            i=atoi(inbuf);\n            printf(\"%d squared is %d\\n\\n\",i,i*i);\n        }\n        else {\n            printf(\"\\n\");\n        }\n    }\n}\n</code></pre>"},{"location":"examples/examples-divcon/#html-code","title":"HTML Code","text":"<p>We are using <code>twrWasmModuleAsync</code> which integrates blocking C code into JavaScript.  <code>twrWasmModuleAsync</code> can also be used to receive key input from a <code>&lt;div&gt;</code> or <code>&lt;canvas&gt;</code> tag. </p> index.html<pre><code>&lt;body&gt;\n   &lt;div id=\"stdioDiv\" \n        tabindex=\"0\" \n        style=\"color: DarkGreen; background-color: LightGray; font-size: 18px;font-family: Arial, sans-serif;\" &gt;\n        Loading... &lt;br&gt;\n   &lt;/div&gt;\n\n   &lt;script type=\"module\"&gt;\n      import {twrWasmModuleAsync, twrConsoleDiv} from \"twr-wasm\";\n\n      const con = new twrConsoleDiv(document.getElementById(\"stdioDiv\"));\n      const amod = new twrWasmModuleAsync({stdio: con});\n\n      // remove 'Loading...'\n      document.getElementById(\"stdioDiv\").innerHTML =\"&lt;br&gt;\"; \n      // send key events to twrConsoleDiv\n      document.getElementById(\"stdioDiv\").addEventListener(\"keydown\",(ev)=&gt;{con.keyDown(ev)});\n\n      await amod.loadWasm(\"./divcon.wasm\");\n      await amod.callC([\"stdio_div\"]);\n\n   &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"examples/examples-fft/","title":"FFT - Example of using C FFT with HTML/JavaScript","text":"<p>This example is a demo of integrating the popular KISS FFT C library with TypeScript/JavaScript/HTML using WebAssembly.  The FFT C library is compiled into a Wasm (WebAssembly) module using clang, with the help of twr-wasm.   The FFT Wasm module is used by the HTML page to calculate the FFT.  The FFT input and output is drawn to the web page using JavaScript canvas functions.  </p> <p>The FFT library exposes APIs to process data, and doesn't use stdio.</p> <p>The FFT APIs use float32 arrays for complex-number input and output data, and a configuration C struct.   In the example I generate the input data by adding a 1K and 5K sine waves, call the kiss FFT API to perform the FFT on the generated sine waves, and then graph the input and output data using a JavaScript Canvas.</p> <ul> <li>View example running on the web</li> <li>View example source code</li> </ul>"},{"location":"examples/examples-fft/#screen-grab-of-output","title":"Screen Grab of Output","text":""},{"location":"examples/examples-fft/#code","title":"Code","text":"<p>Here is part of the code. The rest can be found on github.</p> <p>index.html<pre><code>&lt;head&gt;\n    &lt;title&gt;Fast Fourier transform (FFT)&lt;/title&gt;\n&lt;/head&gt;\n&lt;body style=\"background-color:white\"&gt;\n\n    &lt;br&gt;\n\n    &lt;div style=\"font:24px arial\"&gt;Input Signal&lt;/div&gt;\n    &lt;canvas id=\"c-input\" width=\"1024\" height=\"300\" style=\"background-color:lightgray\"&gt;&lt;/canvas&gt;\n\n    &lt;br&gt;&lt;br&gt;&lt;br&gt;\n\n    &lt;div style=\"font:24px arial\"&gt;FFT Output&lt;/div&gt;\n    &lt;canvas id=\"c-output\" width=\"1024\" height=\"300\" style=\"background-color:lightgray\"&gt;&lt;/canvas&gt;\n\n    &lt;script type=\"module\"&gt;\n        import {fftDemo} from \"./fft-script.js\";\n\n        fftDemo();\n\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre> fft-script.js<pre><code>import {twrWasmModule} from \"twr-wasm\";\n\nexport async function fftDemo() {\n\n    const mod=new twrWasmModule();\n\n    // load the kiss_fft C code as is, unmodified\n    await mod.loadWasm('kiss_fft.wasm');\n\n    //  kissFFTData stores and graphs the input and output data\n    //  in this example the fft has 1024 bins, and I am using a 48K sampling rate\n    let fft=new kissFFTData(1024, 48000);\n    fft.genSin(1000)\n    fft.addSin(5000)\n    fft.graphIn(\"c-input\");\n\n    // see kiss_fft README, but in summary you: (a) alloc config, (b) compute the FFT, (c) free the config\n    // kiss_fft_alloc() returns a malloced structure.  Pointers are numbers (index into Wasm module memory) in JS land \n    //\n    //kiss_fft_cfg cfg = kiss_fft_alloc( nfft ,is_inverse_fft ,0,0 );\n    let cfg:number = await mod.callC([\"kiss_fft_alloc\", fft.nfft, 0, 0, 0 ]);\n\n    // The FFT input and output data are C arrays of complex numbers.\n    // typedef struct {\n    //    kiss_fft_scalar r;\n    //    kiss_fft_scalar i;\n    // } kiss_fft_cpx;\n    //\n    // /*  default is float */\n    // define kiss_fft_scalar float\n\n    // So if the FFT data has 1024 bins, then 1024 * 2 floats (r &amp; i) * 4 bytes per float are needed.\n    // I use a JS Float32Array view on the ArrayBuffer to access the floats\n\n    // When an arrayBuffer is passed in as an argument to mod.callC,\n    // callC will malloc memory in the Wasm module of a size that matches the array buffer, then\n    // copy the arraybuffer into the malloc'd memory prior to the function call, \n    // then copy the malloc'd memory contents back into the arrayBuffer post call.\n    // The malloc'd memory is free'd post call. \n\n    // void kiss_fft(kiss_fft_cfg cfg,const kiss_fft_cpx *fin,kiss_fft_cpx *fout);\n    await mod.callC([\"kiss_fft\", cfg, fft.inArrayBuf, fft.outArrayBuf]);\n\n    fft.graphOut(\"c-output\");\n\n    await mod.callC([\"free\", cfg]);      // not much point to this since all the module memory is about to disappear\n}\n</code></pre></p>"},{"location":"examples/examples-helloworld/","title":"Hello World - WebAssembly C Example","text":"<p>This example is a very simple twr-wasm program.  It uses WebAssembly and C to print \"hello, world!\" to an HTML <code>&lt;div&gt;</code> tag.</p> <p>Also see: Hello World - Step-by-Step C to Wasm.</p> <ul> <li>View helloworld example running live</li> <li>View helloworld source code</li> </ul>"},{"location":"examples/examples-lib/","title":"class twrLibrary Example","text":""},{"location":"examples/examples-lib/#what-it-does","title":"What It Does","text":"<p>This example is a twr-wasm Library that implements functions that can be called by your C/C++ code.  A twr-wasm Library is written in TypeScript, and derives from the class twrLibrary.</p> <p>The lib example demos:</p> <ul> <li>Creating functions in TypeScript that can be called from C/C++</li> <li>Posting Events to C</li> <li>Implementing blocking as well as non-blocking functions</li> </ul>"},{"location":"examples/examples-lib/#running-examples-and-source","title":"Running Examples and Source:","text":"<ul> <li>View lib output </li> <li>Source for lib </li> </ul> <p>Also see  twr-wasm Libraries Documentation</p>"},{"location":"examples/examples-libcxx/","title":"tests-libcxx - WebAssembly libc++ Smoke Test","text":"<p>This is a simple test of various libc++ functions using WebAssembly with twr-wasm.  The C++ program links with libc++. An example makefile is provided.</p> <ul> <li>view tests-libcxx example running live</li> <li>View tests-libcxx source code</li> </ul> <p>Also see this WebAssembly program that uses libc++ with twr-wasm to implement a CLI console.</p> <ul> <li>tests-user Live</li> <li>tests-user Source</li> </ul>"},{"location":"examples/examples-maze/","title":"Maze Generator/Solver","text":"<p>This example is a port to Wasm of a 20 year old Win32 C Maze creator,  with the help of twr-wasm 2D Draw APIs.</p> <ul> <li>View live maze here</li> <li>Source for maze</li> </ul>"},{"location":"examples/examples-maze/#screen-grab-of-output","title":"Screen Grab of Output","text":""},{"location":"examples/examples-maze/#overview","title":"Overview","text":"<p>This Maze generator uses the twr-wasm \"d2d\" (Draw 2D) C APIs.  These allow drawing onto an HTML canvas from C/C++.  (Also see the balls C++ example).</p> <p>This C code is interesting in that it is a combination of blocking and non blocking functions.  The <code>CalcMaze</code> function is blocking when the \"slow draw\" flag is set.  It uses <code>Sleep</code> in this case.   For this reason, I use twrWasmModuleAsync.   The solve section uses repeated calls to <code>SolveStep</code>, which works well with a JavaScript main loop.  I used a javascript interval timer to make repeated calls to the C <code>SolveStep</code> function.  If all the C code was structured this way, <code>twrWasmModule</code> could have been used (instead of the Async version)</p> <p>To port this code to twr-wasm I wrote a (very tiny) Win32 compatible API (in winemu.c/winemu.h).  It only implements the features needed to port Maze, but it might be useful to use as a starting point for porting your Win32 code to the web.  </p> index.html<pre><code>&lt;head&gt;\n    &lt;title&gt;Maze&lt;/title&gt;\n&lt;/head&gt;\n&lt;body style=\"background-color:powderblue\"&gt;\n    &lt;canvas id=\"twr_d2dcanvas\" width=\"600\" height=\"600\"&gt;&lt;/canvas&gt;\n\n    &lt;script type=\"module\"&gt;\n        import {mazeRunner} from \"./maze-script.js\";\n\n        mazeRunner();\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre> maze-script.js<pre><code>import {twrWasmModuleAsync} from \"twr-wasm\";\n\nexport async function mazeRunner() {\n\n    const amod=new twrWasmModuleAsync();\n\n    await amod.loadWasm('maze.wasm');\n\n    //void CalcMaze(HWND hWnd, LONG cell_size, LONG is_black_bg, LONG isd - slow draw)\n    await amod.callC([\"CalcMaze\", 0, 7, 0, 1]);\n    await amod.callC([\"SolveBegin\"]);\n\n    let timer = setInterval(async ()=&gt;{\n        let isdone=await amod.callC([\"SolveStep\", 0]);  //SolveStep(hwnd))\n        if (isdone) clearInterval(timer);\n    }, 50);\n}\n</code></pre>"},{"location":"examples/examples-multi-io/","title":"Multi-io Multiple Console Example","text":""},{"location":"examples/examples-multi-io/#what-it-does","title":"What It Does","text":"<p>This example demos six simultaneous consoles:</p> <ul> <li>Two character streaming consoles directed to a <code>&lt;div&gt;</code> tag</li> <li>Two character terminal consoles directed to a <code>&lt;canvas&gt;</code> tag </li> <li>Two 2D draw surface consoles directed to a <code>&lt;canvas&gt;</code> tag</li> </ul> <p>The multi-io example also demos:</p> <ul> <li>Creating consoles in JavaScript/TypeScript</li> <li>Using consoles in C/C++ and JavaScript/TypeScript</li> <li>Mixing multiple Consoles</li> <li>Using multiple .wasm modules using the same console</li> <li>Inputting, printing, and drawing to consoles</li> </ul>"},{"location":"examples/examples-multi-io/#running-examples-and-source","title":"Running Examples and Source:","text":"<ul> <li>View multi-io </li> <li>Source for multi-io </li> </ul> <p>Also see  Console Introduction</p>"},{"location":"examples/examples-overview/","title":"WebAssembly C/C++ Examples","text":""},{"location":"examples/examples-overview/#overview","title":"Overview","text":"<p>These C and C++ examples demonstrate how to create different types of WebAssembly (wasm) programs with the twr-wasm library.</p> <p>These are good examples to use as starting points for your own Wasm projects.</p> <p>These examples are a good place to learn how to configure clang and wasm-ld to compile and link C/C++ code for use with WebAssembly (wasm).</p>"},{"location":"examples/examples-overview/#example-quick-links","title":"Example Quick Links","text":"<ul> <li>Click here to view C/C++ WebAssembly twr-wasm examples running live</li> <li>Click here to view source code and make files</li> </ul>"},{"location":"examples/examples-overview/#hello-world","title":"Hello World","text":"Name Description Link helloworld A very simple C Wasm example to get you started helloworld"},{"location":"examples/examples-overview/#console-examples","title":"Console Examples","text":"Name Description Link divcon A simple C program demos inputting and printing characters to a <code>div</code> tag divcon terminal A simple C program demos writing and inputting from a <code>&lt;canvas&gt;</code> tagthat twr-wasm configures as a windowed \"terminal\" terminal multi-io Demo 6 simultaneous consoles: stream i/o, terminal, and 2D Drawing. multi-io"},{"location":"examples/examples-overview/#draw-2d-and-audio-examples","title":"Draw 2D and Audio Examples","text":"Name Description Link balls These fun Bouncing Balls are written in C++ and demo the 2D drawingAPIs with a C++ Canvas wrapper class balls pong A simple game of Pong written in C++ to demo 2D drawing and Audio APIs witha C++ canvas wrapper class and taking user input from JS pong maze This is an old Win32 program ported to wasm and demos 2D Draw APIs maze"},{"location":"examples/examples-overview/#call-argument-examples","title":"Call Argument Examples","text":"Name Description Link callC A demo of passing and returning values between JavaScript and Wasm module callc fft A demo of calling a C library to perform an FFT that is graphed in TypeScript fft"},{"location":"examples/examples-overview/#twrlibrary-examples","title":"twrLibrary Examples","text":"Name Description Link lib A demo of createing a twrLibrary (use TypeScript to create C/C++ APIs) library"},{"location":"examples/examples-overview/#unit-tests","title":"Unit Tests","text":"Name Description Link tests twr-wasm unit tests tests tests-user \"cli\" for tests using libc++ and <code>&lt;canvas&gt;</code> tests-user tests-libcxx Smoke test for libc++.  Shows how to use libc++. tests-libcxx tests-d2d Unit tests for Draw 2D canvas console tests-d2d tests-audio Unit tests for the Audio Library tests-audio"},{"location":"examples/examples-overview/#running-or-building-the-examples-locally","title":"Running or Building the examples locally","text":"<p>Online versions of the examples can be viewed here. </p> <p>You can also run the examples locally, or build them..</p>"},{"location":"examples/examples-overview/#copying-examples-to-start-your-own-project","title":"Copying Examples to Start your own Project","text":"<p>All of the examples have makefiles that use a relative path for <code>twr.a</code> and <code>includes</code>. These paths will work fine if your code is in an examples sub-folder as a peer to the other examples.  But assuming your code is in your own project folder elsewhere, you will need to determine the correct path to <code>twr.a</code> and <code>includes</code> for your project's makefile.  Details on how to do this can be found in the following sections: Hello World walk through and the Compiler and Linker Options section.</p> <p>Also see the section on Import Resolution if you installed with <code>git clone.</code></p>"},{"location":"examples/examples-pong/","title":"Pong - 2D Game Example","text":"<p>Similar to the balls example, this example uses twr-wasm's 2D Draw API and a C++ canvas class to implement a simple game of 2 player and single player Pong with WebAssembly.</p> <ul> <li>View Pong</li> <li>Source for Pong</li> </ul> <p>The Pong example demonstrates</p> <ul> <li>C++</li> <li>Using twr-wasm draw 2D APIs that match Javascript Canvas APIs.</li> <li>Using the twr-wasm canvas.cpp class.</li> <li>A custom typescript library</li> <li>User mouse and keyboard input via events</li> <li>Using the Audio Library to play simple sounds</li> </ul> <p>This example does not use libc++, which results in smaller code size.   For an example that uses libc++ see tests-libcxx.</p>"},{"location":"examples/examples-pong/#screen-grab-of-pong-example","title":"Screen Grab of Pong Example","text":""},{"location":"examples/examples-terminal/","title":"Terminal Console Demo","text":"<p>A simple WebAssembly C \"terminal\" is demoed with input and output directed to an HTML <code>&lt;canvas&gt;</code> tag.</p>"},{"location":"examples/examples-terminal/#what-it-does","title":"What it Does","text":"<ul> <li>uses class twrConsoleTerminal, a Console </li> <li>moves a string up or down in the terminal window when you press the u or d or arrow keys.</li> <li>shows basic color usage</li> <li>draws a graphic box around the terminal window.</li> </ul>"},{"location":"examples/examples-terminal/#run-and-view-the-code","title":"Run and View the Code","text":"<ul> <li>View terminal example running live</li> <li>View terminal source code</li> <li>For another 'terminal' demo View tests-user</li> </ul>"},{"location":"examples/examples-terminal/#screen-grab-of-terminal","title":"Screen Grab of Terminal","text":""},{"location":"examples/examples-tests-audio/","title":"tests-audio - Unit tests for Audio Library","text":"<p>This is a simple set of Unit Tests for testing the Audio API functions. It includes a test for each Audio function. WARNING: Some of the audio played can be loud, so turn down your volume before playing.</p> <ul> <li>view tests-audio example running live</li> <li>View tests-audio source code</li> </ul> <p>Also see these WebAssembly programs that use this API</p> <ul> <li>Pong</li> </ul>"},{"location":"examples/examples-tests-d2d/","title":"tests-d2d - Unit tests for Draw 2D canvas console","text":"<p>This is a simple set of Unit Tests for testing the D2D API functions. It includes a test for each D2D function as well as a test for memory leaks within the API itself.</p> <ul> <li>view tests-d2d example running live</li> <li>View tests-d2d source code</li> </ul> <p>Also see these WebAssembly programs that use this API</p> <ul> <li>Balls</li> <li>Pong</li> </ul>"},{"location":"gettingstarted/basicsteps/","title":"Basic Steps To Create Your Wasm Project","text":"<p>This section describes the basic steps to integrate your TypeScript/JavaScript with C/C++ WebAssembly code.</p>"},{"location":"gettingstarted/basicsteps/#overview-of-webassembly-project","title":"Overview of WebAssembly Project","text":"<p>Your C/C++ WebAssembly project consists of HTML (and related JavaScript or TypeScript) and C/C++ source.  The C/C++ is compiled using <code>clang</code> into a <code>.wasm</code> binary module.  The <code>.wasm</code> module is loaded as a WebAssembly module by your JavaScript using <code>twr-wasm</code>.</p>"},{"location":"gettingstarted/basicsteps/#javascripttypescript-part-of-wasm-project","title":"JavaScript/TypeScript Part of Wasm Project","text":"<p>On the JavaScript side of your WebAssembly project you will use the twr-wasm JavaScript/TypeScript class <code>twrWasmModule</code> or <code>twrWasmModuleAsync</code> to load the <code>.wasm</code> module, and then call C functions in it using <code>callC</code> (more details are in the TypeScript/Javascript API section).</p>"},{"location":"gettingstarted/basicsteps/#cc-part-of-wasm-project","title":"C/C++ Part of Wasm Project","text":"<p>You will call C functions (or C++ with ' extern \"C\" ' linkage) in the <code>.wasm</code> module from your JavaScript.  You can also call JavaScript functions from your C/C++ code, but this is less common.</p> <p>There is no direct equivalent to a C \"main\".  Instead, a Wasm module provides exported C functions that you can call from JavaScript/TypeScript.  A Wasm module is more like a runtime loaded dynamic library.</p> <p><code>twr-wasm</code> supports C/C++ code that is either asynchronous (non-blocking) or syncronous (blocking).  A CLI app is an example of typical blocking code.  A CLI app typically blocks waiting for keyboard input (blocking means that it \"takes a long time\" to return).  If your C code is a big loop that never returns, that would be very blocking.  Alternately,if you send mouse events to C code, have the code process them then return, this would be non-blocking.    You can use the twr-wasm class <code>twrWasmModuleAsync</code> to execute blocking code from JavaScript or <code>twrWasmModule</code> to integrate asynchronous C/C++ code. The example maze demonstrates both non-blocking and blocking C calls.</p> <p>See the examples of different types of C/C++ apps.</p>"},{"location":"gettingstarted/basicsteps/#steps-to-integrate-c-code-with-javascript-code","title":"Steps to integrate C code with JavaScript code","text":"<p>Here are the general steps to integrate your C with your JavaScript:</p> <ol> <li>Compile your C code with <code>clang</code> and link with <code>wasm-ld</code> to create the <code>.wasm</code> file.</li> <li>On the JavaScript side you:<ol> <li>Access <code>twr-wasm</code> \"ES\" modules in the normal way with <code>import</code>. </li> <li>Add a <code>&lt;div id=twr_iodiv&gt;</code> or <code>&lt;canvas id=twr_iocanvas&gt;</code> to your HTML (see stdio)</li> <li>Use <code>new twrWasmModule</code>, followed by a call to <code>loadWasm</code>, then one or more <code>callC</code>.</li> <li>Alternately, use <code>twrWasmModuleAsync</code> -- which is interchangeable with <code>twrWasmModule</code>, but proxies through a worker thread, which allows you to call blocking functions from the asynchronous JavaScript main thread.</li> <li>For more details, see the remainder of this documentation, or see the hello world or other exampes.</li> </ol> </li> </ol>"},{"location":"gettingstarted/charencoding/","title":"Character Encoding Support with twr-wasm","text":"<p>This section explains twr-wasm's WebAssembly support for ASCII, UTF-8, windows-1252, and UTF-32 character encoding.</p>"},{"location":"gettingstarted/charencoding/#getting-started","title":"Getting Started","text":"<p>When using C with twr-wasm, you will likely want to add this line to the start of your code: <pre><code>setlocale(LC_ALL, \"\")\n</code></pre></p> <p>This will change the C locale language to the one selected in the browser, and will enable consistent UTF-8 character encoding support.</p> <p>Without this line, the standard C runtime will default character encoding to ASCII, as per the std c lib standard.  However, just as with gcc, twr-wasm consoles support outputting UTF-8, even in the default setting.</p>"},{"location":"gettingstarted/charencoding/#character-encodings","title":"Character Encodings","text":"<p>twr-wasm supports ASCII, UNICODE, and extended-ASCII (in the form of Windows-1252).</p>"},{"location":"gettingstarted/charencoding/#utf-8","title":"UTF-8","text":"<p>These days UNICODE with UTF-8 encoding is the most popular method of displaying and encoding text. UTF-8 is popular because it has the deep character glyph definitions of UNICODE with an encoding that provides (a) the best backwards compatibility with ASCII, and (b) a compact memory footprint.  It does this at the expense of some multibyte complexities.</p> <p>UTF-8 is variable length, and uses between one to four bytes to represent any unicode code point, with ASCII compatibility in the first 128 characters.  It is also the standard for the web, and the default for clang. But because UTF-8 uses a variable number of bytes per character it can make string manipulation in C a bit harder than ASCII, Windows-1252 or UTF-32.</p>"},{"location":"gettingstarted/charencoding/#locale","title":"Locale","text":"<p>In this document you will see the term \"locale\". This term originated (at least as its commonly used in programming) in the standard C library, and is also used in the standard C++ library (libc++ in twr-wasm).  A locale refers to a region of the world, along with a specific character encoding. The twr-wasm standard c runtime uses a label akin to this to define a locale: <code>en-US.UTF-8</code>. Of note is that libc++ and the standard C runtime have different domains for their locales (ie, they don't directly impact each other).  You can learn more about locales by searching the internet. </p> <p>twr-wasm C locales support ASCII, UTF-8 or windows-1252 character encoding.  </p>"},{"location":"gettingstarted/charencoding/#utf-32","title":"UTF-32","text":"<p>UTF-16/32 are not supported as a std c lib locale setting, but functions are provided to convert utf-32 (unicode code points) to and from ASCII, UTF-8, and windows-1252 \"code pages\" (there are other miscellaneous utf-32 based functions as well.)</p> <p>You can also use libc++, which has classes that directly support utf-16 and utf-32.</p>"},{"location":"gettingstarted/charencoding/#windows-compatibility-with-windows-1252","title":"Windows Compatibility with Windows-1252","text":"<p>Windows-1252 is the default character encoding on Windows computers in many countries - particularly the Americas and western Europe -- and particularly when using MSVC. Linux, clang, gcc, and the web commonly default in some way to UTF-8 character encoding.  Windows-1252 is an extension of ASCII that uses a single byte per character.  This makes it easier than UTF-8 from a programmers perspective, but it doesn't represent as many characters. It is supported by twr-wasm to make it easier to port legacy C code, windows code, as well as a simpler alternative to UTF-8.</p> <p>twr-wasm supports Windows-1252, and you can enable it like this:</p> <pre><code>setlocale(LC_ALL, \".1252\")\n</code></pre> <p>This will set the locale to the default browser language, and character encoding to Windows-1252.</p> <p>1252 String Literals These days text editors generally default to UTF-8.  In order to use windows-1252  source code and/or string literals, such as <code>const char * str=\"\u20ac100\"</code> you may need to: </p> <ul> <li>Configure your text editor to save in Windows-1252/ISO-8859-1 format (instead of UTF-8)</li> <li>use compiler flags like <code>--finput-charset</code> and <code>-fexec-charset</code></li> </ul> <p>By default, the Microsoft Visual Studio C compiler (MSVC) does not treat string literals as UTF-8. Instead, it treats them as being encoded in the current code page of the system, which is typically Windows-1252 on western european language Windows systems.  twr-wasm is designed to work with clang, which does default to utf-8, so if you are compiling code written for MSVC, and you use extend character sets (non ASCII), you may need to adjust your compiler settings with the flags mentioned above.</p>"},{"location":"gettingstarted/charencoding/#more","title":"More","text":"<p>For more details see Localization Reference for twr-wasm</p>"},{"location":"gettingstarted/compiler-opts/","title":"Compiling, Linking, and Memory Options","text":"<p>This section describes how to use <code>clang</code> to compile C/C++ code for WebAssembly, and how to use <code>wasm-ld</code> to link your files into a .wasm module, when using twr-wasm.</p> <p>twr-wasm lets you use clang directly, without a wrapper.  This section describes the needed clang compile options and the wasm-ld link options.  You can also take a look at the example makefiles.</p>"},{"location":"gettingstarted/compiler-opts/#compiler-notes","title":"Compiler Notes","text":"<p>twr-wasm has been tested with clang 17.0.6 and wasm-ld 17.0.6.</p> <p>If you are using nix, the default clang packages are wrapped with flags that break compilation. The following packages don't have this issue:</p> <ul> <li>llvmPackages_18.clang-unwrapped (clang 18.1.7)</li> <li>llvmPackages_17.clang-unwrapped (clang 17.0.6)</li> </ul>"},{"location":"gettingstarted/compiler-opts/#c-clang-compiler-options","title":"C clang Compiler Options","text":"<p>When compiling C code with clang for use with Wasm and twr-wasm, use these clang options: <pre><code> --target=wasm32 -nostdinc -nostdlib -isystem  ../../include\n</code></pre></p> <p>Here is an example of a compile command: <pre><code>clang --target=wasm32 -nostdinc -nostdlib -isystem ./node_modules/twr-wasm/include -c  helloworld.c -o helloworld.o\n</code></pre></p> <p><code>-isystem</code> should be adjusted to point to where the folder <code>twr-wasm/include</code> is installed. For example:</p> <ul> <li><code>../../include</code> is a relative link to <code>include</code> that works if your project is a sub folder in the <code>examples</code> folder. </li> <li><code>./node_modules/twr-wasm/include</code> assumes you installed with <code>npm</code> into your project folder. (see the Hello World Walk Through).</li> </ul>"},{"location":"gettingstarted/compiler-opts/#c-clang-compiler-options_1","title":"C++ clang Compiler Options","text":"<p>When compiling C++ code with clang for use with Wasm and twr-wasm, use these clang options: <pre><code> --target=wasm32 -fno-exceptions -nostdlibinc -nostdinc -nostdlib -isystem  ../../include\n</code></pre></p>"},{"location":"gettingstarted/compiler-opts/#wasm-ld-linker-options","title":"wasm-ld Linker Options","text":"<p>Use the wasm-ld linker directly with twr-wasm.</p> <p>For example: <pre><code>wasm-ld  helloworld.o ./node_modules/twr-wasm/lib-c/twr.a -o helloworld.wasm  --no-entry --initial-memory=131072 --max-memory=131072 --export=hello \n</code></pre></p> <p>For C and C++ link to <code>twr.a</code> to link to the twr-wasm library.</p> <p>For C++ link to <code>libc++.a</code> if you are using libc++. (see the tests-libcxx example makefile).</p> <p>Be sure to adjust the path to <code>twr.a</code> and <code>libc++.a</code> as needed to the location where <code>twr-wasm/lib-c/</code> is installed. </p> <p>All of the twr-wasm functions are staticly linked from the library <code>lib-c/twr.a</code>.  There is also a version ( <code>lib-c/twrd.a</code> ) of twr-wasm library available with debug symbols.  One of these two static libraries should be added to the list of files to link (normally this is <code>twr.a</code>).  Both versions are built with asserts enabled.  <code>twr.a</code> is built with <code>-O3</code>.  <code>twrd.a</code> is built with <code>-g -O0</code>.</p> <p>C functions that you wish to call from JavaScript should either have an <code>-export</code> option passed to <code>wasm-ld</code>, or you can use the <code>__attribute__((export_name(\"function_name\")))</code> option in your C function definition.</p> <p>All exported functions to JavaScript should be C linkage (<code>extern \"C\"</code> if using C++).</p> <p>wasm-ld should be passed the following options:</p> <p>If Using twrWasmModule: <pre><code>--no-entry --initial-memory=&lt;size&gt; --max-memory=&lt;size&gt;\n</code></pre></p> <p>If Using twrWasmModuleAsync: <pre><code>--no-entry --shared-memory --no-check-features --initial-memory=&lt;size&gt; --max-memory=&lt;size&gt;\n</code></pre></p>"},{"location":"gettingstarted/compiler-opts/#memory-options-memory-size-stack-size-etc","title":"Memory Options (Memory Size, Stack Size, etc)","text":"<p><code>WebAssembly.Memory</code> contains all the data used by your code (including the data needs of staticly linked libraries such as twr-wasm or libc++), but it does not store your actual code. It provides a contiguous, mutable array of raw bytes. Code execution and storage in WebAssembly are handled separately using the <code>WebAssembly.Module</code> and <code>WebAssembly.Instance</code> objects. The code (compiled WebAssembly instructions) is stored in the <code>WebAssembly.Module</code>, while <code>WebAssembly.Memory</code>is used to manage the linear memory accessible to the WebAssembly instance for storing data. Examples of data include your static data (.bss section or the .data section), the heap (used by <code>malloc</code> and <code>free</code>), and the stack (used for function calls and local variables).</p> <p>The memory size should be a multiple of 64*1024 (64K) chunks. \"initial-memory\" and \"max-memory\" should be set to the same number since there is no support for automatically growing memory in twr-wasm.  The memory is an export out of the <code>.wasm</code> into the JavaScript code -- you should not create or set the size of <code>WebAssembly.Memory</code> in JavaScript when using twr-wasm.</p> <p>You set the memory size for your module (<code>WebAssembly.Memory</code>) using <code>wasm-ld</code> options as follows (this examples sets your Wasm memory to 1MB).</p>"},{"location":"gettingstarted/compiler-opts/#twrwasmmodule","title":"twrWasmModule","text":"<p>if using <code>twrWasmModule</code>: <pre><code>--initial-memory=1048576 --max-memory=1048576\n</code></pre></p>"},{"location":"gettingstarted/compiler-opts/#twrwasmmoduleasync","title":"twrWasmModuleAsync","text":"<p>If you are using <code>twrWasmModuleAsync</code>, shared memory must also be enabled. Like this: <pre><code>--shared-memory --no-check-features --initial-memory=1048576 --max-memory=1048576\n</code></pre></p> <p>See this note on CORS headers with shared memory.</p>"},{"location":"gettingstarted/compiler-opts/#stack-size","title":"Stack Size","text":"<p>You can change your C/C++ stack size from the default 64K with the following <code>wasm-ld</code> option.   This example sets the stack at 128K <pre><code> -z stack-size=131072\n</code></pre></p>"},{"location":"gettingstarted/compiler-opts/#print-memory-map","title":"Print Memory Map","text":"<p>You can print your module memory map, heap stats, and stack size using the function from C: <pre><code>void twr_mem_debug_stats(twr_ioconsole_t* outcon);\n</code></pre> You can call it from Javascript with the output sent to the debug console (stderr) like this: <pre><code>twrWasmModule/Async.callC([\"twr_wasm_print_mem_debug_stats\"])\n</code></pre></p>"},{"location":"gettingstarted/compiler-opts/#typescriptjavascript-malloc-and-memory-access","title":"TypeScript/JavaScript malloc and Memory Access","text":"<p><code>twrWasmModule</code> and <code>twrWasmModuleAsync</code> expose <code>malloc</code> as an async function, as well as the WebAssembly Module memory as: <pre><code>async malloc(size:number);\n\nmemory?:WebAssembly.Memory;\nmem8:Uint8Array;\nmem32:Uint32Array;\nmemD:Float64Array;\n</code></pre> to call <code>free</code> from JavaScript (you probably won't need to), you can use: <pre><code>twrWasmModule/Async.callC([\"twr_free\", index]);  // index to memory to free, as returned by malloc\n</code></pre></p> <p>more information on these functions and module public variables can be found in the examples in this section:  Passing Function Arguments to WebAssembly.</p>"},{"location":"gettingstarted/debugging/","title":"Debugging WebAssembly","text":"<p>This section describes tips for debugging your WebAssembly (Wasm) program.  Some of these techniques are WebAssembly generic, some are specific to using twr-wasm.</p>"},{"location":"gettingstarted/debugging/#debug-and-release-libraries","title":"Debug and Release libraries","text":"<p>There are release (twr.a) and debug (twrd.a) versions of the twr-wasm C library.  The \"debug\" version has debug symbols enabled with <code>-g</code> and is built with optimizations disabled via <code>-O0</code>.  The \"release\" version has no debug symbols and optimization is set to <code>-O3</code>.  Both have asserts enabled.  In general, you should use the \"release\" version unless you wish to step through the twr-wasm source -- in which case use the \"debug\" version.</p> <p>libc++.a is not built with debug symbols.</p>"},{"location":"gettingstarted/debugging/#source-level-debugging-webassembly-cc","title":"Source Level Debugging WebAssembly C/C++","text":"<p>In order to enable C/C++ source debugging with Wasm and clang, do the following:</p> <ol> <li>Use Chrome</li> <li>Install the Chrome extension: C/C++ DevTools Support (DWARF)</li> <li>Use the clang compile flag -g to add debug annotation to your object files</li> <li>You may want to turn off optimization to allow the debugger to have a bit more logical behavior (remove the <code>-O</code> flag or set to <code>-O0</code>) </li> <li>You may want to use the version of the twr-wasm C library that has debug symbols enabled (twrd.a).  Only if you want to step into the twrd.a source.</li> <li>You need to serve your files with a (likely local) web server.  </li> <li>For example, 'python server.py' is provided.  'server.py' can be found in the examples root folder.  Note that your local server needs to enable SharedArrayBuffers if you are using <code>twrWasmModuleAsync</code> -- see these CORS notes.</li> <li>your code can be bundled or unbundled, but</li> <li>you need to ensure that the web server/browser can find the source code</li> <li>also see Example Readme</li> </ol>"},{"location":"gettingstarted/debugging/#resolving-imports","title":"Resolving Imports","text":"<p>If you are having issues with import resolution, see this section.</p>"},{"location":"gettingstarted/debugging/#useful-twr-wasm-debug-functions","title":"Useful twr-wasm Debug Functions","text":"<p>Use <code>twr_conlog</code> to print to the JavaScript console from C (see API ref section). <pre><code>#include \"twr-crt.h\"\n\ntwr_conlog(\"hello 99 in hex: %x\",99);\n</code></pre></p> <p>Inside JavaScript, you can print to a console using the <code>putStr</code> console member function that is available on all consoles.</p> <p>For example: <pre><code>const stream1 = new twrConsoleDiv(stream1Element);\nstream1.putStr(`Hello stream1 of type ${stream1.getProp(\"type\")} from JavaScript!\\n`);\n</code></pre></p>"},{"location":"gettingstarted/debugging/#testing-webassembly-without-a-web-server","title":"Testing WebAssembly Without a Web Server","text":"<p>Note: If you use this technique, you will not be able to get the C/C++ DevTool chrome extension to run, and so source level debugging won't work. (If you know how to fix this, please contact me on github.)</p> <p>You can execute and debug JavaScript with Wasm from local files without an HTTP server.  It might be helpful to download the twr-wasm source code from github when you do this (so you can step through the twr-wasm typescript code as needed).</p> <p>See the examples and Example Readme for more detail on how this works.</p> <p>In general, you will need to add a clip of code similar to this to your HTML: <pre><code>&lt;script type=\"importmap\"&gt;\n   {\n      \"imports\": {\n      \"twr-wasm\": \"./../../lib-js/index.js\"\n      }\n   }\n&lt;/script&gt;\n</code></pre></p> <p>Make sure the paths to  <code>twr-wasm/lib-js/index.js</code> are correct for where your source is located.  The above is correct for the provided examples.</p> <p>You will need to set the following flags when running chrome from the shell or VS Code (the first is only strictly required if using twrWasmModuleAsync).</p> <pre><code>--enable-features=SharedArrayBuffer\n--allow-file-access-from-files\n</code></pre> <p>If you are using VS Code, You can create a launch.json entry similar to this:</p> launch.json<pre><code>{\n    \"configurations\": [\n    {\n        \"name\": \"Launch Chrome\",\n        \"request\": \"launch\",\n        \"type\": \"chrome\",\n        \"runtimeArgs\": [\n            \"--allow-file-access-from-files\",\n            \"--autoplay-policy=no-user-gesture-required\",\n            \"--enable-features=SharedArrayBuffer\"\n         ],\n         \"file\": \"${workspaceFolder}/index.html\",\n         \"cwd\": \"${workspaceFolder}/\",\n    }\n    ]\n}\n</code></pre>"},{"location":"gettingstarted/events/","title":"Overview of Events","text":"<p>This section describes how to use twr-wasm to:</p> <ul> <li>register event callbacks in C/C++</li> <li>use events in C/C++</li> </ul>"},{"location":"gettingstarted/events/#quick-example","title":"Quick Example","text":"timer events<pre><code>#include &lt;stdio.h&gt;\n#include \"twr-crt.h\"\n\nint t2_count=0;\nint t2_id;\n\n// timer2 event callback (called multiple times)\n__attribute__((export_name(\"on_timer2\")))\nvoid on_timer2(int event_id) {\n   t2_count++;\n   printf(\"timer callback 2 entered (event id=%d, count=%d)\\n\", event_id, t2_count);\n\n   if (t2_count==5) {\n      twr_timer_cancel(t2_id);\n      printf(\"timer example complete\\n\")\n   }\n}\n\n// C entry point to call from JavaScript\nint timer_main() {\n   printf(\"the timer will trigger 5 times...\\n\");\n\n   int t2_eventid=twr_register_callback(\"on_timer2\");\n   t2_id=twr_timer_repeat(500, t2_eventid);\n}\n</code></pre>"},{"location":"gettingstarted/events/#examples","title":"Examples","text":"Name View Live Link Source Link timer example View timer test Source library example View library example Source"},{"location":"gettingstarted/events/#events","title":"Events","text":"<p>In twr-wasm, certain APIs can trigger events.  For example a timer can trigger a \"timer complete\" event, or an audio api my trigger a \"file has finished playing\" event.  An event had an <code>id</code> and an associated callback.  The <code>id</code> is an integer that identifies the event (<code>int event_id</code>).   In order to receive an event call back:</p> <ol> <li>Write your callback in C/C++.  It must be C linkage, and you should be exported from your C code to JavaScript/TypeScript using the <code>export_name</code> clang <code>__attribute__</code> like this: <code>__attribute__((export_name(\"on_timer2\")))</code>. Replace <code>on_timer2</code> with your callback function name.</li> <li>Register your callback.  This will also allocate the event ID paired to this callback.  For example: <code>int t2_event_id=twr_register_callback(\"on_timer2\");</code></li> <li>Call an API that takes an event <code>id</code>.  For example: <code>twr_timer_repeat(500, t2_eventid);</code>.  This will call the <code>t2_event</code> callback every 500ms.</li> </ol> <p>You can use the same event/callback with multiple APIs if you wish.  When the event callback is called, the first argument will be the event <code>id</code> triggering the callback.  There may then be optional parameters.  These are event specific.</p> <p>As in JavaScript, twr-wasm event callbacks only occur when your C/C++ code is not running. </p>"},{"location":"gettingstarted/events/#when-using-twrwasmmoduleasync","title":"When using twrWasmModuleAsync","text":"<p>With a <code>twrWasmModuleAsync</code> module, various blocking APIs are available. For example: <code>twr_sleep</code>.  When these functions are blocking (waiting), event callbacks are queued and not processed until your C functions return back to JavaScript.</p> <p>With a <code>twrWasmModuleAsync</code> module, events are sent from the JavaScript main thread to the worker thread that is running the C/C++ code.</p>"},{"location":"gettingstarted/events/#twr_register_callback","title":"twr_register_callback","text":"<p>See twr_register_callback</p>"},{"location":"gettingstarted/helloworld/","title":"Create and Run WebAssembly Hello World","text":"<p>This section shows you, step by step, how to to create a C \"hello world\" program for WebAssembly (Wasm) with twr-wasm, C, HTML, and JavaScript.</p> <p>You will learn how to:</p> <ul> <li>Create the helloworld.c file</li> <li>Create the index.html file</li> <li>Compile the helloworld.c code with <code>clang</code></li> <li>Link the helloworld.o and twr.a files with <code>wasm-ld</code> to create a helloworld.wasm file</li> <li>Set the needed library and include paths to allow the twr-wasm libraries to be discovered</li> <li>Create an optional Makefile</li> <li>Execute the \"hello world\" program using a local web server or directly with VS Code and Chrome</li> </ul> <p>You can find code for a hello world example in the folder examples\\helloworld.  It is similar, but not identical to this walk through.  The primary differences are the paths for lib-c, lib-js, and include.</p>"},{"location":"gettingstarted/helloworld/#step-0-installation","title":"Step 0: Installation","text":"<ul> <li>prerequisites: install clang, wasm-ld, and python or VS Code (or both)</li> <li>Create a folder for your project, such as <code>hello-proj</code></li> <li><code>cd</code> into <code>hello-proj</code></li> <li><code>npm install twr-wasm</code></li> <li>your folder structure should now look similar to this: <pre><code>hello-proj\\\n\u251c\u2500\u2500package.json\n\u2514\u2500\u2500node_modules\\\n   \u2514\u2500\u2500twr-wasm\\\n      \u251c\u2500\u2500examples\\\n      \u2514\u2500\u2500include\\\n      \u2514\u2500\u2500lib-c\\\n      \u2514\u2500\u2500lib-js\\\n      \u2514\u2500\u2500LICENSE\n      \u2514\u2500\u2500package.json\n      \u2514\u2500\u2500readme.md\n</code></pre></li> </ul>"},{"location":"gettingstarted/helloworld/#step-1-create-the-c-code","title":"Step 1: Create the C code","text":"<p>Create a file <code>helloworld.c</code> in <code>hello-proj</code> helloworld.c<pre><code>#include &lt;stdio.h&gt;\n\nvoid hello() {\n   printf(\"hello world\\n\");\n}\n</code></pre></p>"},{"location":"gettingstarted/helloworld/#step-2-create-the-html","title":"Step 2: Create the HTML","text":"<p>Create a file <code>index.html</code> in <code>hello-proj</code> index.html<pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n   &lt;title&gt;Hello World&lt;/title&gt;\n\n   &lt;script type=\"importmap\"&gt;\n   {\n      \"imports\": {\n      \"twr-wasm\": \"./node_modules/twr-wasm/lib-js/index.js\"\n      }\n   }\n   &lt;/script&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n   &lt;div id=\"twr_iodiv\"&gt;&lt;/div&gt;\n\n   &lt;script type=\"module\"&gt;\n      import {twrWasmModule} from \"twr-wasm\";\n\n      const mod = new twrWasmModule();\n      await mod.loadWasm(\"./helloworld.wasm\");\n      await mod.callC([\"hello\"]);\n   &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <p>This example uses Import Maps, which are used when not using a bundler like WebPack or Parcel.  For smaller projects, this can be simpler with a more clear debugging and development environment.  This is the approach we will use for this example (no bundler).</p> <p>The path in the <code>importmap</code> section of <code>index.html</code> should point to the location where you installed <code>twr-wasm/lib-js</code>.  The path above is correct for this project example with the indicated folder structure.</p> <p>For more detail on import resolution see this section.</p>"},{"location":"gettingstarted/helloworld/#step-3-compile-your-c-code-to-create-your-wasm-file","title":"Step 3: Compile your C code to create your .wasm file","text":"<pre><code>cd hello-proj\nclang --target=wasm32 -nostdinc -nostdlib -isystem ./node_modules/twr-wasm/include -c  helloworld.c -o helloworld.o\nwasm-ld  helloworld.o ./node_modules/twr-wasm/lib-c/twr.a -o helloworld.wasm  --no-entry --initial-memory=131072 --max-memory=131072 --export=hello \n</code></pre> <p>The path to <code>twr.a</code> and to <code>include</code>  should match your installation.  The above path is correct for this example.</p> <p>As an alternate to executing clang and wasm-ld from the shell, here is a Makefile that will work for this example:</p> Makefile<pre><code>CC := clang\nTWRCFLAGS := --target=wasm32 -nostdinc -nostdlib -isystem  ./node_modules/twr-wasm/include\nCFLAGS := -c -Wall -O3 $(TWRCFLAGS)\nCFLAGS_DEBUG := -c -Wall -g -O0  $(TWRCFLAGS)\n\n.PHONY: default\n\ndefault: helloworld.wasm\n\nhelloworld.o: helloworld.c\n    $(CC) $(CFLAGS)  $&lt; -o $@\n\nhelloworld.wasm: helloworld.o \n    wasm-ld  helloworld.o ./node_modules/twr-wasm/lib-c/twr.a -o helloworld.wasm \\\n        --no-entry --initial-memory=131072 --max-memory=131072 \\\n        --export=hello \n</code></pre> <p>Copy the above into a file named <code>Makefile</code> and execute with <code>make</code> (or <code>mingw32-make</code> in windows).</p>"},{"location":"gettingstarted/helloworld/#step-4-load-and-execute-your-web-page","title":"Step 4: Load and execute your web page","text":"<p>The two easiest ways to load and execute your <code>index.html</code> web page locally are:</p>"},{"location":"gettingstarted/helloworld/#option-a-run-a-local-web-server","title":"Option A: Run a local web Server","text":"<p>You can run a local server to view your helloworld program.  </p> <ul> <li>Copy the file server.py from the examples folder to your <code>hello-proj</code> folder (where your <code>index.html</code> resides).  </li> <li>Execute with the shell command <code>python server.py</code>.</li> <li>Open your web browser and browse to <code>http://localhost:8000/index.html</code></li> <li>You should see 'Hello World' in the browser window!</li> </ul> <p>At this pont your folder structure should look like this:</p> <pre><code>hello-proj\\\n\u2514\u2500\u2500node_modules\\\n\u2514\u2500\u2500helloworld.c\n\u2514\u2500\u2500helloworld.o\n\u2514\u2500\u2500helloworld.wasm\n\u2514\u2500\u2500index.html\n\u2514\u2500\u2500Makefile\n\u2514\u2500\u2500package.json\n\u2514\u2500\u2500server.py\n</code></pre>"},{"location":"gettingstarted/helloworld/#option-b-vs-code-launchjson","title":"Option B: VS Code launch.json","text":"<p>Alternately, you can launch chrome without a local web server.  Add an entry similar to the following to  <code>hello-proj\\.vscode\\launch.json</code>.  This assumes your workspaceFolder is <code>hello-proj</code>.</p> launch.json<pre><code>{\n    \"configurations\": [\n    {\n        \"name\": \"Launch Chrome Hello, World!\",\n        \"request\": \"launch\",\n        \"type\": \"chrome\",\n        \"runtimeArgs\": [\n            \"--allow-file-access-from-files\",\n            \"--autoplay-policy=no-user-gesture-required\",\n            \"--enable-features=SharedArrayBuffer\"\n         ],\n         \"file\": \"${workspaceFolder}/index.html\",\n         \"cwd\": \"${workspaceFolder}/\",\n    }\n    ]\n}\n</code></pre> <p>Once you have created this file, you:</p> <ul> <li>select the Run and Debug icon on left</li> <li>Select the green play icon at the top, with \"Launch Chrome Hello, World!\" selected</li> <li>Chrome should launch, and you should see 'Hello World' in the browser window!</li> </ul> <p><code>--autoplay-policy=no-user-gesture-required</code> and <code>--enable-features=SharedArrayBuffer</code> are not required for this simple \"hello world\" example, but will be needed if you request user input or you are using <code>twrWasModuleAsync</code>.</p>"},{"location":"gettingstarted/helloworld/#see-live-version","title":"See live version","text":"<p>You can find a live link to hello world on this page.</p>"},{"location":"gettingstarted/helloworld/#next-steps-after-hello-world","title":"Next steps after hello world","text":"<p>A good way to get your own code up and running is to copy one of the examples, get it to build and run, then start modifying it.  Note you will need to modify the paths for <code>include</code>, <code>lib-js</code>, <code>lib-c</code>, etc. based on your project structure.  The examples are all setup with relative paths assuming the folder structure <code>twr-wasm\\examples\\&lt;example&gt;</code></p> <p>The examples include Makefiles.</p> <p>\"Hello World\" uses the twr-wasm class <code>twrWasmModule</code>.   If you wish to use C blocking functions, such as <code>twr_getc32</code> or <code>twr_sleep</code>, you should use <code>twrWasmModuleAsync</code>.  This square calculator example shows how to do this.  </p> <p>If you wish to build an app that makes non-block calls into C, the balls example shows how to do this. The maze example uses a combination of blocking and non-blocking C functions.</p>"},{"location":"gettingstarted/helloworld/#debugging","title":"Debugging","text":"<p>See the debugging section for debugging tips, including setting up Wasm source level debugging.</p>"},{"location":"gettingstarted/installation/","title":"Installing twr-wasm","text":"<p>A simple way to install twr-wasm is: <pre><code>npm install twr-wasm\n</code></pre></p> <p>See the \"Hello World walk through\" in the following section for more specifics.</p> <p>There are actually two methods of installation with different pros and cons:</p> <ul> <li><code>npm install</code> will install everything necessary to build your software: built libraries (lib-js, lib-c) and includes.  In addition the examples are installed.</li> <li><code>git clone</code> will copy the above as well as the source and VS Code settings.</li> </ul> <p>When using <code>twr-wasm</code> your applications needs to access both JavaScript and C twr-wasm libraries.  This is explained in the installation sections below, as well as in the Hello World walk through.</p>"},{"location":"gettingstarted/installation/#npm-install","title":"npm install","text":"<p><pre><code>npm install twr-wasm\n</code></pre> After installation from npm, you will have a folder structure like this:</p> <p><pre><code>node_modules\\\n   twr-wasm\\\n      examples\\\n      include\\\n      lib-c\\\n      lib-js\\\n      LICENSE\n      package.json\n      readme.md\n</code></pre> The JavaScript and TypeScript exports are in <code>lib-js</code> and should be found by VS Code, TypeScript or your bundler as usual when using a statement like <code>import {twrWasmModule} from \"twr-wasm\"</code>.  </p> <p>The C library (<code>twr.a</code>) that you will need to link your C/C++ program to is found in the <code>libs-c</code> folder, and the C/C++ include files that you will need to use in your C/C++ program are found in the <code>include</code> folder.  You will need to use paths to to these folders in your makefile. See the Hello World walk through for details. </p> <p>There is no real downside to this installation method, except possibly: (1) it does not include source code (use git clone for that), and (b) the C libraries are buried inside your node_modules.</p>"},{"location":"gettingstarted/installation/#git-install","title":"git install","text":"<pre><code> git clone https://github.com/twiddlingbits/twr-wasm\n</code></pre> <p>This method of installation installs the complete code base, including source and built binaries.</p> <p>After twr-wasm is cloned, use VS Code <code>File | Open Folder</code>.</p> <p>See here for information on running the examples or building the examples.</p> <p>See here for information on building the source.</p> <p>The primary downside to this method is that the JavaScript side of twr-wasm will not be placed in a node_modules folder. This will create a little extra work to configure a bundler, TypeScript or VS Code to find the location of the twr-wasm module imports.</p> <p>There are a few solutions to this.  For example, in the provided Hello World example, a <code>package.json</code> file with an <code>alias</code> entry is used.  This syntax is supported by the Parcel bundler:</p> <pre><code>{\n   \"@parcel/resolver-default\": {\n      \"packageExports\": true\n   },\n   \"alias\": {\n      \"twr-wasm\": \"../../lib-js/index.js\"\n   },\n   \"dependencies\": {\n      \"twr-wasm\": \"^2.0.0\"\n   }\n}\n</code></pre> <p>The FFT example uses the <code>paths</code> entry in the <code>tsconfig.json</code> file.  This is found by TypeScript, VS Code and the Parcel bundler.  This is probably the best solution if you are using TypeScript.</p> <pre><code>\"paths\": {\n   \"twr-wasm\": [\"./../../lib-js/index\"]\n}\n</code></pre> <p>The paths for <code>alias</code> and <code>paths</code> shown above are correct for the included examples, but will likely need to be adjust for your project.</p> <p>For more details see this section on Import Resolution</p>"},{"location":"gettingstarted/installation/#clang-and-wasm-ld","title":"clang and wasm-ld","text":"<p>To build C/C++ code for use in your Wasm project, you will need to install clang and the wasm-ld linker.  If you are using Windows, more details can be found at the end of the Building Source section.</p>"},{"location":"gettingstarted/installation/#python-and-more","title":"python and more","text":"<p>To use the included <code>examples\\server.py</code> to execute your project you will need to install python.  <code>server.py</code> is a simple HTTP server for local testing that sets the correct CORS headers for <code>twrWasmModuleAsync</code>.  As explained in the Hello World walk through, you can alternately execute HTML files directly using VS Code and Chrome.</p> <p>You will likely want these tools installed to use twr-wasm:</p> <ul> <li>gnu make (all the examples use make)</li> <li>VS Code (not required, but the repo includes VS Code launch.json, etc)</li> <li>TypeScript (not required, but the twr-wasm source code is TypeScript)</li> </ul>"},{"location":"gettingstarted/installation/#note-on-examples","title":"Note on Examples","text":"<p>You can run the examples either locally or with the online versions.</p>"},{"location":"gettingstarted/parameters/","title":"Passing Function Arguments to WebAssembly","text":"<p>This article describes techniques to transfer data between JavaScript/TypeScript and C/C++ when using WebAssembly. It delves a bit \u201cunder the covers\u201d to explain how this works when you use a library like twr-wasm or Emscripten. In this article, I am using twr-wasm for the examples. Emscripten does something similar.</p> <p>For an example that illustrates the concepts discussed here, see: the callC example.</p>"},{"location":"gettingstarted/parameters/#webassembly-virtual-machine-intrinsic-capabilities","title":"WebAssembly Virtual Machine Intrinsic Capabilities","text":"<p>The WebAssembly VM (often referred to as a Wasm \u201cRuntime\u201d) is limited to passing numbers between C functions and the Wasm host (I\u2019ll assume that\u2019s JavaScript for this document). In other words, if you are using the most basic WebAssembly capabilities provided by JavaScript, such as <code>WebAssembly.Module</code>, <code>WebAssembly.Instance</code>, and <code>instance.exports</code>, your function calls and return types can only be:</p> <ul> <li>Integer 32 or 64 bit</li> <li>Floating point 32 or 64 bit</li> </ul> <p>These correspond to the WebAssembly spec support for: i32, i64, f32, and f64. </p> <p>Note that a JavaScript <code>number</code> is of type Float 64 (known as a <code>double</code> in C/C++.).  If you are storing an integer into a JavaScript <code>number</code>, it is converted to a Float 64, and its maximum \"integer\" precision is significantly less than 64 bits (its about 52 bits, but this is a simplification).  As a result, to use a 64-bit integers with JavaScript the <code>bigint</code> type is used. </p> <p>When using 32-bit WebAssembly (by far the most common default), and you call a C function from JavaScript without using any \u201chelper\u201d libraries (like twr-wasm), the following argument types can be passed:</p> <ul> <li>Integer 32: JavaScript <code>number</code> type is converted to an Integer 32 and passed to C when the C function prototype specifies a <code>signed or unsigned int</code>, <code>long</code>, <code>int32_t</code>, or a pointer type. All of these are 32 bits in length in wasm32.</li> <li>Integer 64: JavaScript <code>bigint</code> type is converted to an Integer 64 and passed to C when the C function prototype specifies signed or unsigned <code>int64_t</code> (or equivalent).  Attempting to pass a JavaScript <code>number</code> to a C <code>int64_t</code> will fail with a JavaScript runtime error.</li> <li>Float 32: JavaScript <code>number</code> type is converted to a Float 32 when the C function prototype specifies a <code>float</code>.</li> <li>Float 64: JavaScript <code>number</code> type is passed as a Float 64 when the C function prototype specifies a <code>double</code>.</li> </ul> <p>The same rules apply to the return types.</p>"},{"location":"gettingstarted/parameters/#c-structs-javascript-c","title":"C Structs: JavaScript &lt;--&gt; C","text":"<p>This section shows how to create a C <code>struct</code> in JavaScript, then pass it to a C function, and then read the modified C <code>struct</code> in JavaScript.  </p> <p>Although the techniques described here are explained with a <code>struct</code> example, the basic techniques are used with other data types as well (such as strings).  For common data types, like a string, libraries like twr-wasm will handle these details for you automatically.</p> <p>To create and pass a C <code>struct</code> from JavaScript to C, the technique is to call the WebAssembly C <code>malloc</code> from JavaScript to allocate WebAssembly memory and then manipulating the memory in JavaScript. One complexity is that each struct entry\u2019s memory address needs to be calculated. And when calculating the WebAssembly Memory indices for the struct entries, C structure padding must be accounted for. </p>"},{"location":"gettingstarted/parameters/#struct-entry-padding","title":"struct Entry Padding","text":"<p>Before we delve into the actual code, lets review C struct entry padding.</p> <p>In clang, if you declare this structure in your C code:</p> <pre><code>struct test_struct {\n    int a;\n    char b;\n    int *c;\n};\n</code></pre> <ul> <li>The first entry, <code>int a</code>, will be at offset 0 in memory (from the start of the <code>struct</code> in memory).</li> <li>The second entry, <code>char b</code>, will be at offset 4 in memory. This is expected since the length of an int is 4 bytes.</li> <li>The third entry, <code>int *c</code>, will be at offset 8 in memory, not at offset 5 as you might expect. The compiler adds three bytes of padding to align the pointer to a 4-byte boundary.</li> </ul> <p>This behavior is dependent on your compiler, cpu, and whether you are using 32 or 64-bit architecture. For wasm32 with clang:</p> <ul> <li>char is 1 byte aligned</li> <li>short is 2 byte aligned</li> <li>pointers are 4 byte aligned</li> <li>int, long, int32_t are 4 byte aligned</li> <li>double (Float 64) is 8-byte aligned</li> </ul> <p>If you are not familiar with structure padding, there are many articles on the web.</p> <p>Alignment requirements are why twr-wasm <code>malloc</code> (and GCC <code>malloc</code> for that matter) aligns new memory allocations on an 8-byte boundary.</p>"},{"location":"gettingstarted/parameters/#creating-a-struct-in-javascript","title":"Creating a struct in JavaScript","text":"<p>We can create and initialize the above <code>struct test_struct</code> like this in JavaScript:</p> <pre><code>//...\nconst mod = new twrWasmModule();\n//...\nconst structSize=12;\nconst structIndexA=0;\nconst structIndexB=4;\nconst structIndexC=8;   // compiler allocates pointer on 4 byte boundaries\nlet structMem=mod.wasmMem.malloc(structSize);\nlet intMem=mod.wasmMem.malloc(4);\nmod.wasmMem.setLong(structMem+structIndexA, 1);\nmod.wasmMem.mem8[structMem+structIndexB]=2;    // you can access the memory directly with the mem8, mem32, and memD (float64 aka double) byte arrays.\nmod.wasmMem.setLong(structMem+structIndexC, intMem);\nmod.wasmMem.setLong(intMem, 200000);\n</code></pre> <p>note that:</p> <ul> <li><code>mod.wasmMem.malloc(structSize)</code> is a shortcut for: <code>mod.callC([\"malloc\", structSize])</code></li> <li><code>mod.wasmMem.malloc</code> returns a C pointer as a <code>number</code>.  This pointer is also an index into <code>WebAssembly.Memory</code> -- which is exposed as the byte array (<code>Uint8Array</code>) via <code>mod.wasmMem.mem8</code> by twr-wasm.</li> <li>When accessing a C <code>struct</code> in JavaScript/TypeScript, you have to do a bit of arithmetic to find the correct structure entry.</li> <li>The entry <code>int *c</code> is a pointer to an <code>int</code>.  So a separate <code>malloc</code> to hold the <code>int</code> is needed. </li> <li>In twr-wasm there is no function like <code>setLong</code> to set a byte.  Instead you access the byte array view of the WebAssembly memory with <code>mod.wasmMem.mem8</code>.  Functions like <code>mod.wasmMem.setLong</code> manipulate this byte array for you.</li> <li>As well as <code>mod.wasmMem.mem8</code> (Uint8Array), you can also access WebAssembly.Memory directly via <code>mod.wasmMem.mem32</code> (Uint32Array), and <code>mod.wasmMem.memD</code> (Float64Array).</li> <li>The list of functions available to access WebAssembly.Memory can be found at the end of this page.</li> </ul>"},{"location":"gettingstarted/parameters/#passing-struct-to-c-from-javascript","title":"Passing struct to C from JavaScript","text":"<p>Assume we have C code that adds 2 to each entry of the <code>test_struct</code>:</p> <pre><code>__attribute__((export_name(\"do_struct\")))\nvoid do_struct(struct test_struct *p) {\n    p-&gt;a=p-&gt;a+2;\n    p-&gt;b=p-&gt;b+2;\n    (*p-&gt;c)++;\n    (*p-&gt;c)++;\n}\n</code></pre> <p>Once the <code>struct</code> has been created in JavaScript, you can call the C function <code>do_struct</code> that adds 2 to each entry like this in twr-wasm:</p> <pre><code>await mod.callC([\"do_struct\", structMem]);  // will add two to each value\n</code></pre>"},{"location":"gettingstarted/parameters/#reading-c-struct-in-javascript","title":"Reading C struct in JavaScript","text":"<p>You read the modified elements like this using JavaScript:</p> <pre><code>success=mod.wasmMem.getLong(structMem+structIndexA)==3;\nsuccess=success &amp;&amp; mod.wasmMem.mem8[structMem+structIndexB]==4;\nconst intValPtr=mod.wasmMem.getLong(structMem+structIndexC);\nsuccess=success &amp;&amp; intValPtr==intMem;\nsuccess=success &amp;&amp; mod.wasmMem.getLong(intValPtr)==200002;\n</code></pre> <p>You can see the additional complexity of de-referencing the <code>int *</code>.</p>"},{"location":"gettingstarted/parameters/#cleanup","title":"Cleanup","text":"<p>You can free the malloced memory like this:</p> <pre><code>mod.wasmMem.free(intMem);\nmod.wasmMem.free(structMem);\n</code></pre> <p>The complete code for this example is here.</p>"},{"location":"gettingstarted/parameters/#passing-strings-from-javascript-to-cc-webassembly","title":"Passing Strings from JavaScript to C/C++ WebAssembly","text":"<p>Although you can use the technique I am about to describe here directly (by writing your own code), it is generally accomplished by using a third-party library such as twr-wasm or Emscripten. These libraries handle the nitty-gritty for you. </p> <p>To pass a string from JavaScript/TypeScript to a WebAssembly module, the general approach is to:</p> <ul> <li>Allocate memory for the string inside the WebAssembly memory. This is typically done by calling the C <code>malloc</code> from JavaScript. <code>malloc</code> returns a pointer, which is an index into the WebAssembly Memory.</li> <li>Copy the JavaScript string to this malloc'd Wasm memory. In the case of twr-wasm, this copying also converts the character encoding as necessary, for example, to UTF-8.</li> <li>Pass the malloc'd memory index to your function as an integer (which is accepted as a pointer by C code).</li> </ul> <p>In the case of twr-wasm, the above steps are handled automatically for you by the <code>callC</code> function:</p> <pre><code>mod.callC([\"my_function\", \"this is my string\"]);  // mod is instance of twrWasmModule\n</code></pre> <p>Under the covers, to pass \"this is my string\" from JavaScript to the C Web Assembly function, <code>callC</code> will execute code like this:</p> <p><pre><code>// twrWasmMemory member function\nputString(sin:string, codePage = codePageUTF8) {\n    const ru8 = this.stringToU8(sin, codePage);  // convert a string to UTF8 encoded characters stored in a Uint8Array\n    const strIndex = this.malloc(ru8.length + 1);  // shortcut for: await this.callC([\"malloc\", ru8.length + 1]);\n    this.mem8.set(ru8, strIndex);  // mem8 is of type Uint8Array and is the Wasm Module\u2019s Memory\n    this.mem8[strIndex + ru8.length] = 0;\n    return strIndex;\n}\n</code></pre> <code>this.malloc</code> is the standard C runtime <code>malloc</code> function, provided by twr-wasm, and linked into your <code>.wasm</code> code that is loaded into the WebAssembly Module. Likewise, twr-wasm will call <code>free</code> after the function call is executed.</p>"},{"location":"gettingstarted/parameters/#returning-a-string-from-cc-webassembly-to-javascript","title":"Returning a String from C/C++ WebAssembly to JavaScript","text":"<p>Returning a string from C to JavaScript is the reverse of passing in a string from JavaScript to C. When the \u201craw\u201d WebAssembly capabilities are used (<code>WebAssembly.Module</code>, etc.) and your C code looks like this:</p> <pre><code>return(\"my string\");\n</code></pre> <p>The WebAssembly VM and JavaScript host will cause your JavaScript to receive an unsigned 32-bit integer. This is the pointer to the string, cast to an unsigned 32-bit integer. This integer is an index into the WebAssembly Memory.</p> <p>twr-wasm provides a function to pull the string out of WebAssembly Memory and convert the character encoding to a JavaScript string. JavaScript strings are Unicode 16, but twr-wasm supports ASCII, UTF-8, and windows-1252 string encoding. When extracted and converted, a copy of the string is made.</p> <pre><code>const retStringPtr = await mod.callC([\"ret_string_function\"]);\nconsole.log(mod.wasmMem.getString(retStringPtr));\n</code></pre> <p>The <code>retStringPtr</code> is an integer 32 (but converted to a JavaScript <code>number</code>, which is Float 64). This integer is an index into the WebAssembly Memory.</p>"},{"location":"gettingstarted/parameters/#passing-arraybuffers-from-javascript-to-cc-webassembly","title":"Passing ArrayBuffers from JavaScript to C/C++ WebAssembly","text":"<p>When <code>callC</code> in twr-wasm is used to pass an ArrayBuffer to and from C/C++, some details are handled for you. The technique is similar to that used for a <code>string</code> or as performed manually for a <code>struct</code> above, with the following differences:</p> <ul> <li><code>ArrayBuffers</code> have entries of all the same length, so the index math is straight forward and no <code>struct</code> padding is needed.</li> <li>When an <code>ArrayBuffer</code> is passed to a function, the function receives a pointer to the <code>malloc</code> memory. If the length is not known by the function, the length needs to be passed as a separate argument.</li> <li>Before <code>callC</code> returns, any modifications made to the memory by the C code are reflected back into the <code>ArrayBuffer</code>.</li> <li>the malloced copy of the ArrayBuffer is freed.</li> </ul> <p>Here is an example:</p> <pre><code>let ba = new Uint8Array(4);\nba[0] = 99; ba[1] = 98; ba[2] = 97; ba[3] = 6;\nconst ret_sum = await mod.callC([\"param_bytearray\", ba.buffer, ba.length]);\n</code></pre> <p>See this example for the complete example.</p>"},{"location":"gettingstarted/parameters/#passing-a-javascript-object-to-webassembly","title":"Passing a JavaScript Object to WebAssembly","text":""},{"location":"gettingstarted/parameters/#simple-case-use-c-struct","title":"Simple Case - use C struct","text":"<p>For a simple object like this: <pre><code>const a = 'foo';\nconst b = 42;\n\nconst obj = {\n  a: a,\n  b: b\n};\n</code></pre></p> <p>It is straightforward to convert to a C struct like this: <pre><code>struct obj {\n    const char* a;\n    int b;\n};\n</code></pre> To pass this JavaScript object to WebAssembly, a C struct is created (using the <code>struct</code> techniques described above).  Each object entry is then copied into the corresponding C <code>struct</code> entry (using the <code>struct</code> and string techniques described above).</p>"},{"location":"gettingstarted/parameters/#more-complicated-object","title":"More Complicated Object","text":"<p>A JavaScript object can contain entries that are of more complexity than simple C data types.  For example:</p> <pre><code>const a = 'foo';\nconst b = 42;\nconst map = new Map();\nmap1.set('a', 1);\nmap1.set('b', 2);\nmap1.set('c', 3);\nconst object2 = { a: a, b: b, c: map };\n</code></pre> <p>In this case, you are going to have to do more work.  An approach is to use the libc++ <code>map</code> class, which is similar to the JavaScript <code>Map</code>.  You could also perhaps use the libc++ <code>vector</code>.  </p> <p>To handle this more complicated JavaScript object with a <code>Map</code> entry, an approach is to export functions from WebAssembly to create and add entries to the libc++ <code>map</code> (you need to use <code>extern 'C'</code> to export these C++ access functions as C functions).  In otherworld, you might export from your Wasm Module C functions like this:</p> <pre><code>void* createMap();   // return an unsigned long Map ID\nvoid addIntToMap(void* mapID, int newInt);\n</code></pre> <p>You would then use these functions in JavaScript to build your C++ <code>map</code>.  JavaScript would access this <code>map</code> using the <code>unsigned long</code> identifier (the <code>void *</code> returned by <code>createMap</code>).  After creating and adding entries to the <code>map</code>, you would set this MapID to <code>object2.c</code>.</p> <p>There are alternative approaches.  For example, you could convert the JavaScript <code>Map</code> to a C struct, by enumerating every entry in the <code>Map</code>.  Your C struct might look like: ` <pre><code>struct entry {\n    char* name;\n    int value;\n};\n\nstruct mapUnroll {\n    int MapLen;\n    struct entry* entries[];\n};\n</code></pre></p> <p>This approach is probably even more work, less general purpose, and less efficient.</p>"},{"location":"gettingstarted/parameters/#summary","title":"Summary","text":"<p>I hope this has demystified how JavaScript values are passed to and from WebAssembly.  In many cases, functions like twr-wasm's <code>mod.callC</code> will handle the work for you.  But in more bespoke cases, you will have to handle some of the work yourself.</p>"},{"location":"gettingstarted/stdio/","title":"Overview of Consoles","text":"<p>This section describes how to use twr-wasm to:</p> <ul> <li>create input/output consoles for use by C/C++ with WebAssembly</li> <li>direct stdin, stdout and stderr to a console</li> <li>use addressable display and canvas 2D consoles</li> <li>use multiple consoles at once</li> </ul>"},{"location":"gettingstarted/stdio/#quick-example","title":"Quick Example","text":"Hello World<pre><code>#include &lt;stdio.h&gt;\n\nvoid hello() {\n    printf(\"hello world\\n\");\n}\n</code></pre> Using twrConsoleDiv<pre><code>&lt;body&gt;\n   &lt;div id=\"console-tag\"&gt;&lt;/div&gt;\n\n   &lt;script type=\"module\"&gt;\n      import {twrConsoleDiv, twrWasmModule} from \"twr-wasm\";\n\n      const tag=document.getElementById(\"console-tag\");\n      const streamConsole=new twrConsoleDiv(tag); \n      const mod = new twrWasmModule({stdio: streamConsole});\n      await mod.loadWasm(\"./helloworld.wasm\");\n      await mod.callC([\"hello\"]);\n\n   &lt;/script&gt;\n&lt;/body&gt;\n</code></pre> Using twr_iodiv Shortcut<pre><code>&lt;body&gt;\n   &lt;div id=\"twr_iodiv\"&gt;&lt;/div&gt;\n\n   &lt;script type=\"module\"&gt;\n      import {twrWasmModule} from \"twr-wasm\";\n\n      const mod = new twrWasmModule();\n      await mod.loadWasm(\"./helloworld.wasm\");\n      await mod.callC([\"hello\"]);\n\n   &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"gettingstarted/stdio/#running-examples","title":"Running Examples","text":"Name View Live Link Source Link stdin and stdout to <code>&lt;div&gt;</code> View square demo Source simple \"terminal\" via <code>&lt;canvas&gt;</code> View hello world demo Source \"cli\" with a <code>&lt;canvas&gt;</code> stdio View CLI demo using libc++ Source Multiple Consoles, including Canvas2D View multi-io demo Source"},{"location":"gettingstarted/stdio/#capabilities","title":"Capabilities","text":"<p>With a Console you can:</p> <ul> <li>read character streams (Use C statements like  <code>getc</code> or <code>io_mbgets</code>)</li> <li>write character streams (use C statements like <code>printf</code> or <code>cout</code>)</li> <li>position characters, graphics, colors with an addressable display (Use C statements like <code>io_setc32</code> or <code>io_set_cursor</code>).</li> <li>draw to a Canvas compatible 2D surface (Use C statements like <code>d2d_fillrect</code>).</li> </ul> <p>Consoles are primarily designed for use by twr-wasm C/C++ modules, but they can also be used by JavaScript/TypeScript.</p> <p>Although it is common to have a single console, an arbitrary number of consoles can be created, and they can be used by an arbitrary number of twr-wasm C/C++ modules.</p> <p>Unicode characters are supported by consoles (see Character Encoding Support with twr-wasm).</p>"},{"location":"gettingstarted/stdio/#tag-shortcuts","title":"Tag Shortcuts","text":"<p>If you add a <code>&lt;div id=\"twr_iodiv\"&gt;</code>, a <code>&lt;canvas id=\"twr_iocanvas\"&gt;</code>, or a <code>&lt;canvas id=\"twr_d2dcanvas\"&gt;</code> tag to your HTML, twr-wasm will create the appropriate class for you when you instantiate the class <code>twrWasmModule</code> or <code>twrWasmModuleAsync</code>.  Use these tag shortcuts as an aternative to instantiating the console classes in your JavaScript/TypeScript.</p> <ul> <li><code>&lt;div id=\"twr_iodiv\"&gt;</code> will be used to create a <code>twrConsoleDiv</code> as <code>stdio</code></li> <li><code>&lt;canvas id=\"twr_iocanvas\"&gt;</code> will be used to create a <code>twrConsoleTerminal</code> as <code>stdio</code>. </li> <li><code>&lt;canvas id=\"twr_d2dcanvas\"&gt;</code> will be used to create a <code>twrConsoleCanvas</code> as <code>std2d</code> -- the default 2D drawing surface.  See 2D drawing APIs.</li> </ul> <p>If neither of the above <code>&lt;div&gt;</code> or <code>&lt;canvas&gt;</code> is defined in your HTML, and if you have not set <code>stdio</code> via the <code>io</code> or <code>stdio</code> module options, then <code>stdout</code> is sent to the debug console in your browser. And <code>stdin</code> is not available.</p>"},{"location":"gettingstarted/stdio/#console-classes","title":"Console Classes","text":"<p>Consoles are implemented in TypeScript and run in the JavaScript main thread.  This allows consoles to be shared by multiple wasm modules.</p> <p>For simple cases, when you use the tag shortcuts, you won't need to use these console classes directly.  For more bespoke cases, they will come in handy. For details on console classes, see the TypeScript/JavaScript API reference</p> <p>These conosle classes are available in twr-wasm:  </p> <ul> <li><code>twrConsoleDiv</code> streams character input and output to a div tag </li> <li><code>twrConsoleTerminal</code> provides streaming or addressable character input and output using a canvas tag.</li> <li><code>twrConsoleDebug</code> streamings characters to the browser debug console.</li> <li><code>twrConsoleCanvas</code> creates a 2D drawing surface that the Canvas compatible 2d drawing APIs can be used with.</li> </ul>"},{"location":"gettingstarted/stdio/#multiple-consoles-with-names","title":"Multiple Consoles with Names","text":"<p>When you instantiate a class <code>twrWasmModule</code> or <code>twrWasmModuleAsync</code>, you can pass it the module option <code>io</code> -- a javascript object containing name-console attributes. Your C/C++ code can then retrieve a console by name.  This is described in more detail the TypeScript/JavaScript API Reference.</p> <p>Also see the multi-io example.</p>"},{"location":"gettingstarted/stdio/#setting-stdio-and-stderr","title":"Setting stdio and stderr","text":"<p><code>stdio</code> can be defined automatically if you use a Tag Shortcut. <code>stderr</code> streams to the browser's debug console by default. Both can be set to a specific console with the module <code>io</code> option.</p> <p>For example, given:</p> <pre><code>const tag=document.getElementById(\"console-tag\");\nconst streamConsole=new twrConsoleDiv(tag);\n</code></pre> <p>Either of these will set <code>stdio</code> to a streaming <code>div</code> console:</p> <p><pre><code>const mod = new twrWasmModule({stdio: streamConsole});\n</code></pre> <pre><code>const mod = new twrWasmModule({ io: {stdio: streamConsole} });\n</code></pre></p> <p>This option would send stderr and stdio to the same console:</p> <pre><code>const mod = new twrWasmModule({ io: \n   {stdio: streamConsole, stderr: streamConsole} \n});\n</code></pre>"},{"location":"gettingstarted/stdio/#utf-8-or-windows-1252","title":"UTF-8 or Windows-1252","text":"<p>Consoles can support UTF-8 or Windows-1252 character encodings (see Character Encoding Support with twr-wasm).</p>"},{"location":"gettingstarted/stdio/#c-access-to-consoles","title":"C Access To Consoles","text":""},{"location":"gettingstarted/stdio/#io_functions","title":"io_functions","text":"<p><code>io_functions</code> are available to operate on  all character based Consoles.</p>"},{"location":"gettingstarted/stdio/#d2d_functions","title":"d2d_functions","text":"<p><code>d2d_functions</code> are available to operate on Canvas 2D Consoles.</p>"},{"location":"gettingstarted/stdio/#reading-from-a-console","title":"Reading from a Console","text":"<p>Reading from a console is blocking, and so <code>twrWasmModuleAsync</code> must be used to receive keys. There are some specific requirements to note in the <code>twrWasmModuleAsync</code> API docs.</p> <p>You can get characters with any of these functions:</p> <ul> <li><code>io_mbgets</code> - get a multibyte string from a console using the current locale character encoding.   Console must support IO_TYPE_CHARREAD.</li> <li><code>twr_mbgets</code> - the same as <code>io_mbgets</code> with the console set to <code>stdin</code>.</li> <li><code>io_mbgetc</code> - get a multibyte character from an <code>twr_ioconsole_t *</code> (aka <code>FILE *</code>) like <code>stdin</code> using the current locale character encoding</li> <li><code>getc</code> (same as <code>fgetc</code>) - get a single byte from a <code>FILE *</code> (aka <code>twr_ioconsole_t *</code>) -- returning ASCII or extended ASCII (window-1252 encoding)</li> <li><code>io_getc32</code> - gets a 32 bit unicode code point from an <code>twr_ioconsole_t *</code> (which must support IO_TYPE_CHARREAD)</li> </ul>"},{"location":"gettingstarted/stdio/#standard-c-library-functions","title":"Standard C Library Functions","text":"<p>Many of the common standard C library functions, plus twr-wasm specific functions, are available to stream characters to and from the standard input and output console that supports character streaming (most do).</p> <p>In C, a console is represented by <code>twr_ioconsole_t</code>.  In addition, <code>FILE</code> is the same as a <code>twr_ioconsole_t</code> (<code>typedef twr_ioconsole_t FILE</code>).  <code>stdout</code>, <code>stdin</code>, <code>stderr</code> are all consoles.</p> <p><code>#include &lt;stdio.h&gt;</code> to access <code>stdout</code>, <code>stdin</code>, <code>stderr</code>, and <code>FILE</code>.</p> <p><code>FILE</code> is supported for user input and output, and for stderr.  <code>FILE</code> as filesystem I/O is not currently supported.</p>"},{"location":"gettingstarted/stdio/#stdout-and-stderr-functions","title":"stdout and stderr functions","text":"<p>You can use these functions to output to the standard library defines <code>stderr</code> or <code>stdout</code>: <pre><code>fputc, putc, vfprintf, fprintf, fwrite\n</code></pre></p> <p>These functions go to <code>stdout</code>: <pre><code>printf, vprintf, puts, putchar\n</code></pre></p> <p>Note that when characters are sent to the browser console using <code>stderr</code> they will not render to the console until a newline, return, or ASCII 03 (End-of-Text) is sent.</p> <p>For example: <pre><code>#include &lt;stdio.h&gt;\n\nfprintf(stderr, \"hello over there in browser debug console land\\n\");\n</code></pre></p> <p>A more common method to send output to the debug console is to use <code>twr_conlog</code>.</p>"},{"location":"more/building/","title":"Building the twr-wasm Source","text":""},{"location":"more/building/#source-for-twr-wasm","title":"Source for twr-wasm","text":"<p>The source can be found at:</p> <pre><code>https://github.com/twiddlingbits/twr-wasm\n</code></pre> <p>The <code>main</code> branch contains the latest release.  The <code>dev</code> branch is work in progress.</p>"},{"location":"more/building/#tools-needed-to-build-twr-wasm-source","title":"Tools Needed to Build twr-wasm Source","text":"<p>You will need these core tools, versions used in release are in ():</p> <ul> <li>TypeScript (5.4.5)</li> <li>clang tool chain (17.0.6) - for C/C++ code</li> <li>wasm-ld (17.0.6) - to link the .wasm files</li> <li>wat2wasm (1.0.34) - to compile WebAssembly (.wat) files of which I have a few </li> <li>GNU make (4.4.1)</li> <li>git - to clone twr-wasm source, or to clone llvm, if you want to build libc++</li> </ul> <p>In addition, you might need:</p> <ul> <li>VS Code - to use the debug launcher and build tasks</li> <li>NPM - package manager</li> <li>Parcel v2 - to bundle the examples</li> <li>mkdocs, material theme, meta-descriptions plugin - to build the documentation static web site</li> <li>python - mkdocs is built with python, and you need python to run server.py in examples</li> <li>CMake and ninja - to build llvm libc++</li> </ul> <p>There is a deprecated gcc build that I used to use for testing, but now the tests are executed in wasm.</p>"},{"location":"more/building/#to-build-the-libraries-lib-c-lib-js","title":"To Build the Libraries (lib-c, lib-js)","text":"<p><pre><code>cd source\nmake\n</code></pre> or on windows <pre><code>cd source\nmingw32-make\n</code></pre></p>"},{"location":"more/building/#to-build-the-examples","title":"To Build the Examples","text":"<p>See examples/readme.md for more information.</p> <p>To build the examples, but not bundle them.  <pre><code>cd examples\nsh buildall.sh\n</code></pre></p> <p>To build bundles: <pre><code>sh buildbundles.sh\n</code></pre></p>"},{"location":"more/building/#to-build-the-docs","title":"To Build the docs","text":"<p>The docs are created using the material theme for mkdocs.</p> <p>In twr-wasm root folder:</p> <pre><code>mkdocs build\n</code></pre> <p>The destination of the build is found in the <code>mkdocs.yml</code> file (<code>site_dir: azure/docsite/</code>).</p> <p>Usually the docs are built as part of building the static web site that hosts the docs and examples.  This is accomplished using this shell script (found in examples folder): <pre><code>buildazure.sh\n</code></pre></p>"},{"location":"more/building/#to-build-libc-for-wasm-and-twr-wasm","title":"To Build libc++ for Wasm and twr-wasm","text":"<p>See the instructions in the comments in the shell script <code>source\\libcxx\\buildlibcxx.sh</code></p>"},{"location":"more/building/#installing-clang-and-wasm-ld-on-windows","title":"Installing clang and wasm-ld on Windows","text":"<p>Here is how I installed the tools for windows: </p> <pre><code> install  MSYS2 \n   1. https://www.msys2.org/\n   2. After the install completes, run UCRT64 terminal by clicking on the MSYS2 UCRT64 in the Start menu\n   3. pacman -Syuu\n\n install gcc using MSYS2 UCRT64\n   1. Use MSYS2 UCRT64 terminal (per above)\n   1. pacman -S mingw-w64-ucrt-x86_64-toolchain\n\n install clang and wasm-ld using MSYS2 UCRT64\n   2. Use MSYS2 UCRT64  (per above)\n      1. pacman -S mingw-w64-ucrt-x86_64-clang\n      2. pacman -S mingw-w64-x86_64-lld\n\nupdate PATH env variable using the windows control panel (search for path)\n   2. added C:\\msys64\\ucrt64\\bin \n   3. added C:\\msys64\\mingw64\\bin \n   4. added C:\\msys64\\usr\\bin (for sh.exe used by mingw32-make)\n</code></pre> <p>wabt tools:  can be found here https://github.com/WebAssembly/wabt/releases </p>"},{"location":"more/imports/","title":"twr-wasm Import Resolution","text":"<p>This section covers path resolution for statements like this: <pre><code>import {twrWasmModule} from \"twr-wasm\";\n</code></pre></p> <p>It can be confusing to determine how tools like VS Code, a bundler, or a Web Browser resolve imports like \"twr-wasm\".  This section explains how it works, using the included examples as examples.</p> <p>Two situations are addressed in this document: (1) browser import resolution when not using a bundler, and (2) if you installed using <code>git clone</code>.</p>"},{"location":"more/imports/#if-you-installed-using-git-clone","title":"If you installed using <code>git clone</code>","text":"<p>If you have installed <code>twr-wasm</code> using <code>npm</code>, most tools will automatically resolve imports by finding the <code>node_modules</code> folder. </p> <p>However, if you installed using <code>git clone</code>, then other steps will need to be taken to help a bundler, VS Code, and tsc resolve imports.  This situation can apply to the examples, which are in the git repo tree, and as a result there may be no <code>node_modules</code> for the twr-wasm libraries.  This will also be the case for your project, if you installed with <code>git clone</code>.</p>"},{"location":"more/imports/#import-path-resolution-by-the-bundler","title":"Import path resolution by the bundler","text":"<p>A bundler will find the twr-wasm library using one of these methods:</p> <ol> <li>If twr-wasm has been installed with npm install, the bundler will find the <code>node_modules</code> folder</li> <li>Alternately, If all your scripts are in TypeScript, use <code>paths</code>  entry in <code>tsconfig.json</code> (see maze example)</li> <li>Alternately, use alias option in package.json as in the helloworld example <pre><code>     \"alias\": {\n          \"twr-wasm\": \"../../lib-js/index.js\"\n     },\n</code></pre></li> </ol> <p>In the examples, the alias entry in the <code>package.json</code> exists so that the parcel bundler can find twr-wasm.</p> <p>If you are using a bundler, you don't need to add a <code>&lt;script type=\"importmap\"&gt;</code> tag.  </p>"},{"location":"more/imports/#import-resolution-by-vs-code-and-tsc","title":"Import resolution by VS Code and tsc","text":"<p>VS Code Intellisense and the typescript compiler need to find modules.  If twr-wasm is installed using <code>npm</code> into a <code>node_modules</code> folder, this is probably automatic.  But if this is not the case, you can add a line to the <code>tsconfig.json</code> as follows (this example assumes the <code>tsconfig.json</code> is in a examples/example folder).  See the maze example. <pre><code>\"paths\": {\n   \"twr-wasm\": [\"./../../lib-js/index\"]\n}\n</code></pre></p>"},{"location":"more/imports/#import-path-resolution-by-the-browser","title":"Import path resolution by the browser","text":"<p>This section apples to executing your javascript without first \"bundling\" it.  Whether execution is from the filesystem directly in a browser or using a web server. </p> <p>In order for the browser to locate the twr-wasm path when import is used,  you can add code like this to your HTML prior to the import.  You should make sure the path for twr-wasm is correct for your project (this is correct for the examples). <pre><code>&lt;script type=\"importmap\"&gt;\n    {\n        \"imports\": {\n        \"twr-wasm\": \"../../lib-js/index.js\"\n        }\n    }\n&lt;/script&gt;\n</code></pre></p>"},{"location":"more/production/","title":"HTTP CORS headers needed to use twrWasmModuleAsync","text":"<p>If you are using twr-wasm with web pages served by an http server, you may need to enable certain CORS headers.  This applies whether using a remote server or using your local machine for development.</p> <p>twr-wasm class <code>twrWasmModuleAsync</code> uses <code>SharedArrayBuffers</code>, and there are special CORS headers that need to be configured to use <code>SharedArrayBuffers</code>, that are not widely enabled by default on web servers.  It may be helpful to also see the <code>SharedArrayBuffer</code> documentation online.</p> <p>Github pages doesn't support the needed CORS headers for SharedArrayBuffers.  But other web serving sites do have options to enable the needed CORS headers.</p> <p>Here are two provided examples of how to enable the necessary headers:</p> <ul> <li>server.py </li> <li>staticwebapp.config.json </li> </ul> <p>The azure static web site config file <code>staticwebapp.config.json</code> looks like this: <pre><code>{\n    \"globalHeaders\": {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Cross-Origin-Embedder-Policy\": \"require-corp\",\n      \"Cross-Origin-Opener-Policy\": \"same-origin\"\n    }\n}\n</code></pre></p> <p>server.py in the examples folder will launch a local server with the correct headers.  To use Chrome without a web server, see the Hello World walk through.</p>"},{"location":"more/production/#using-twrwasmmoduleasync-with-file","title":"Using twrWasmModuleAsync with file:","text":"<p>If you are loading html with chrome from files (not using an https server), you will need to set these command line args:</p> <pre><code>--enable-features=SharedArrayBuffer\n--allow-file-access-from-files\n</code></pre> <p>More detail is found in the debugging section.</p>"},{"location":"more/wasm-problem/","title":"Wasm Runtime Limitations","text":"<p>HTML browsers can load a WebAssembly module, and execute it's bytecode in a virtual machine.  To create this bytecode (.wasm file) from C/C++, you compile your code using clang with the target code format being WebAssembly (aka Wasm) byte code. If you are not using a support library like twr-wasm or emscripten, there are a few issues that one immediately encounters trying to execute code that is more complicated than squaring a number.  </p> <p>The Wasm virtual machine simply executes the instructions that are generated by the clang compiler and linked by the linker into the .wasm file.  The first issue encountered is that some code that is generated by a compiler assumes a compiler support library will be linked to your code.  That is, clang code generation will produce calls to compiler support routines for floating point, <code>memcpy</code>, and the like. In clang, these support routines are in the \"compile-rt\" support library.  Typically clang handles this behind to scenes for you.  But support for a WebAssembly version of this compiler support library is not (as of this writing) included in a clang distribution.</p> <p>The next level up the library stack is the standard C runtime library.  This library provides functions like <code>malloc</code> and  <code>printf</code>. And then built on the standard C runtime library is the standard c++ library - like libc++.  WebAssembly versions of these libraries are also not part of a clang distribution.  </p> <p>To get access to WebAssembly versions of these libraries you need to use emscripten or twr-wasm.</p> <p>The second problem is that all the function calls between your Wasm module and your javascript are limited to parameters and return values that are numbers (integer and float). No strings, arrays, struct pointers, etc. (for more on this see this doc).</p> <p>The third problem is that legacy C code or games often block, and when written this way they don't naturally integrate with the JavaScript asynchronous programming model.</p> <p>twr-wasm is a static C library (twr.a) that you can link to your clang C/C++ Wasm code, as well as a set of JavaScript/TypeScript modules that solve these issues.</p> <p>In addition, twr-wasm provides APIs that you can use in your WebAssembly code - such as Canvas compatible 2D drawing APIs, a simple terminal emulator, character encoding support, and more.</p>"}]}